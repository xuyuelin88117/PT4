<!-- Programming Taskbook 4.8 | Copyright (c) M. Abramyan, 1998-2009 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>PT4Tasks</title>
<style type="text/css">
H1{font-family:"Arial";font-size:20pt;text-indent:0px;margin-top:10px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
H2{font-family:"Arial";font-size:16pt;text-indent:0px;margin-top:5px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
P{font-family:"Times New Roman";text-align:left;font-size:12pt;text-indent:0px;margin-top:0px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
TD{font-family:"Times New Roman";font-size:12pt;}
LI{font-family:"Times New Roman";font-size:12pt;}
UL{font-family:"Times New Roman";font-size:12pt;}
SUB{font-family:"Times New Roman";font-size:8pt;}
SUP{font-family:"Times New Roman";font-size:8pt;}
TABLE{margin-top:0px; margin-bottom:0px;}
P.ptAuthor{text-align:right;font-size:10pt;font-style:italic;}
P.ptTask{text-align:justify;text-indent:-50px;margin-top:5px; margin-left:60px;}
P.ptTaskQuote{text-align:left;margin-left:120px;margin-top:0px;margin-bottom:0px;}
P.ptTaskCenter{text-align:center;margin-left:60px;margin-top:0px;margin-bottom:0px;}
P.ptTaskContinue{text-align:justify;margin-left:60px;}
P.ptComment{text-align:justify;text-indent:50px;margin-top:5px;}
P.ptCommentCenter{text-align:center;}
P.ptCommentQuote{text-align:left;margin-left:120px;margin-top:0px;margin-bottom:0px;}
P.ptCommentContinue{text-align:justify;}
P.ptFooter{text-align:right;font-size:10pt;font-style:italic;margin-right:0px;}
SPAN.ptSpecial{font-family:"Arial";}
PRE{font-family:"Courier New";text-align:left;font-size:10pt;text-indent:0px;margin-top:5px; margin-right:10px; margin-bottom:0px; margin-left:60px;}
CODE{font-size:10pt;}
TT{font-size:10pt;}
P.ptPicture{font-family:Arial, sans-serif;margin-top: 5px;margin-bottom: 5px;margin-left: 60px;font-size: small;color: #000080;text-indent: 0pt;text-align: justify}
</style>
</head><body>
<h1>Characters and&nbsp;strings</h1>
<p class="ptAuthor">M.&nbsp;E.&nbsp;Abramyan, 2021</p>
<h2>Characters and&nbsp;strings: basic operations</h2>
<p class="ptTask"><span class="ptSpecial">XString8°</span>. Given an integer&nbsp;<i>N</i> (&gt;&nbsp;0) and a character&nbsp;<i>C</i>, output a string that is of length&nbsp;<i>N</i> and contains characters&nbsp;<i>C</i>. </p>
<p class="ptTask"><span class="ptSpecial">XString16°</span>. Given a string, convert all Latin capital letters of the string to lowercase. </p>
<p class="ptTask"><span class="ptSpecial">XString25°</span>. Given a string with the decimal representation of a positive integer, output a new string with the binary representation of this integer. </p>
<p class="ptTask"><span class="ptSpecial">XString30°</span>. Given a character&nbsp;<i>C</i> and two strings&nbsp;<i>S</i>, <i>S</i><sub>0</sub>, insert the string&nbsp;<i>S</i><sub>0</sub> into the string&nbsp;<i>S</i> after each occurrence of the character&nbsp;<i>C</i>. </p>
<p class="ptTask"><span class="ptSpecial">XString40°</span>. A string with at least one blank character is given. Output the substring of&nbsp;<i>S</i> that contains all characters between the first and the last blank character. If the string&nbsp;<i>S</i> contains only one blank character then output an empty string. </p>
<h2>Characters and&nbsp;strings: word processing</h2>
<p class="ptTask"><span class="ptSpecial">XString48°</span>. A string that contains English words separated by one or more blank characters is given. All string letters are in uppercase. Process each word as follows: replace all next occurrences of its first letter by the character &#34;.&#34; (for example, the word &#34;MINIMUM&#34; must be transformed into &#34;MINI.U.&#34;). Do not change blank characters in the string. </p>
<h2>Characters and&nbsp;strings: additional tasks</h2>
<p class="ptTask"><span class="ptSpecial">XString59°</span>. A string that contains a <i>fully qualified path name</i> (that is, the drive and directory parts, the file name and extension) is given. Extract the extension (without the preceding dot character) from the string. </p>
<p class="ptTask"><span class="ptSpecial">XString64°</span>. A string with an encrypted English sentence and an integer&nbsp;<i>K</i> (0&nbsp;&lt;&nbsp;<i>K</i>&nbsp;&lt;&nbsp;10) are given. The string is encrypted by means of the right cyclic shift of any letter by <i>K</i>&nbsp;positions of the English alphabet (see XString63). Decrypt the given string. </p>
<h1>Binary files</h1>
<p class="ptAuthor">M&nbsp;E.&nbsp;Abramyan, 2021</p>
<h2>Binary files: basic operations</h2>
<p class="ptTask"><span class="ptSpecial">XFile13°</span>. A file of integers is given. Create two new files; the first resulting file must contain the given file components (in inverse order) whose values are positive numbers, the second resulting file must contain the given file components (in inverse order too) whose values are negative numbers. If the given file does not contain positive or negative numbers then the corresponding resulting file must be empty. </p>
<p class="ptTask"><span class="ptSpecial">XFile34°</span>. Given a file of integers, remove file components with negative values. </p>
<h2>Work with several numeric files. Archival files</h2>
<p class="ptTask"><span class="ptSpecial">XFile55°</span>. A string&nbsp;<i>S</i><sub>0</sub>, an integer&nbsp;<i>N</i> (&#8804;&nbsp;4), and <i>N</i>&nbsp;files of integers called <i>S</i><sub>1</sub>,&nbsp;&#8230;, <i>S</i><sub><i>N</i></sub> are given. Create a new file called&nbsp;<i>S</i><sub>0</sub>; this file (an <i>archival file</i>) must contain data of all given files in the following format: the amount of components of the file&nbsp;<i>S</i><sub>1</sub> and values of all its components in the same order; the amount of components of the file&nbsp;<i>S</i><sub>2</sub> and values of all its components in the same order;&nbsp;&#8230;; the amount of components of the file&nbsp;<i>S</i><sub><i>N</i></sub> and values of all its components in the same order. </p>
<h2>Files of&nbsp;characters and&nbsp;files of&nbsp;strings</h2>
<p class="ptTask"><span class="ptSpecial">XFile70°</span>. A file of strings is given; the file contains dates in the &#34;day/month/year&#34; format (see XFile67). Write its components that corresponds to winter dates to a new file (in the same order). If the given file does not contain required dates then the resulting file must be empty. </p>
<h1>Text files</h1>
<p class="ptAuthor">M.&nbsp;E.&nbsp;Abramyan, 2021</p>
<h2>Text files: basic operations</h2>
<p class="ptTask"><span class="ptSpecial">XText18°</span>. Given an integer&nbsp;<i>K</i> and a text file, remove <i>K</i>&nbsp;leading characters from each line of the file. If the length of some line is less than&nbsp;<i>K</i> then remove all characters from the line. </p>
<h2>Text analysis and&nbsp;formatting</h2>
<p class="ptTask"><span class="ptSpecial">XText36°</span>. A text file whose lines are right-aligned is given. Make the given text centered by means of removing a half of leading blank characters from all nonempty lines. If the amount of leading blank characters of line is an odd number then remove one blank character from the beginning of this line before centering. </p>
<h2>Text files with numeric data</h2>
<p class="ptTask"><span class="ptSpecial">XText42°</span>. Real numbers&nbsp;<i>A</i>, <i>B</i> and an integer&nbsp;<i>N</i> are given. Create a text file that contains table of values of the function&nbsp;(<i>x</i>)<sup>1/2</sup> at points of the segment&nbsp;[<i>A</i>,&nbsp;<i>B</i>] with the step <i>H</i>&nbsp;=&nbsp;(<i>B</i>&nbsp;&#8722;&nbsp;<i>A</i>)/<i>N</i> (that is, at the points&nbsp;<i>A</i>, <i>A</i>&nbsp;+&nbsp;<i>H</i>, <i>A</i>&nbsp;+&nbsp;2&#183;<i>H</i>,&nbsp;&#8230;, <i>B</i>). The table consists of two columns, the first column contains arguments&nbsp;<i>x</i>, the second one contains the function values&nbsp;(<i>x</i>)<sup>1/2</sup>. The width of the columns is&nbsp;10 and&nbsp;15 characters respectively; the width of the fractional part of arguments and function values is&nbsp;4 and&nbsp;8 respectively; all string representations of numbers are right-aligned with respect to column boundary. </p>
<p class="ptTask"><span class="ptSpecial">XText46°</span>. A text file is given. Each line of the file represents several integers and real numbers that are separated by one or more blank characters. All real numbers have nonzero fractional part. Create a binary file of real numbers that contains all given numbers with nonzero fractional part (in the same order). </p>
<p class="ptTask"><span class="ptSpecial">XText49°</span>. A text file and a binary file of integers are given. Add a string representation of each integer from the binary file to the end of the corresponding line of the text file. If the amount of integers is less than the amount of text lines  then do not change remaining text lines. </p>
<h2>Text files: additional tasks</h2>
<p class="ptTask"><span class="ptSpecial">XText55°</span>. A text file is given. Create a new binary file of characters that contains all characters of the given text (without repetitions) including blank character and punctuation marks. The characters must be in ascending order of their numeric values in the character set. </p>
<h1>Знакомство с&nbsp;итераторами и&nbsp;алгоритмами</h1>
<p class="ptAuthor">М.&nbsp;Э.&nbsp;Абрамян, 2015</p>
<p class="ptComment"> Для всех исходных наборов данных вначале указывается их размер (т.&nbsp;е. количество элементов), а затем значения элементов.</p>
<p class="ptComment">Во всех заданиях группы STL1Iter обработка данных выполняется без использования контейнеров: исходные наборы считываются итератором чтения и сразу передаются требуемому алгоритму, а&nbsp;полученные результаты немедленно выводятся в&nbsp;файл или пересылаются задачнику с&nbsp;помощью соответствующего итератора записи.</p>
<p class="ptComment">Если алгоритм требует применения функционального объекта, то&nbsp;в&nbsp;случае компиляторов, поддерживающих стандарт&nbsp;C++11, следует использовать лямбда-выражения.</p>
<p class="ptComment">В&nbsp;большинстве ситуаций достаточно применять лямбда-выражения без захвата переменных или, если компилятор не&nbsp;поддерживает стандарт&nbsp;C++11, &#8212; обычные функции (см.&nbsp;указание к&nbsp;STL1Iter2). Более сложные задания требуют применения лямбда-выражений с&nbsp;захваченными внешними переменными или структур с&nbsp;дополнительными полями и&nbsp;операцией&nbsp;() (см.&nbsp;указания к&nbsp;STL1Iter8 и&nbsp;STL1Iter9).</p>
<p class="ptTask"><span class="ptSpecial">STL1Iter2°</span>. Дан текстовый файл с именем <i>name</i>, содержащий строковые представления вещественных чисел. Найти количество положительных чисел в исходном файле. Использовать итератор istream_iterator и алгоритм count_if. </p><p class="ptTaskContinue"><span class="ptSpecial">Указание.</span> Если компилятор поддерживает стандарт C++11, то в качестве функционального объекта используйте лямбда-выражение <code>[](double&nbsp;e){&nbsp;return&nbsp;e&nbsp;&gt;&nbsp;0;&nbsp;}</code>, указав его в&nbsp;списке параметров алгоритма.</p>
<p class="ptTaskContinue">В противном случае используйте функцию <code>f</code>, описав ее перед функцией <code>Solve</code> как <code>bool&nbsp;f(double&nbsp;e){&nbsp;return&nbsp;e&nbsp;&gt;&nbsp;0;&nbsp;}</code>.</p>
<p class="ptTask"><span class="ptSpecial">STL1Iter6°</span>. Дана строка <i>name</i> и набор символов. Записать в текстовый файл с именем <i>name</i> исходный набор символов в том же порядке, добавляя после каждого символа пробел. Использовать итераторы ptin_iterator, ostream_iterator и алгоритм copy. </p>
<p class="ptTask"><span class="ptSpecial">STL1Iter8°</span>. Дано целое число <i>K</i> (&gt;&nbsp;0), текстовый файл с именем <i>name1</i>, содержащий английские слова, и строка <i>name2</i>. Записать в текстовый файл с именем <i>name2</i> все слова из исходного файла, длина которых не превосходит&nbsp;<i>K</i>, сохранив исходный порядок их следования и располагая каждое слово на новой строке. Использовать итераторы istream_iterator, ostream_iterator и алгоритм remove_copy_if. </p><p class="ptTaskContinue"><span class="ptSpecial">Указание.</span> Если компилятор поддерживает стандарт C++11, то&nbsp;в&nbsp;качестве функционального объекта используйте лямбда-выражение с&nbsp;захваченной внешней переменной <code>k</code>, указав это лямбда-выражение в&nbsp;списке параметров алгоритма: <code>[k](string&nbsp;e){&nbsp;return&nbsp;e.length()&nbsp;&gt;&nbsp;k;&nbsp;}</code>.</p>
<p class="ptTaskContinue">В противном случае используйте структуру <code>f</code>, которая описывается перед функцией <code>Solve</code>, содержит поле&nbsp;<code>len</code> и&nbsp;операцию&nbsp;(), определенную следующим образом: <code>bool&nbsp;operator()(string&nbsp;e){&nbsp;return&nbsp;e.length()&nbsp;&gt;&nbsp;len;&nbsp;}</code>. В&nbsp;алгоритме указывается конструктор&nbsp;<code>f(k)</code>, инициализирующий поле&nbsp;<code>len</code> значением&nbsp;<code>k</code>.</p>
<p class="ptTask"><span class="ptSpecial">STL1Iter11°</span>. Решить задачу STL1Iter7, используя вместо алгоритма remove_copy цикл for с параметром-итератором. </p><p class="ptTaskContinue"><span class="ptSpecial">Указание.</span> Опишите итератор <code>out</code> типа ostream_iterator и организуйте цикл for с&nbsp;параметром-итератором <code>in</code> типа istream_iterator и операцией инкремента <code>in++</code>. В&nbsp;цикле выполняйте проверку введенного числа <code>*in</code> и в случае, если оно удовлетворяет требуемому условию, выполняйте оператор <code>out&nbsp;=&nbsp;*in</code>. Выражение <code>*in</code> можно использовать многократно; оно всегда будет соответствовать последнему прочитанному элементу данных (чтение очередного элемента выполняется при создании объекта istream_iterator и при выполнении операции инкремента).</p>
<p class="ptTask"><span class="ptSpecial">STL1Iter15°</span>. Дана строка <i>name</i> и набор целых чисел. Записать в текстовый файл с именем <i>name</i> все числа из исходного набора в том же порядке, заменяя каждое число 0 на число 10 и добавляя после каждого числа два пробела. Использовать итераторы ptin_iterator, ostream_iterator и алгоритм replace_copy. </p>
<h1>Последовательные контейнеры</h1>
<p class="ptAuthor">М.&nbsp;Э.&nbsp;Абрамян, 2016</p>
<p class="ptComment"></p>
<p class="ptComment">Во всех заданиях данной группы, кроме пяти начальных, заготовки решения уже содержат операторы, обеспечивающие заполнение исходных контейнеров и отладочную печать преобразованных контейнеров. Кроме того, заготовки содержат закомментированные операторы вывода полученных контейнеров в раздел результатов. Например, если в задании требуется преобразовать вектор целых чисел, то заготовка решения имеет следующий вид:</p>
<pre class="pt">typedef ptin_iterator&lt;int&gt; ptin;
typedef ptout_iterator&lt;int&gt; ptout;
vector&lt;int&gt; V(ptin(0), ptin());

Show(V.begin(), V.end(), &quot;V: &quot;);
//copy(V.begin(), V.end(), ptout());</pre>
<p class="ptComment">Решение следует ввести перед оператором отладочной печати Show, после чего раскомментировать вызов copy для вывода результатов и их автоматической проверки.</p>
<p class="ptComment">Во всех заданиях элементами контейнеров являются целые числа.</p>
<h2>Последовательные контейнеры: заполнение и&nbsp;доступ к&nbsp;элементам. Обратные итераторы</h2>
<p class="ptTask"><span class="ptSpecial">STL2Seq5°</span>. Дан набор целых чисел, количество которых делится на 3. Заполнить список <i>L</i> исходными числами и вывести вначале первую треть элементов списка <i>L</i> в исходном порядке, затем вторую треть элементов в обратном порядке, а затем последнюю треть (также в обратном порядке). Для заполнения списка использовать итератор ptin_iterator и конструктор списка, для вывода элементов трижды применить алгоритм copy к итераторам полученного списка и итератору ptout_iterator. Использовать как прямые, так и обратные итераторы; при определении некоторых из них использовать выражение <tt>L.size()/3</tt> и функцию advance. </p>
<h2>Последовательные контейнеры: вставка элементов</h2>
<p class="ptTask"><span class="ptSpecial">STL2Seq11°</span>. Даны вектор <i>V</i> и список <i>L</i>. Каждый исходный контейнер содержит не менее 5&nbsp;элементов. Вставить после элемента списка с порядковым номером&nbsp;5 первые 5&nbsp;элементов вектора в обратном порядке. Использовать один вызов функции-члена insert. </p>
<h2>Последовательные контейнеры: удаление элементов</h2>
<p class="ptTask"><span class="ptSpecial">STL2Seq20°</span>. Дан дек <i>D</i> с нечетным количеством элементов <i>N</i> (&#8805;&nbsp;3). Удалить средний элемент дека. Использовать функцию-член erase. </p>
<p class="ptTask"><span class="ptSpecial">STL2Seq25°</span>. Даны списки <i>L</i><sub>1</sub> и <i>L</i><sub>2</sub>; список <i>L</i><sub>2</sub> имеет четное количество элементов. Переместить первую половину элементов списка&nbsp;<i>L</i><sub>2</sub> в начало списка&nbsp;<i>L</i><sub>1</sub>. Использовать один вызов функции-члена splice. </p>
<h1>Обобщенные алгоритмы</h1>
<p class="ptAuthor">М.&nbsp;Э.&nbsp;Абрамян, 2016</p>
<p class="ptComment"></p>
<p class="ptComment">Во всех заданиях данной группы заготовки решения уже содержат операторы, обеспечивающие заполнение исходных контейнеров. Если в задании требуется преобразовать содержимое исходного контейнера, то заготовка содержит отладочную печать преобразованного контейнера. Кроме того, если в задании требуется вывести преобразованный контейнер, заготовка содержит закомментированный оператор вывода требуемого контейнера (для вывода используется алгоритм copy). Например, если в задании требуется преобразовать вектор целых чисел, то заготовка решения имеет следующий вид:</p>
<pre class="pt">typedef ptin_iterator&lt;int&gt; ptin;
typedef ptout_iterator&lt;int&gt; ptout;
vector&lt;int&gt; V(ptin(0), ptin());

Show(V.begin(), V.end(), &quot;V: &quot;);
//copy(V.begin(), V.end(), ptout());</pre>
<p class="ptComment">Решение следует ввести перед оператором отладочной печати Show, после чего раскомментировать вызов copy для вывода результатов и их автоматической проверки.</p>
<p class="ptComment">Если тип элементов контейнера в задании не указан, то предполагается, что элементами являются целые числа.</p>
<h2>Алгоритмы поиска</h2>
<p class="ptTask"><span class="ptSpecial">STL3Alg2°</span>. Дан дек <i>D</i>. Удалить последний нулевой элемент дека. Если нулевых элементов нет, то дек не изменять. Использовать алгоритм find с обратными итераторами и функцию-член erase. </p><p class="ptTaskContinue"><span class="ptSpecial">Указание.</span> Алгоритм find может возвращать обратный итератор, однако функция-член erase не позволяет его использовать для удаления элемента. Необходимо перейти от обратного итератора&nbsp;<code>r</code> к связанному с ним обычному итератору, используя функцию-член обратного итератора <code>r.base()</code>. При этом следует учитывать, что функция <code>r.base()</code> возвращает итератор, связанный с элементом, следующим за тем, с которым связан обратный итератор&nbsp;<code>r</code>. Поэтому в функции-члене erase следует указать одно из следующих выражений (предполагается, что&nbsp;<code>r</code>&nbsp;&#8212; это обратный итератор, который вернул алгоритм find, и этот итератор отличен от rend): <code>--r.base()</code> или <code>(++r).base()</code>.</p>
<p class="ptTask"><span class="ptSpecial">STL3Alg6°</span>. Даны вектор <i>V</i> и список <i>L</i>; вектор <i>V</i> имеет четное количество элементов. Продублировать последний элемент списка, совпадающий с каким-либо элементом из первой половины исходного вектора. Если список не содержит требуемых элементов, то не изменять его. Использовать алгоритм find_first_of и функцию-член insert для списка. </p>
<h2>Базовые модифицирующие алгоритмы. Итераторы вставки</h2>
<p class="ptTask"><span class="ptSpecial">STL3Alg17°</span>. Даны числа <i>A</i> и <i>B</i> и векторы <i>V</i><sub>1</sub> и <i>V</i><sub>2</sub>. Добавить в начало каждого вектора 5&nbsp;элементов со значениями <i>A</i>, а в конец&nbsp;&#8212; 5&nbsp;элементов со значениями <i>B</i>. При преобразовании вектора <i>V</i><sub>1</sub> использовать два вызова алгоритма fill_n с функциями inserter и back_inserter (данные функции возвращают итераторы вставки), при преобразовании вектора <i>V</i><sub>2</sub> использовать два вызова функции-члена insert. </p><p class="ptTaskContinue"><span class="ptSpecial">Замечание.</span> Второй способ является более эффективным. </p>
<p class="ptTask"><span class="ptSpecial">STL3Alg21°</span>. Дано число <i>K</i> (0&nbsp;&lt;&nbsp;<i>K</i>&nbsp;&lt;&nbsp;10) и списки <i>L</i><sub>1</sub> и <i>L</i><sub>2</sub>, каждый из которых содержит не менее 10&nbsp;элементов. Выполнить для списка <i>L</i><sub>1</sub> циклический сдвиг элементов вправо на <i>K</i> позиций, а для списка <i>L</i><sub>2</sub> &#8212; циклический сдвиг влево на <i>K</i> позиций. Использовать алгоритм rotate и функцию advance. </p>
<p class="ptTask"><span class="ptSpecial">STL3Alg28°</span>. Дан список <i>L</i> с четным количеством элементов. Скопировать в начало списка все положительные элементы, расположенные в его второй половине, сохранив для них исходный порядок следования. Использовать алгоритм remove_copy_if и итератор вставки, а также функцию advance. </p>
<p class="ptTask"><span class="ptSpecial">STL3Alg30°</span>. Дан вектор <i>V</i> с четным количеством элементов. Удалить все нулевые элементы, расположенные во второй половине исходного вектора. Использовать алгоритм remove и функцию-член erase. </p><p class="ptTaskContinue"><span class="ptSpecial">Указание.</span> Алгоритм remove и другие алгоритмы, связанные с удалением элементов, не удаляют требуемые элементы, а лишь перемещают их в конец указанного диапазона и возвращают итератор на начало диапазона с перемещенными элементами. Для&nbsp;фактического удаления элементов после выполнения алгоритма необходимо вызвать функцию-член erase.</p>
<h2>Сортировка и&nbsp;слияние</h2>
<p class="ptTask"><span class="ptSpecial">STL3Alg37°</span>. Дан вектор <i>V</i>, содержащий не менее 3 элементов. Определить значения трех начальных элементов вектора после того, как вектор будет отсортирован (по возрастанию), и вывести их в порядке возрастания. Использовать один вызов алгоритма partial_sort и алгоритм copy для вывода требуемых элементов. </p>
<p class="ptTask"><span class="ptSpecial">STL3Alg40°</span>. Дан список <i>L</i>. Определить количество четных и нечетных чисел в исходном списке (вначале вывести количество четных, затем количество нечетных чисел). Использовать алгоритм partition и два вызова функции distance для итераторов. </p>
<p class="ptTask"><span class="ptSpecial">STL3Alg46°</span>. Дан дек <i>D</i>, элементами которого являются английские слова. Отсортировать его элементы по убыванию их длин, а элементы одинаковой длины&nbsp;&#8212; в алфавитном порядке. Использовать единственный вызов алгоритма sort с параметром &#8212; функциональным объектом, включающим как сравнение строк, так и сравнение их длин. </p>
<h2>Численные алгоритмы</h2>
<p class="ptTask"><span class="ptSpecial">STL3Alg56°</span>. Дан вектор <i>V</i>. Найти сумму отрицательных и сумму положительных элементов вектора. Использовать два вызова алгоритма accumulate с параметрами &#8212; функциональными объектами. </p>
<h1>Строки как&nbsp;последовательные контейнеры</h1>
<p class="ptAuthor">М.&nbsp;Э.&nbsp;Абрамян, 2016</p>
<p class="ptComment"> Во всех заданиях данной группы требуется обработать строку, рассматривая ее как последовательный контейнер и используя конструкторы класса string, его функции-члены insert и erase и/или подходящие обобщенные алгоритмы. Вспомогательные строки при решении задач использовать не следует.</p>
<p class="ptComment">Во всех заданиях группы STL4Str требуется обработать строку, рассматривая ее как последовательный контейнер и&nbsp;используя конструкторы класса string, его функции-члены insert и&nbsp;erase и/или подходящие обобщенные алгоритмы. Вспомогательные строки при решении задач не&nbsp;использовать.</p>
<p class="ptTask"><span class="ptSpecial">STL4Str6°</span>. Дано целое число <i>K</i> (&gt;&nbsp;0) и строки <i>S</i><sub>1</sub> и <i>S</i><sub>2</sub>. Строка <i>S</i><sub>1</sub> содержит не менее <i>K</i> символов, а строка <i>S</i><sub>2</sub>&nbsp;&#8212; не менее двух символов. Используя два вызова функции-члена insert с параметрами-итераторами, преобразовать строку <i>S</i><sub>2</sub>, вставив после ее первого символа первые <i>K</i> символов строки <i>S</i><sub>1</sub> в исходном порядке, а перед ее последним символом&nbsp;&#8212; последние <i>K</i> символов строки <i>S</i><sub>1</sub> в обратном порядке. </p>
<p class="ptTask"><span class="ptSpecial">STL4Str12°</span>. Дана строка <i>S</i>, содержащая не менее трех символов. Используя подходящий обобщенный алгоритм в цикле, переместить каждый третий символ строки <i>S</i> в ее конец, располагая перемещенные символы в исходном порядке. </p>
<p class="ptTask"><span class="ptSpecial">STL4Str20°</span>. Дано число <i>N</i> (1&nbsp;&#8804;&nbsp;<i>N</i>&nbsp;&#8804;&nbsp;26) и строка <i>S</i>. Используя два вызова подходящего обобщенного алгоритма с итератором вставки, добавить в начало и в конец строки <i>S</i> по <i>N</i> первых заглавных букв латинского алфавита, расположив эти буквы в конце строки по алфавиту, а в начале&nbsp;&#8212; в порядке, обратном алфавитному. Например, при <i>N</i>&nbsp;=&nbsp;3 и <i>S</i>&nbsp;=&nbsp;&#34;567&#34; требуется получить строку &#34;CBA567ABC&#34;. </p>
<p class="ptTask"><span class="ptSpecial">STL4Str23°</span>. Дана строка <i>S</i>. Используя один вызов подходящего обобщенного алгоритма, изменить регистр всех буквенных символов строки <i>S</i> на противоположный, а цифровые символы заменить на символ&nbsp;&#34;*&#34;. </p>
<h1>Ассоциативные контейнеры</h1>
<p class="ptAuthor">М.&nbsp;Э.&nbsp;Абрамян, 2016</p>
<p class="ptComment"></p>
<p class="ptComment">Во всех заданиях данной группы заготовки решения уже содержат операторы, обеспечивающие заполнение исходных контейнеров. Если тип элементов контейнера в задании не указан, то предполагается, что элементами являются целые числа.</p>
<h2>Множества. Теоретико-множественные алгоритмы</h2>
<p class="ptTask"><span class="ptSpecial">STL5Assoc1°</span>. Дан вектор <i>V</i> с четным количеством элементов. Если все значения, содержащиеся во второй половине вектора, входят хотя бы один раз в его первую половину, то вывести true, иначе вывести false. Использовать алгоритм includes, применив его к двум <i>множествам</i> (контейнерам типа set), созданным на основе вектора <i>V</i>. </p>
<p class="ptTask"><span class="ptSpecial">STL5Assoc7°</span>. Даны векторы <i>V</i><sub>1</sub> и <i>V</i><sub>2</sub> с различным количеством элементов. Найти все числа (с учетом повторений), которые входят в один из исходных векторов и отсутствуют в другом, и вывести их в порядке убывания; при этом если, например, некоторое число входит в один из векторов 3 раза, а в другой 5 раз, то его надо вывести 2 раза. Использовать алгоритм set_symmetric_difference для двух вспомогательных мультимножеств и итератора ptout_iterator. Чтобы обеспечить вывод чисел в нужном порядке, при создании множеств и в алгоритме использовать функциональный объект greater. </p>
<h2>Отображения. Группировка и&nbsp;объединение данных</h2>
<p class="ptTask"><span class="ptSpecial">STL5Assoc15°</span>. Дан вектор <i>V</i>. Определить количество повторений каждого числа в векторе <i>V</i> и вывести все различные элементы вектора <i>V</i> вместе с количеством их повторений (в порядке возрастания значений элементов); количество повторений выводить сразу после значения соответствующего элемента. Использовать вспомогательное <i>отображение</i> <i>M</i> (класс map), ключами которого являются различные элементы вектора <i>V</i>, а значениями&nbsp;&#8212; количество повторений этих элементов. При заполнении отображения <i>M</i> не использовать условные конструкции (достаточно операций индексирования [] и инкремента). Элементы вектора <i>V</i> (при заполнении отображения <i>M</i>) и элементы отображения <i>M</i> (при выводе полученных результатов) перебирать в цикле с параметром-итератором соответствующего контейнера. </p>
<p class="ptTask"><span class="ptSpecial">STL5Assoc22°</span>. Дан вектор <i>V</i>, элементами которого являются английские слова, набранные заглавными буквами. Выполнить группировку элементов вектора <i>V</i>, используя в качестве ключа группировки последнюю букву элемента: в одну группу должны входить все элементы вектора <i>V</i>, оканчивающиеся одной и той же буквой (сгруппированные элементы должны располагаться в порядке, обратном порядку их расположения в исходном векторе). Представить результат группировки в виде мультиотображения <i>M</i>, ключами которого являются ключи группировки, т.&nbsp;е. последние буквы элементов вектора <i>V</i>, а значениями&nbsp;&#8212; элементы вектора, оканчивающиеся на соответствующую букву (таким образом, отображение <i>M</i> должно иметь тип multimap&lt;char,&nbsp;string&gt;). Вывести полученное отображение (для каждого элемента отображения <i>M</i> вначале выводить ключ, а затем связанный с ним элемент вектора <i>V</i>; ключи могут повторяться). Для перебора элементов контейнеров использовать алгоритм for_each или, если компилятор поддерживает стандарт C++11, цикл for по элементам контейнера. </p><p class="ptTaskContinue"><span class="ptSpecial">Указание.</span> Для размещения элементов в группе в порядке, обратном исходному порядку их расположения в векторе, достаточно при формировании мультиотображения <i>M</i> перебирать элементы вектора <i>V</i> в обратном порядке (используя обратные итераторы). Требуемый результат можно получить и при прямом переборе элементов вектора, если использовать вариант функции-члена <tt>M.insert</tt> с первым параметром-итератором (&#34;подсказкой&#34;), в качестве которого указывать возвращаемое значение функции-члена <tt>M.lower_bound</tt> для соответствующего ключа. </p>
<p class="ptTask"><span class="ptSpecial">STL5Assoc32°</span>. Даны векторы <i>V</i><sub>1</sub> и <i>V</i><sub>2</sub>, элементами которых являются английские слова, набранные заглавными буквами, причем все слова в каждом векторе различны. Получить вектор <i>V</i>, являющийся внутренним объединением векторов <i>V</i><sub>1</sub> и <i>V</i><sub>2</sub> (см. STL5Assoc29), в каждой паре которого первое слово начинается с буквы, которой оканчивается второе слово. Порядок следования пар определяется алфавитным порядком первых элементов пар, а для равных первых элементов&nbsp;&#8212; порядком вторых элементов, обратным порядку их следования в векторе <i>V</i><sub>2</sub>. Для построения вектора <i>V</i> выполнить группировку элементов вектора <i>V</i><sub>2</sub> по ключу&nbsp;&#8212; последней букве слова, используя вариант группировки со вспомогательным мультиотображением <i>M</i>, описанный в задаче STL5Assoc22, после чего в цикле по отсортированным элементам вектора <i>V</i><sub>1</sub> сформировать требуемое внутреннее объединение, перебирая для каждого элемента вектора <i>V</i><sub>1</sub> соответствующие ему элементы отображения <i>M</i>. Вывести размер полученного вектора <i>V</i> и все его элементы. </p>
<h1>Применение различных средств стандартной библиотеки C++</h1>
<p class="ptAuthor">М.&nbsp;Э.&nbsp;Абрамян, 2016</p>
<p class="ptComment"> </p><p class="ptComment">В каждом задании даются имена одного или нескольких текстовых файлов, содержащих исходные последовательности, а также имя текстового файла, в который требуется записать результаты обработки исходных последовательностей (имя результирующего файла указывается последним). Каждая исходная последовательность содержится в отдельном файле. Все исходные файлы содержат текст в кодировке &#34;windows-1251&#34;; эта же кодировка должна использоваться при записи полученных данных в результирующий файл. </p><p class="ptComment">Каждый элемент последовательности размещается в отдельной строке файла, в начале и конце строки пробелы отсутствуют, поля элемента не содержат пробелов и разделяются ровно одним пробелом. Все исходные числовые данные являются положительными. В качестве десятичного разделителя используется <i>точка</i>. </p><p class="ptComment">Если в задание входят дополнительные числовые или строковые исходные данные, то они указываются в начале набора исходных данных (перед именами файлов).</p>
<p class="ptComment">Во всех заданиях данной группы заготовки решения уже содержат определения исходных структур данных (в заданиях STL7Mix1&#8211;STL7Mix70 структура имеет имя <code>Data</code>, в заданиях STL7Mix71&#8211;STL7Mix100 имя дополнительно содержит буквенный идентификатор соответствующего набора данных, например, <code>DataA</code> или <code>DataC</code>). Кроме того, заготовки содержат операторы, обеспечивающие чтение данных из исходных файлов в векторы типа <code>vector&lt;Data&gt;</code>, где <code>Data</code> &#8212; ранее определенная структура данных, и операторы, создающие результирующий файл.</p>
<p class="ptComment">Например, в задании STL7Mix1 заготовка задания включает определение структуры Data с целочисленными полями code, year, month, len, а функция Solve содержит следующие операторы:</p>
<pre class="pt">    string name1, name2;
    pt &gt;&gt; name1 &gt;&gt; name2;
    ifstream f1(name1);
    vector&lt;Data&gt; V((istream_iterator&lt;Data&gt;(f1)), istream_iterator&lt;Data&gt;());
    f1.close();
    ShowLine(V.begin(), V.end(), &quot;V: &quot;);

    ofstream f2(name2);

    f2.close();</pre>
<p class="ptComment">Оператор отладочной печати отображает в разделе отладки все введенные исходные данные. Выводить полученные данные следует в файловый поток f2.</p>
<p class="ptComment">Если компилятор поддерживает стандарт C++11, то для вывода результатов рекомендуется использовать цикл <code>for(auto&amp; e : C)</code>, где <code>C</code> &#8212; контейнер с результирующими данными; в противном случае можно использовать алгоритм for_each для этого контейнера.</p>
<p class="ptComment">При решении большинства задач требуется выполнить <i>группировку</i> исходных данных, используя вспомогательное отображение подходящего типа. В задачах STL7Mix71&#8211;STL7Mix100 может оказаться удобным предварительно выполнить внутреннее или внешнее <i>объединение</i> данных по общему ключу. Группировка и объединение данных с использованием ассоциативных контейнеров рассматриваются в группе заданий STL5Assoc.</p>
<p class="ptComment">Если порядок вывода сгруппированных данных отличается от порядка следования их ключей, то следует скопировать полученные данные в последовательный контейнер (обычно вектор) и выполнить для него требуемую сортировку (используя алгоритмы sort или stable_sort).</p>
<h2>ОБРАБОТКА ОТДЕЛЬНЫХ ПОСЛЕДОВАТЕЛЬНОСТЕЙ</h2>
<p class="ptTask"><span class="ptSpecial">STL7Mix8°</span>. Дано целое число <i>K</i> &#8212; код одного из клиентов фитнес-центра. Исходная  последовательность содержит сведения о клиентах этого фитнес-центра. Каждый элемент последовательности включает следующие целочисленные поля: </p><p class="ptTaskQuote"><tt>&lt;Продолжительность занятий (в часах)&gt; &lt;Код клиента&gt; &lt;Год&gt; &lt;Номер месяца&gt;</tt></p><p class="ptTaskContinue">Для каждого года, в котором клиент с кодом&nbsp;<i>K</i> посещал центр, определить месяц, в котором продолжительность занятий данного клиента была наименьшей для данного года (если таких месяцев несколько, то выбирать первый из этих месяцев в исходном наборе; месяцы с нулевой продолжительностью занятий не учитывать). Сведения о каждом годе выводить на новой строке в следующем порядке: наименьшая продолжительность занятий, год, номер месяца. Упорядочивать сведения по возрастанию продолжительности занятий, а при равной продолжительности &#8212; по возрастанию номера года. Если данные о клиенте с кодом&nbsp;<i>K</i> отсутствуют, то записать в результирующий файл строку &#34;Нет данных&#34;. </p><p class="ptTaskContinue"><span class="ptSpecial">Указание</span>. Ср. с STL7Mix7. В данном случае после построения отображения <i>M</i> следует скопировать его во вспомогательный вектор и отсортировать этот вектор в требуемом порядке. Если в отображении <i>M</i> использовать порядок по умолчанию (т.&nbsp;е. по возрастанию ключа &#171;год&#187;), то для сортировки вспомогательного вектора достаточно использовать алгоритм устойчивой сортировки по возрастанию поля &#171;длительность&#187;.</p>
<p class="ptTask"><span class="ptSpecial">STL7Mix22°</span>. Исходная последовательность содержит сведения об абитуриентах. Каждый элемент последовательности включает следующие поля: </p><p class="ptTaskQuote"><tt>&lt;Фамилия&gt; &lt;Номер школы&gt; &lt;Год поступления&gt;</tt></p><p class="ptTaskContinue">Для каждой школы найти годы поступления абитуриентов из этой школы и вывести номер школы и найденные для нее годы (годы располагаются на той же строке, что и номер школы, и упорядочиваются по возрастанию). Сведения о каждой школе выводить на новой строке и упорядочивать по возрастанию номеров школ. </p><p class="ptTaskContinue"><span class="ptSpecial">Указание</span>. Здесь, как и в задании STL7Mix17, удобно использовать вспомогательное отображение <code>map&lt;int, set&lt;int&gt;&gt;</code>, позволяющее сразу получить результирующие данные в требумом порядке.</p>
<h1>Порождающие паттерны</h1>
<p class="ptAuthor">М.&nbsp;Э.&nbsp;Абрамян, 2021</p>
<h2>Singleton, Prototype, Builder</h2>
<p class="ptTask"><span class="ptSpecial">OOP1Creat6°</span>. </p><p class="ptPicture"><img src="file:///D:\Program\PT4\LIB\Graph\OOPSingleton.png" alt="D:\Program\PT4\LIB\Graph\OOPSingleton.png" border=1></p><p class="ptTaskContinue"><b>Singleton</b> (<b>Одиночка</b>)&nbsp;&#8212; порождающий паттерн. </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: выше средней. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Singleton</i> (<i>Одиночка</i>)&nbsp;&#8212; определяет операцию Instance, которая позволяет клиентам получать доступ к единственному экземпляру (операция Instance обычно оформляется в виде <i>статического</i>, т.&nbsp;е. классового, метода); может обеспечивать <i>отложенную инициализацию</i> данного экземпляра. </p><p class="ptTaskContinue">Чтобы проиллюстрировать особенности паттерна Singleton, в задании предлагается реализовать не только его стандартный вариант, но и основанные на той же идее варианты, допускающие использование <i>ограниченного количества</i> экземпляров. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать иерархию классов, включающую абстрактный базовый класс BaseClass и классы-потомки Singleton, Doubleton и Tenton, обеспечивающие создание ограниченного количества своих экземпляров. </p><p class="ptTaskContinue">Класс BaseClass включает целочисленное поле data и два связанных с ним метода: метод IncData(increment) увеличивает значение data на величину целочисленного параметра increment, метод GetData без параметров возвращает текущее значение поля data. Поле data инициализируется нулевым значением. </p><p class="ptTaskContinue">Класс Singleton реализует стандартный паттерн &#34;Одиночка&#34;. Он включает статическое поле uniqueInstance&nbsp;&#8212; ссылку на тип Singleton (инициализируется нулевой ссылкой), закрытый конструктор без параметров, не выполняющий дополнительных действий, и статический метод Instance (без параметров, возвращает ссылку на тип Singleton). Метод Instance выполняет следующие действия: если поле uniqueInstance является нулевой ссылкой, то метод создает объект Singleton, помещает ссылку на него в поле uniqueInstance и возвращает эту ссылку как результат своей работы; если поле uniqueInstance уже содержит ссылку на объект Singleton, то метод Instance просто возвращает эту ссылку. Дополнительно реализовать статический метод InstanceCount (без параметров), который возвращает&nbsp;0, если поле uniqueInstance содержит нулевую ссылку, и&nbsp;1 в противном случае. </p><p class="ptTaskContinue">Классы Doubleton и Tenton реализуют вариант паттерна, допускающий использование <i>не более двух</i> и <i>не более десяти</i> экземпляров соответственно. </p><p class="ptTaskContinue">Класс Doubleton включает статический массив instances из двух элементов-ссылок типа Doubleton (элементы инициализируются нулевыми значениями), закрытый конструктор и статические методы Instance1 и Instance2, которые выполняют действия, аналогичные действиям метода Instance класса Singleton, но обращаются соответственно к элементам массива instances с индексами&nbsp;0 и&nbsp;1. </p><p class="ptTaskContinue">Класс Tenton отличается от класса Doubleton тем, что его статический массив instances содержит 10&nbsp;элементов-ссылок типа Tenton, а вместо двух методов Instance1 и Instance2 он включает статический метод Instance(index) с целочисленным параметром, определяющим индекс элемента массива instances, к которому обращается данный метод. Если параметр находится вне диапазона 0&#8211;9, то метод Instance может возвращать нулевую ссылку или возбуждать исключение (при выполнении задания такая ситуация не будет возникать). </p><p class="ptTaskContinue">В классах Doubleton и Tenton дополнительно реализовать статический метод InstanceCount (без параметров), который возвращает количество элементов массива instances, не являющихся нулевыми ссылками. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;10) и набор из N строк, которые могут принимать значения &#34;S&#34;, &#34;D1&#34;, &#34;D2&#34;, &#34;T0&#34;, &#34;T1&#34;, &#8230;, &#34;T9&#34;. Создать массив&nbsp;b из N&nbsp;элементов&nbsp;&#8212; ссылок на BaseClass и инициализировать его элементы экземплярами классов Singleton, Doubleton, Tenton, используя следующие варианты статических методов в зависимости от значения соответствующей строки из исходного набора: для строки &#34;S&#34; используется метод Instance класса Singleton; для строк &#34;D1&#34;, &#34;D2&#34;&nbsp;&#8212; соответственно методы Instance1 и Instance2 класса Doubleton; для строк &#34;T0&#34;, &#34;T1&#34;,&nbsp;&#8230;, &#34;T9&#34;&nbsp;&#8212; метод Instance(index) класса Tenton с параметром index, соответствующим цифре, указанной в строке. </p><p class="ptTaskContinue">После создания всех элементов массива b вывести значения метода InstanceCount для классов Singleton, Doubleton, Tenton в указанном порядке. </p><p class="ptTaskContinue">Также дано целое число K (&#8804;&nbsp;20) и набор из K пар целых чисел (index, increment), в котором первое число находится в диапазоне от&nbsp;0 до N&nbsp;&#8722;&nbsp;1 и определяет индекс элемента в массиве&nbsp;b, а второе число определяет параметр метода IncData(increment), который надо вызвать для элемента b[index]. После вызова всех требуемых методов IncData вывести итоговые значения поля data для всех объектов массива&nbsp;b, используя метод GetData. </p><pre class="pt">/*
При реализации класса Singleton (и аналогичных ему) в языке С++
необходимо объявить закрытым не только конструктор,
но и ДЕСТРУКТОР класса. Это, в частности, не позволит
внешней программе применить оператор delete к возвращенному
результату функции Instance (и тем самым разрушить статический
объект uniqueInstance). Кроме того, наличие закрытого
деструктора делает невозможным КОПИРОВАНИЕ объекта (и тем самым
создание еще одного его экземпляра).
*/

class BaseClass
{
    int data = 0;
public:
    void IncData(int increment);
    int GetData();
};

void BaseClass::IncData(int increment)
{
    data += increment;
}
int BaseClass::GetData()
{
    return data;
}

class Singleton : public BaseClass
{
    static Singleton* uniqueInstance;
    Singleton() {}
    ~Singleton() {}
public:
    // ЗАВЕРШИТЕ РЕАЛИЗАЦИЮ КЛАССА Singleton
};

Singleton* Singleton::uniqueInstance = nullptr;

class Doubleton : public BaseClass
{
    static Doubleton* instances[];
    Doubleton() {}
    ~Doubleton() {}
public:
    // ЗАВЕРШИТЕ РЕАЛИЗАЦИЮ КЛАССА Doubleton
};

Doubleton* Doubleton::instances[2];

class Tenton : public BaseClass
{
    static Tenton* instances[];
    Tenton() {}
    ~Tenton() {}
public:
    // ЗАВЕРШИТЕ РЕАЛИЗАЦИЮ КЛАССА Tenton
};

Tenton* Tenton::instances[10];</pre>
<h2>Factory Method, Abstract Factory</h2>
<p class="ptTask"><span class="ptSpecial">OOP1Creat4°</span>. </p><p class="ptPicture"><img src="file:///D:\Program\PT4\LIB\Graph\OOPAbstractFactory.png" alt="D:\Program\PT4\LIB\Graph\OOPAbstractFactory.png" border=1></p><p class="ptTaskContinue"><b>Abstract Factory</b> (<b>Абстрактная фабрика</b>)&nbsp;&#8212; порождающий паттерн. </p><p class="ptTaskContinue">Известен также под именем <b>Kit</b> (<b>Инструментарий</b>). </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: высокая. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя конкретные классы этих объектов. Методы абстрактной фабрики обычно реализуются как <i>фабричные методы</i> (см.&nbsp;OOP1Creat1). </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>AbstractFactory</i> (<i>Абстрактная фабрика</i>)&nbsp;&#8212; объявляет интерфейс для операций, создающих абстрактные объекты-продукты; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteFactory</i> (<i>Конкретная фабрика</i>)&nbsp;&#8212; реализует операции, создающие конкретные объекты-продукты; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>AbstractProduct</i> (<i>Абстрактный продукт</i>)&nbsp;&#8212; объявляет интерфейс для типа объекта-продукта; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteProduct</i> (<i>Конкретный продукт</i>)&nbsp;&#8212; определяет объект-продукт, создаваемый соответствующей конкретной фабрикой; реализует интерфейс AbstractProduct; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Client</i> (<i>Клиент</i>) &nbsp;&#8212; пользуется исключительно интерфейсами, которые объявлены в классах AbstractFactory и AbstractProduct. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать три иерархии классов, в одну из которых входят абстрактная фабрика AbstractFactory и две конкретные фабрики ConcreteFactory1 и ConcreteFactory2, в другую&nbsp;&#8212; абстрактный продукт (типа A) AbstractProductA и два его потомка ProductA1 и ProductA2, а в третью&nbsp;&#8212; абстрактный продукт (типа B) AbstractProductB и два его потомка ProductB1 и ProductB2. Все фабрики включают методы CreateProductA и CreateProductB, конкретные фабрики&nbsp;1 и&nbsp;2 возвращают конкретные продукты с соответствующим номером (фабрика&nbsp;1 возвращает продукты ProductA1 и ProductB1, фабрика&nbsp;2&nbsp;&#8212; продукты ProductA2 и ProductB2). </p><p class="ptTaskContinue">Все классы-продукты имеют метод GetInfo, возвращающий строковое значение. Кроме того, в продукте первого типа определен метод&nbsp;A без параметров, а в продукте второго типа&nbsp;&#8212; метод&nbsp;В с параметром типа AbstractProductA (методы не возвращают значений). Конкретные продукты содержат строковое поле info, которое инициализируется в конструкторе с помощью его параметра <i>целого типа</i> (в поле info записывается строковое представление целочисленного параметра конструктора). Метод GetInfo конкретных классов-продуктов возвращает текущее значение поля info. </p><p class="ptTaskContinue">Для класса-продукта ProductA1 метод&nbsp;A переводит поле info в целое число, удваивает его и сохраняет строковое представления результата в поле info; для класса-продукта ProductA2 метод&nbsp;A просто удваивает строку info. Для класса-продукта ProductB1 вызов objB.B(objA) преобразует поля objB.info и objA.info в целые числа, складывает их и сохраняет строковое представление результата в поле objB.info; для класса-продукта ProductB2 вызов objB.B(objA) находит сумму строк objB.info + objA.info и сохраняет результат в поле objB.info. </p><p class="ptTaskContinue">Дано целое число Nf, которое может быть равно&nbsp;1 или&nbsp;2, целые числа&nbsp;Na и&nbsp;Nb и строка&nbsp;S, содержащая только символы&nbsp;A и&nbsp;B. Описать ссылочные переменные&nbsp;f типа AbstractFactory, pa типа AbstractProductA и pb типа AbstractProductB. Если число Nf равно 1, то связать f с конкретной фабрикой&nbsp;1, если Nf равно&nbsp;2, то связать f с конкретной фабрикой&nbsp;2. Используя фабричные методы созданной фабрики, создать конкретные продукты типа&nbsp;A и&nbsp;B, инициализировав их данными числами Na и Nb соответственно, и связать их с переменными pa и pb. Затем для созданных продуктов pa и pb выполнить методы&nbsp;A и&nbsp;B в порядке, указанном в исходной строке S. При этом метод&nbsp;A должен вызываться для продукта pa, а метод&nbsp;B&nbsp;&#8212; для продукта pb, причем параметром метода&nbsp;B должен быть продукт pa. Используя методы GetInfo, вывести итоговые значения объектов-продуктов pa и pb (в указанном порядке). </p><p class="ptTaskContinue"><span class="ptSpecial">Примечание</span>. При выполнении задания используются только ссылки на абстрактные классы, а также только методы, определенные в абстрактных классах (за исключением конструктора создаваемой конкретной фабрики), что и составляет суть паттерна &#34;Абстрактная фабрика&#34;. </p><pre class="pt">class AbstractProductA
{
public:
    virtual void A() = 0;
    virtual string GetInfo() = 0;
};

// РЕАЛИЗУЙТЕ КЛАССЫ-ПОТОМКИ ProductA1 И ProductA2

class AbstractProductB
{
public:
    virtual void B(const AbstractProductA&amp; objA) = 0;
    virtual string GetInfo() = 0;
};

// РЕАЛИЗУЙТЕ КЛАССЫ-ПОТОМКИ ProductB1 И ProductB2

class AbstractFactory
{
public:
    virtual AbstractProductA* CreateProductA(int info) = 0;
    virtual AbstractProductB* CreateProductB(int info) = 0;
};

// РЕАЛИЗУЙТЕ КЛАССЫ-ПОТОМКИ ConcreteFactory1 И ConcreteFactory2</pre>
<h2>Singleton, Prototype, Builder</h2>
<p class="ptTask"><span class="ptSpecial">OOP1Creat7°</span>. </p><p class="ptPicture"><img src="file:///D:\Program\PT4\LIB\Graph\OOPPrototype.png" alt="D:\Program\PT4\LIB\Graph\OOPPrototype.png" border=1></p><p class="ptTaskContinue"><b>Prototype</b> (<b>Прототип</b>)&nbsp;&#8212; порождающий паттерн. </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: средняя. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: задает виды создаваемых объектов с помощью экземпляра-прототипа и создает новые объекты путем копирования (&#34;клонирования&#34;) этого прототипа. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Prototype</i> (<i>Прототип</i>)&nbsp;&#8212; объявляет интерфейс для клонирования самого себя; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcretePrototype</i> (<i>Конкретный прототип</i>)&nbsp;&#8212; реализует операцию клонирования себя; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Client</i> (<i>Клиент</i>)&nbsp;&#8212; создает новый объект, обращаясь к прототипу с запросом клонировать себя. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать иерархию классов, которая содержит абстрактный прототип Prototype и два конкретных прототипа ConcretePrototype1 и ConcretePrototype2. Все классы включают метод Clone без параметров, возвращающий копию объекта, вызвавшего данный метод, а также методы GetInfo и ChangeId. Метод GetInfo без параметров возвращает строку, метод ChangeId имеет целочисленный параметр id и не возвращает значений. В классе Prototype методы Clone, GetInfo и ChangeId являются абстрактными. Конкретные прототипы содержат строковое поле data и целочисленное поле id, которые инициализируются соответствующими параметрами конструктора. Метод GetInfo для конкретных прототипов возвращает строку, содержащую краткое имя типа (CP1 для типа ConcretePrototype1 и CP2 для типа ConcretePrototype2) и значения полей data и id (части описания разделяются символом &#34;=&#34;, например, &#34;CP1=TEXT=34&#34;). Метод ChangeId изменяет значение поля id. При реализации метода Clone можно использовать специальные средства стандартной библиотеки или обычный вызов конструктора. </p><p class="ptTaskContinue">Также реализовать класс Client, предназначенный для работы с группой объектов типа ConcretePrototype1 или ConcretePrototype2. Конструктор класса Client имеет параметр-ссылку типа Prototype, определяющий прототип объектов, включаемых в группу (прототип в группу не входит и сохраняется в специальном поле prot; для хранения группы объектов удобно использовать динамическую структуру). Класс Client также содержит методы AddObject(id) и GetObjects. Метод AddObject добавляет в набор новый объект, получаемый путем клонирования прототипа и последующего изменения поля id полученного объекта в соответствии со значением параметра метода AddObject. Метод GetObjects без параметров возвращает строку с описанием всех объектов группы (описания разделяются пробелом). Все объекты создаваемой группы имеют одно и то же поле data и различные поля id (задаваемые в методе AddObject). </p><p class="ptTaskContinue">Дана строка S, целое число N (&#8804;&nbsp;10) и набор из N целых чисел. С помощью двух объектов класса Client сформировать два набора из N объектов типа ConcretePrototype1 (для первого объекта Client) и ConcretePrototype2 (для второго объекта Client). Все созданные объекты должны иметь одинаковые поля data, равные строке S, и значения полей id, взятые из исходного набора целых чисел. Используя метод GetObjects, вывести строковые описания каждого из полученных наборов объектов. </p><p class="ptTaskContinue"><span class="ptSpecial">Примечание</span>. В реальной ситуации подход, основанный на паттерне &#34;Прототип&#34; будет эффективным, если объем действий по обычному созданию объекта превосходит объем действий по его клонированию и последующей настройке некоторых свойств. </p><pre class="pt">class Prototype
{
public:
    virtual Prototype* Clone() = 0;
    virtual void ChangeId(int id) = 0;
    virtual string GetInfo() = 0;
};

// РЕАЛИЗУЙТЕ КЛАССЫ-ПОТОМКИ ConcretePrototype1 И ConcretePrototype2

class Client
{
    // ДОБАВЬТЕ НЕОБХОДИМЫЕ ПОЛЯ
public:
    Client(Prototype* p);
    ~Client();
    void AddObject(int id);
    string GetObjects();
};

Client::Client(Prototype* p)
{
    // РЕАЛИЗУЙТЕ КОНСТРУКТОР
}
Client::~Client()
{
    // РЕАЛИЗУЙТЕ ДЕСТРУКТОР
}
void Client::AddObject(int id)
{
    // РЕАЛИЗУЙТЕ МЕТОД
}
string Client::GetObjects()
{
    return &quot;&quot;;
    // УДАЛИТЕ ПРЕДЫДУЩИЙ ОПЕРАТОР И РЕАЛИЗУЙТЕ МЕТОД
}</pre>
<p class="ptTask"><span class="ptSpecial">OOP1Creat9°</span>. </p><p class="ptPicture"><img src="file:///D:\Program\PT4\LIB\Graph\OOPBuilder.png" alt="D:\Program\PT4\LIB\Graph\OOPBuilder.png" border=1></p><p class="ptTaskContinue"><b>Builder</b> (<b>Строитель</b>)&nbsp;&#8212; порождающий паттерн. </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: ниже средней. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Builder</i> (<i>Строитель</i>)&nbsp;&#8212; задает абстрактный интерфейс для создания частей объекта Product; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteBuilder</i> (<i>Конкретный</i> <i>строитель</i>)&nbsp;&#8212; конструирует и собирает вместе части продукта посредством реализации интерфейса Builder, предоставляет интерфейс для доступа к продукту; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Director</i> (<i>Распорядитель</i>)&nbsp;&#8212; конструирует объект Product, пользуясь интерфейсом Builder; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Product</i> (<i>Продукт</i>)&nbsp;&#8212; представляет сложный конструируемый объект. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать иерархию классов-строителей, конструирующих продукты-строки. Иерархия включает абстрактный класс Builder, который предоставляет интерфейс для инициализации продукта (BuildStart) и создания трех его фрагментов (BuildPartA, BuildPartB, BuildPartC), и конкретные классы ConcreteBuilder1 и ConcreteBuilder2, которые определяют конкретные способы конструирования. Методы BuildStart, BuildPartA, BuildPartB, BuildPartC не имеют параметров и не возвращают значений. В абстрактном классе Builder подобные методы обычно не выполняют никаких действий, хотя и не являются абстрактными; это позволяет конкретному классу-строителю не переопределять некоторые из них, если его устраивает поведение по умолчанию. Кроме того, в классе Builder определен абстрактный метод GetResult без параметров, возвращающий строку-продукт. </p><p class="ptTaskContinue">Конкретные классы ConcreteBuilder1 и ConcreteBuilder2 содержат строковое поле product; их метод GetResult возвращает текущее значение поля product. В конструкторе этих классов поле product инициализируется пустой строкой, это же действие выполняет и метод BuildStart. Каждый из методов BuildPartA, BuildPartB, BuildPartC добавляет к строке product новый текстовый фрагмент; для класса ConcreteBuilder1 фрагменты A, B, C представляют собой строки &#34;-1-&#34;, &#34;-2-&#34; и &#34;-3-&#34;, а для класса ConcreteBuilder2&nbsp;&#8212; строки &#34;=*=&#34;, &#34;=**=&#34; и &#34;=***=&#34;. </p><p class="ptTaskContinue">Также определить класс Director, содержащий поле b&nbsp;&#8212; ссылку на объект типа Builder (поле b инициализируется в конструкторе с использованием параметра конструктора того же типа) и два метода: Construct(templat) и GetResult. Метод GetResult не имеет параметров и возвращает значение метода GetResult объекта&nbsp;b, т.&nbsp;е. построенный продукт. Метод Construct обеспечивает построение продукта; его строковый параметр templat определяет план строительства. В данном случае план определяется последовательностью символов &#34;A&#34;, &#34;B&#34;, &#34;C&#34;, каждый из которых соответствует фрагменту A, B, C, добавляемому к конструируемой строке в указанном порядке. Строка templat может содержать символы, отличные от &#34;A&#34;, &#34;B&#34;, &#34;C&#34;; подобные символы игнорируются. В начале своей работы метод Construct должен вызвать метод BuildStart. </p><p class="ptTaskContinue">Даны пять строк, каждая из которых содержит план строительства. Создать два экземпляра d1 и d2 класса Director, передав первому экземпляру объект типа ConcreteBuilder1, а второму&nbsp;&#8212; объект типа ConcreteBuilder2. Вызвать метод Construct объектов d1 и d2 для каждой из исходных строк и вывести полученные результаты, используя метод GetResult (вначале выводятся результаты для первой исходной строки, затем для второй и т.&nbsp;д.). </p><pre class="pt">class Builder
{
public:
    virtual void BuildStart() {}
    virtual void BuildPartA() {}
    virtual void BuildPartB() {}
    virtual void BuildPartC() {}
    virtual string GetResult() = 0;
};

// РЕАЛИЗУЙТЕ КЛАССЫ-ПОТОМКИ ConcreteBuilder1 И ConcreteBuilder2

class Director
{
    Builder* b;
public:
    Director(Builder* b);
    string GetResult();
    void Construct(string templat);
};

Director::Director(Builder* b)
{
    this-&gt;b = b;
}
string Director::GetResult()
{
    return b-&gt;GetResult();
}
void Director::Construct(string templat)
{
    // РЕАЛИЗУЙТЕ МЕТОД
}</pre>
<h1>Структурные паттерны</h1>
<p class="ptAuthor">М.&nbsp;Э.&nbsp;Абрамян, 2021</p>
<h2>Adapter, Composite, Decorator</h2>
<p class="ptTask"><span class="ptSpecial">OOP2Struc3°</span>. <b>Adapter</b> (<b>Адаптер</b>)&nbsp;&#8212; структурный паттерн. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 3</span>. Дан абстрактный класс Shape, предоставляющий интерфейс для графических объектов: метод GetInfo без параметров, возвращающий строку с именем объекта и координатами левой верхней и правой нижней вершины ограничивающего прямоугольника (считается, что ось <i>OY</i> направлена вниз), и метод MoveBy(a, b) с двумя целочисленными параметрами, определяющими вектор, на который надо сместить данный графический объект (метод не возвращает значений). В классе Shape методы GetInfo и MoveBy являются абстрактными. </p><p class="ptTaskContinue">Также дан конкретный класс RectShape&nbsp;&#8212; потомок класса Shape, реализующий прямоугольник и имеющий конструктор с параметрами (x1, y1, x2, y2), задающими координаты левой верхней и правой нижней вершины этого прямоугольника. Метод GetInfo для данного класса возвращает строку вида &#34;R(x1,y1)(x2,y2)&#34; с текущими значениями координат. </p><p class="ptTaskContinue">Дан класс TextView для работы с текстовыми объектами. Он содержит поля x, y (координаты точки привязки&nbsp;&#8212; левого верхнего угла текстовой области), width, height (ширина и высота текстовой области) и методы GetOrigin (возвращает координаты точки привязки), SetOrigin (изменяет точку привязки), GetSize (возвращает размеры текстовой области) и SetSize (изменяет размеры текстовой области). Методы GetOrigin и GetSize возвращают результаты либо с помощью выходных параметров, либо с помощью структурного возвращаемого значения&nbsp;&#8212; массива или кортежа. Конструктор класса не имеет параметров (поля x и y полагаются равными&nbsp;0, поля width и height&nbsp;&#8212; равными&nbsp;1). </p><p class="ptTaskContinue">Реализовать класс TextShape, адаптирующий класс TextView к интерфейсу класса Shape. Класс должен быть адаптером объекта: он порождается от класса Shape и включает поле tview, являющееся ссылкой на экземпляр адаптируемого объекта TextView (других полей класс TextShape не содержит). Метод GetInfo класса TextShape должен возвращать строку вида &#34;T(x1,y1)(x2,y2)&#34; с текущими значениями левой верхней и правой нижней вершины ограничивающего прямоугольника. Включить в класс TextShape конструктор с параметрами (tview, x1, y1, x2, y2); смысл четырех последних параметров аналогичен смыслу параметров конструктора класса RectShape. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;8) и набор из N пятерок (C, X1, Y1, X2, Y2), где C является символом &#34;R&#34; или &#34;T&#34;, а остальные элементы являются целыми числами. Кроме того, даны целые числа A и B. Создать структуру данных (например, массив) с элементами типа Shape и заполнить ее объектами типа RectShape (для пятерок с символом &#34;R&#34;) и TextShape (для пятерок с символом &#34;T&#34;), используя значения X1, Y1, X2, Y2 в качестве параметров соответствующего конструктора. Применить к каждому элементу созданного набора метод MoveBy с параметрами A и B и вывести строковые представления элементов набора с помощью метода GetInfo (перебирая элементы в исходном порядке). </p><pre class="pt">class TextView
{
    // НЕ ИЗМЕНЯЙТЕ РЕАЛИЗАЦИЮ ДАННОГО КЛАССА
    int x = 0, y = 0;
    int width = 1, height = 1;
public:
    void GetOrigin(int&amp; x, int&amp; y);
    void SetOrigin(int x, int y);
    void GetSize(int&amp; width, int&amp; height);
    void SetSize(int width, int height);
};

void TextView::GetOrigin(int&amp; x, int&amp; y)
{
    x = this-&gt;x;
    y = this-&gt;y;
}
void TextView::SetOrigin(int x, int y)
{
    this-&gt;x = x;
    this-&gt;y = y;
}
void TextView::GetSize(int&amp; width, int&amp; height)
{
    width = this-&gt;width;
    height = this-&gt;height;
}
void TextView::SetSize(int width, int height)
{
    this-&gt;width = width;
    this-&gt;height = height;
}

class Shape
{
public:
    virtual string GetInfo() = 0;
    virtual void MoveBy(int a, int b) = 0;
};

// РЕАЛИЗУЙТЕ КЛАССЫ-ПОТОМКИ RectShape И TextShape</pre>
<p class="ptTask"><span class="ptSpecial">OOP2Struc7°</span>. </p><p class="ptPicture"><img src="file:///D:\Program\PT4\LIB\Graph\OOPDecorator.png" alt="D:\Program\PT4\LIB\Graph\OOPDecorator.png" border=1></p><p class="ptTaskContinue"><b>Decorator</b> (<b>Декоратор</b>)&nbsp;&#8212; структурный паттерн. </p><p class="ptTaskContinue">Известен также под именем <b>Wrapper</b> (<b>Обертка</b>). </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: средняя. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: динамически добавляет объекту новые возможности, приводящие к изменению его состояния и/или поведения. Является гибкой альтернативой порождению подклассов с целью расширения функциональности. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Component</i> (<i>Компонент</i>)&nbsp;&#8212; определяет интерфейс для объектов, к которым могут быть динамически добавлены новые возможности; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteComponent</i> (<i>Конкретный компонент</i>)&nbsp;&#8212; определяет объект, к которому могут быть добавлены новые возможности; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Decorator</i> (<i>Декоратор</i>)&nbsp;&#8212; хранит ссылку на объект Component и определяет интерфейс, соответствующий интерфейсу Component; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteDecoratorA</i> и <i>ConcreteDecoratorB</i> (<i>Конкретные декораторы</i>)&nbsp;&#8212; добавляют к компоненту новые возможности, изменяющие его состояние и/или поведение. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать иерархию классов, которая включает абстрактный класс Component с абстрактным методом Show (не имеет параметров, возвращает строку), абстрактный класс Decorator, который является потомком класса Component и содержит защищенное поле comp&nbsp;&#8212; ссылку на объект типа Component, и конкретные классы ConcreteComponent (потомок класса Component), ConcreteDecoratorA и ConcreteDecoratorB (потомки класса Decorator). </p><p class="ptTaskContinue">Класс ConcreteComponent содержит строковое поле text, которое инициализируется в конструкторе с помощью одноименного параметра. Метод Show класса ConcreteComponent возвращает строку text. Классы ConcreteDecoratorA и ConcreteDecoratorB имеют конструктор с параметром comp, являющимся ссылкой на объект типа Component; этот параметр присваивается полю comp. Метод Show конкретного декоратора A возвращает строку, полученную путем добавления строки &#34;==&#34; перед и после текста, возвращенного методом Show объекта comp. Метод Show конкретного декоратора B возвращает строку, полученную путем добавления символа &#34;(&#34; перед текстом, возвращенным методом Show объекта comp, и символа &#34;)&#34; после этого текста. Таким образом, каждый декоратор изменяет поведение метода Show исходного объекта Component, добавляя к возвращаемому значению дополнительный префикс и суффикс. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;9) и N пар строк (S,&nbsp;D), причем строка S является непустой, а строка D содержит только буквы &#34;A&#34; и &#34;B&#34; и может быть пустой. Создать набор из N объектов типа Component, формируя каждый элемент этого набора на основе соответствующей пары строк (S,&nbsp;D) следующим образом: вначале создать объект типа ConcreteComponent, вызвав его конструктор с параметром S, а затем последовательно применять к результирующему объекту декораторы A или В, причем количество и порядок декораторов определяется строкой D (например, в случае строки &#34;AAB&#34; к исходному объекту типа ConcreteComponent надо последовательно применить декораторы A, A и B). Перебирая созданный набор из N объектов <i>в обратном порядке</i>, вызвать для каждого из них метод Show и вывести его возвращаемое значение. </p><pre class="pt">class Component
{
public:
    virtual string Show() = 0;
};

// РЕАЛИЗУЙТЕ КЛАСС-ПОТОМОК ConcreteComponent

class Decorator : public Component
{
protected:
    Component* comp;
};

// РЕАЛИЗУЙТЕ КЛАССЫ-ПОТОМКИ ConcreteDecoratorA
//   И ConcreteDecoratorB</pre>
<h2>Proxy, Bridge, Flyweight</h2>
<p class="ptTask"><span class="ptSpecial">OOP2Struc9°</span>. </p><p class="ptPicture"><img src="file:///D:\Program\PT4\LIB\Graph\OOPProxy.png" alt="D:\Program\PT4\LIB\Graph\OOPProxy.png" border=1></p><p class="ptTaskContinue"><b>Proxy</b> (<b>Заместитель</b>)&nbsp;&#8212; структурный паттерн. </p><p class="ptTaskContinue">Известен также под именем <b>Surrogate</b> (<b>Суррогат</b>). </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: выше средней. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: является суррогатом другого объекта и контролирует доступ к нему. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Subject</i> (<i>Субъект</i>)&nbsp;&#8212; определяет общий для RealSubject и Proxy интерфейс, так что класс Proxy можно использовать везде, где ожидается RealSubject; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>RealSubject</i> (<i>Реальный субъект</i>)&nbsp;&#8212; определяет реальный объект, представленный заместителем; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Proxy</i> (<i>Заместитель</i>)&nbsp;&#8212; хранит ссылку, которая позволяет заместителю обратиться к реальному субъекту; контролирует доступ к реальному субъекту и может отвечать за его создание и удаление; прочие обязанности зависят от вида заместителя (<i>удаленный заместитель</i> отвечает за отправление запроса реальному субъекту в другом адресном пространстве; <i>виртуальный заместитель</i> может отложить создание реального субъекта и вызывать некоторые его методы самостоятельно; <i>защищающий заместитель</i> проверяет, имеет ли вызывающий объект необходимые для выполнения запроса права). </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать иерархию классов, включающую абстрактный класс Subject с абстрактными методами OperationA, OperationB, OperationC, OperationD и конкретные классы RealSubject и Proxy&nbsp;&#8212; потомки класса Subject. Указанные методы не имеют параметров и возвращают строку. Класс RealSubject не имеет полей, его методы возвращают следующие строки: &#34;A (Real)&#34;, &#34;B (Real)&#34;, &#34;C (Real)&#34;, &#34;D (Real)&#34;. </p><p class="ptTaskContinue">Класс Proxy является заместителем класса RealSubject, комбинирующим черты виртуального и защищающего заместителя. Предполагается, что операции&nbsp;A и&nbsp;B являются простыми и могут быть реализованы в самом заместителе, в то время как операции&nbsp;C и&nbsp;D являются сложными и доступны только в классе RealSubject. Кроме того, операции&nbsp;A и&nbsp;C являются безопасными, а операции&nbsp;B и&nbsp;D&nbsp;&#8212; потенциально опасными, и в некоторых ситуациях их целесообразно заблокировать. Поэтому класс Proxy содержит два логических поля: deferredMode (отложенный режим) и protectedMode (защищенный режим), которые задаются в его конструкторе и определяют его поведение по отношению к реальному субъекту. Кроме того, класс Proxy содержит поле rsubj&nbsp;&#8212; ссылку на объект типа RealSubject. </p><p class="ptTaskContinue">Если поле deferredMode равно false, то объект RealSubject создается в конструкторе класса Proxy (и связывается со ссылкой rsubj), если deferredMode равно true, то начальное значение ссылки rsubj является пустым. Если поле protectedMode равно false и при этом ссылка rsubj не является пустой, то все операции переадресуются объекту, на который ссылается rsubj. Если protectedMode равно false, а ссылка rsubj является пустой, то простые операции&nbsp;A и&nbsp;B выполняются самим объектом Proxy и при этом возвращаются строки &#34;A (Proxy)&#34; и &#34;B (Proxy)&#34;, а в случае вызова операции&nbsp;C или&nbsp;D объект RealSubject создается и связывается со ссылкой rsubj, после чего эта операция переадресуется ему. Если protectedMode равно true, то выполнение операций&nbsp;A и&nbsp;C не отличается от ранее описанного, а при попытке вызова операций&nbsp;B и&nbsp;D они отменяются (независимо от значения ссылки rsubj), причем соответствующие методы возвращают строки &#34;B denied&#34; и &#34;D denied&#34;. </p><p class="ptTaskContinue">Дан набор из трех целых чисел, принимающих значения от&nbsp;&#8722;1 до&nbsp;3, и строка, содержащая только символы из набора &#34;A&#34;, &#34;B&#34;, &#34;C&#34;, &#34;D&#34;&nbsp;&#8212; имена операций. Создать массив из трех ссылочных элементов типа Subject, инициализировав элементы конкретными объектами в зависимости от значения исходных чисел: &#8722;1&nbsp;&#8212; RealSubject, 0&nbsp;&#8212; Proxy(false, false), 1&nbsp;&#8212; Proxy(true, false), 2&nbsp;&#8212; Proxy(false, true), 3&nbsp;&#8212; Proxy(true, true). Для каждого из созданных объектов выполнить набор операций, определяемый исходной строкой, и вывести результат, возвращаемый каждой операцией. </p><pre class="pt">class Subject
{
public:
    virtual string OperationA() = 0;
    virtual string OperationB() = 0;
    virtual string OperationC() = 0;
    virtual string OperationD() = 0;
};

// РЕАЛИЗУЙТЕ КЛАССЫ-ПОТОМКИ RealSubject И Proxy</pre>
<p class="ptTask"><span class="ptSpecial">OOP2Struc10°</span>. </p><p class="ptPicture"><img src="file:///D:\Program\PT4\LIB\Graph\OOPBridge.png" alt="D:\Program\PT4\LIB\Graph\OOPBridge.png" border=1></p><p class="ptTaskContinue"><b>Bridge</b> (<b>Мост</b>)&nbsp;&#8212; структурный паттерн. </p><p class="ptTaskContinue">Известен также под именем <b>Handle/Body</b> (<b>Описатель/Тело</b>). </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: средняя. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: отделяет абстракцию от ее реализации так, чтобы то и другое можно было изменять независимо. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Abstraction</i> (<i>Абстракция</i>)&nbsp;&#8212; определяет интерфейс абстракции; хранит ссылку на объект типа Implementor; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>RefinedAbstraction</i> (<i>Уточненная</i> <i>абстракция</i>)&nbsp;&#8212; расширяет интерфейс, определенный абстракцией Abstraction; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Implementor</i> (<i>Реализатор</i>)&nbsp;&#8212; определяет интерфейс для классов реализации; не обязан точно соответствовать интерфейсу класса Abstraction (обычно предоставляет только примитивные операции, в то время как класс Abstraction определяет операции более высокого уровня, базирующиеся на этих примитивах); </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteImplementorA</i> и <i>ConcreteImplementorB</i> (<i>Конкретные реализаторы</i>)&nbsp;&#8212; содержат конкретную реализацию интерфейса класса Implementor. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать иерархию классов-<i>реализаторов</i>, содержащую абстрактного реализатора Implementor и два конкретных реализатора ConcreteImplementorA и ConcreteImplementorB. Классы отвечают за представление горизонтальных линий и текста и включают методы DrawLine(size) и DrawText(text), возвращающие строковые значения. Параметр size определяет размер линии (в символах), параметр text&nbsp;&#8212; выводимый текст. В классе Implementor методы DrawLine и DrawText являются абстрактными. Конкретный реализатор&nbsp;A представляет линию в виде набора символов &#34;&#8722;&#34;, а текст отображает в нижнем регистре. Конкретный реализатор&nbsp;B представляет линию в виде набора символов &#34;=&#34;, а текст отображает в верхнем регистре. Оба конкретных реализатора имеют конструкторы без параметров, не выполняющие дополнительных действий. </p><p class="ptTaskContinue">Реализовать класс Abstraction, предназначенный для отображения и корректировки строки заголовка. Конструктор класса принимает параметры imp типа Implementor (ссылку на используемый реализатор) и size целого типа (размер заголовка). Класс также содержит метод Show без параметров, возвращающий строку-заголовок, и метод SetSize(n), задающий размер заголовка равным значению&nbsp;n (целое неотрицательное число). Класс Abstraction реализует простейший вариант заголовка, представляющий собой линию указанного размера. </p><p class="ptTaskContinue">Реализовать класс RefinedAbstraction, который является усовершенствованным вариантом класса Abstraction и позволяет включать в заголовок текст. Конструктор класса RefinedAbstraction содержит, кроме параметров imp и size, имеющих тот же смысл, что и для конструктора класса Abstraction, строковый параметр caption. Заголовок формируется следующим образом: вначале указывается линия размера&nbsp;1, затем строка caption, затем линия такого размера, чтобы суммарный размер заголовка был равен size. Для малых значений size строка caption может урезаться справа. Переопределить нужным образом метод Show в классе RefinedAbstraction. </p><p class="ptTaskContinue">Дано целое положительное число size (начальный размер заголовка) и строка caption (необязательный элемент заголовка). Также даны пять целых положительных чисел (новые размеры заголовков). Создать экземпляры классов Abstraction и RefinedAbstraction с указанными параметрами и каждым из конкретных реализаторов&nbsp;A и&nbsp;B и вывести соответствующие заголовки методом Show. Затем, используя каждый из новых размеров, изменить размер каждого заголовка и вывести измененные заголовки. Порядок вывода заголовков для каждого размера: Abstraction с реализатором&nbsp;A, Abstraction с реализатором&nbsp;B, RefinedAbstraction с реализатором&nbsp;A, RefinedAbstraction с реализатором&nbsp;B. Для хранения созданных объектов использовать массив из четырех ссылочных элементов типа Abstraction. </p><pre class="pt">class Implementor
{
public:
    virtual string DrawLine(int size) = 0;
    virtual string DrawText(string text) = 0;
};

// РЕАЛИЗУЙТЕ КЛАССЫ-ПОТОМКИ ConcreteImplementorA
//   И ConcreteImplementorB

class Abstraction
{
protected:
    int size;
    Implementor* imp;
public:
    Abstraction(Implementor* imp, int size) : imp(imp), size(size) {}
    // ЗАВЕРШИТЕ РЕАЛИЗАЦИЮ КЛАССА Abstraction
};

// РЕАЛИЗУЙТЕ КЛАСС-ПОТОМОК RefinedAbstraction</pre>
<h1>Паттерны поведения</h1>
<p class="ptAuthor">М.&nbsp;Э.&nbsp;Абрамян, 2021</p>
<h2>Iterator, Command, State</h2>
<p class="ptTask"><span class="ptSpecial">OOP3Behav7°</span>. </p><p class="ptPicture"><img src="file:///D:\Program\PT4\LIB\Graph\OOPIterator.png" alt="D:\Program\PT4\LIB\Graph\OOPIterator.png" border=1></p><p class="ptTaskContinue"><b>Iterator</b> (<b>Итератор</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue">Известен также под именем <b>Cursor</b> (<b>Курсор</b>). </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: высокая. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: предоставляет способ последовательного доступа ко всем элементам составного объекта, не раскрывая его внутреннего представления. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Iterator</i> (<i>Итератор</i>)&nbsp;&#8212; определяет интерфейс для доступа и обхода элементов; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteIterator</i> (<i>Конкретный итератор</i>)&nbsp;&#8212; реализует интерфейс класса Iterator; следит за текущей позицией при обходе агрегата; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Aggregate</i> (<i>Агрегат</i>)&nbsp;&#8212; определяет интерфейс для создания объекта-итератора; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteAggregate</i> (<i>Конкретный агрегат</i>)&nbsp;&#8212; реализует интерфейс создания итератора и возвращает экземпляр подходящего класса ConcreteIterator. </p><p class="ptTaskContinue">Во многих современных языках программирования итераторы реализованы в стандартных библиотеках или даже на уровне языковых конструкций. Данное задание можно выполнять, используя либо базовые средства ООП, либо специализированные средства выбранного языка. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать две иерархии классов, связанные с применением паттерна Iterator. Первая иерархия является иерархией классов-<i>агрегатов</i> и включает абстрактный класс Aggregate, содержащий абстрактный метод CreateIterator (не имеет параметров, возвращает ссылку на объект Iterator), и классы ConcreteAggregateA, ConcreteAggregateB и ConcreteAggregateC. Каждый из конкретных классов содержит поле data; для класса ConcreteAggregateA оно целочисленное, для класса ConcreteAggregateB оно строковое, для класса ConcreteAggregateC оно представляет собой структуру с целочисленными элементами (например, массив; можно считать, что число элементов структуры не превосходит&nbsp;10). Поле data инициализируется в конструкторе класса с помощью параметра data того же типа, что и инициализируемое поле. Конкретные классы-агрегаты&nbsp;A,&nbsp;B и&nbsp;C реализуют метод CreateIterator возвращающий итератор, тип которого определяется типом класса-агрегата: для агрегата&nbsp;A это ConcreteIteratorA, для агрегата&nbsp;B&nbsp;&#8212; ConcreteIteratorB, для агрегата&nbsp;C&nbsp;&#8212; ConcreteIteratorC. При создании итератора в методе CreateIterator конструктору итератора передается параметр, являющийся ссылкой на объект-агрегат, вызвавший метод CreateIterator. Классы-агрегаты также имеют метод GetData без параметров, возвращающий поле data. </p><p class="ptTaskContinue">Вторая иерархия является иерархией классов-<i>итераторов</i>; она включает абстрактный класс Iterator и классы ConcreteIteratorA, ConcreteIteratorB и ConcreteIteratorC. Класс Iterator содержит четыре абстрактных метода без параметров: First и Next (не возвращают значений), IsDone (возвращает логическое значение), CurrentItem (возвращает целочисленное значение). </p><p class="ptTaskContinue">Метод First устанавливает итератор на первый элемент перебираемого набора данных, метод Next переводит итератор на следующий элемент (или за конец набора), метод IsDone возвращает значение true, если итератор указывает на позицию за концом набора, и false, если итератор указывает на некоторый элемент набора; метод CurrentItem возвращает элемент набора, на который указывает итератор, или&nbsp;&#8722;1, если итератор находится за последним элементом набора (возможен также вариант, когда в последней ситуации возбуждается исключение, поскольку в программе такая ситуация обычно свидетельствует об ошибке). Для пустого набора метод First сразу устанавливает итератор за конец набора; при нахождении итератора за концом набора метод Next не выполняет никаких действий. </p><p class="ptTaskContinue">Конкретные классы-итераторы&nbsp;A, B,&nbsp;C связаны с ранее описанными классами-агрегатами&nbsp;A, B,&nbsp;C и обеспечивают особый способ перебора содержащихся в них данных. Итератор&nbsp;A перебирает все <i>цифры</i> целочисленного поля data агрегата A <i>в обратном порядке</i> (знак числа игнорируется); для числа&nbsp;0 возвращается цифра 0 (это единственная ситуация, когда последним элементом набора является цифра&nbsp;0). Итератор&nbsp;B перебирает все <i>цифровые символы</i> строкового поля data агрегата B <i>в обратном порядке</i>. Итератор C перебирает все цифры всех элементов структуры data агрегата C, причем как сами элементы, так и их цифры должны перебираться <i>в обратном порядке</i>. Для итераторов&nbsp;B и&nbsp;C возможна ситуация, когда перебираемый набор является пустым (если строковое поле data не содержит цифровых символов или структура data не содержит ни одного элемента). Каждый конкретный итератор содержит поле aggr, которое является ссылкой на связанный с ним объект-агрегат; это поле инициализируется в конструкторе итератора с помощью соответствующего параметра. Кроме того, итераторы содержат вспомогательные поля, используемые при реализации методов First, Next, IsDone и CurrentItem. </p><p class="ptTaskContinue">Дано целое число&nbsp;N (&#8804;&nbsp;10) и N&nbsp;наборов элементов. Первый элемент каждого набора представляет собой символ &#34;A&#34;, &#34;B&#34; или &#34;C&#34;; он определяет тип создаваемого объекта-агрегата (A,&nbsp;B или&nbsp;C). Следующие элементы каждого набора определяют поле data создаваемого агрегата: для агрегата&nbsp;A это одно целое число, для агрегата&nbsp;B&nbsp;&#8212; одна строка, для агрегата&nbsp;C&nbsp;&#8212; целое число&nbsp;K (&#8804;&nbsp;10), определяющее размер структуры данных data, и К&nbsp;целых чисел&nbsp;&#8212; элементов этой структуры (число K может быть равно&nbsp;0). </p><p class="ptTaskContinue">Описать структуру (например, массив) из N&nbsp;элементов-ссылок типа Aggregate, сохранить в ней исходные объекты-агрегаты и выполнить обработку этих объектов, перебирая их <i>в обратном порядке</i>. Для каждого объекта-агрегата требуется вывести сумму цифр, возвращаемых его итератором (или&nbsp;0, если итератор ничего не возвращает), а затем&nbsp;&#8212; сами цифры, возвращаемые его итератором. </p><p class="ptTaskContinue"><span class="ptSpecial">Примечание</span>. В языках с С-подобным синтаксисом для перебора элементов с применением итератора it, имеющего описанный выше набор методов, можно использовать следующий вариант цикла for: <tt>for (it.First(); !it.IsDone(); it.Next()) &lt;обработка it.CurrentItem()&gt;</tt> </p><pre class="pt">class Iterator
{
public:
    virtual void First() = 0;
    virtual void Next() = 0;
    virtual bool IsDone() = 0;
    virtual int CurrentItem() = 0;
};

class Aggregate
{
public:
    virtual Iterator* CreateIterator() = 0;
};

// РЕАЛИЗУЙТЕ КЛАССЫ-ПОТОМКИ ConcreteAggregateA,
//   ConcreteAggregateB И ConcreteAggregateC

// РЕАЛИЗУЙТЕ КЛАССЫ-ПОТОМКИ ConcreteIteratorA,
//   ConcreteIteratorB И ConcreteIteratorC</pre>
<h2>Observer, Strategy, Template Method</h2>
<p class="ptTask"><span class="ptSpecial">OOP3Behav4°</span>. <b>Strategy</b> (<b>Стратегия</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 2</span>. Реализовать иерархию классов-<i>валидаторов</i>, включающую класс Validator и его классы-потомки EmptyValidator, NumberValidator и RangeValidator. Классы-валидаторы предназначены для проверки правильности введенных строковых данных. Классы Validator, EmptyValidator и NumberValidator не имеют полей, их конструкторы не имеют параметров и не выполняют дополнительных действий. В классе Validator определен метод Validate(s), имеющий строковый параметр s и возвращающий строку с описанием ошибки, обнаруженной в строке s. Метод Validate класса Validator всегда возвращает пустую строку; таким образом, класс Validator считает допустимой любую строку. </p><p class="ptTaskContinue">Для класса EmptyValidator метод Validate(s) возвращает пустую строку, если параметр s не является пустой строкой; в противном случае он возвращает строку &#34;!Empty text&#34;. </p><p class="ptTaskContinue">Для класса NumberValidator метод Validate(s) возвращает пустую строку, если параметр s содержит строковое представление некоторого целого числа; в противном случае он возвращает строку вида &#34;!'&lt;s&gt;': not a number&#34;, где в позиции &lt;s&gt; указывается содержимое параметра&nbsp;s. </p><p class="ptTaskContinue">Класс RangeValidator содержит целочисленные поля min и max; его конструктор имеет целочисленные параметры a и b, инициализирующие поля таким образом, чтобы поле min было равно минимальному из чисел a и b, а поле max&nbsp;&#8212; максимальному из этих чисел. Для класса RangeValidator метод Validate(s) возвращает пустую строку, если параметр s содержит строковое представление некоторого целого числа и при этом данное число лежит в диапазоне от min до max включительно; в противном случае метод возвращает строку вида &#34;!'&lt;s&gt;': not in range &lt;min&gt;..&lt;max&gt;&#34;, где в позиции &lt;s&gt; указывается содержимое параметра s, а в позициях &lt;min&gt; и &lt;max&gt;&nbsp;&#8212; значения соответствующих полей. </p><p class="ptTaskContinue">Реализовать класс TextBox, содержащий строковое поле text и поле v&nbsp;&#8212; ссылку на объект типа Validator. Конструктор класса не имеет параметров, в нем создается объект типа Validator и ссылка на него присваивается полю v, а поле text инициализируется пустой строкой. Класс TextBox включает три метода: SetText(text)&nbsp;&#8212; задает или изменяет поле text; SetValidator(v)&nbsp;&#8212; изменяет поле v; Validate (без параметров)&nbsp;&#8212; вызывает для объекта v метод Validate с параметром text и возвращает значение, возвращенное этим методом. </p><p class="ptTaskContinue">Также реализовать класс TextForm. Он содержит набор tb элементов типа TextBox (можно использовать массив или другую структуру данных). Конструктор класса TextForm имеет параметр n, определяющий размер набора tb (можно считать, что параметр n не превосходит&nbsp;10); в конструкторе создаются все элементы набора tb. Класс TextForm включает три метода: SetText(ind, text)&nbsp;&#8212; задает или изменяет поле text для элемента набора tb с индексом ind; SetValidator(ind, v)&nbsp;&#8212; изменяет поле&nbsp;v для элемента набора tb с индексом ind; Validate (без параметров)&nbsp;&#8212; последовательно вызывает методы Validate для всех элементов набора tb и возвращает строку, полученную объединением строк, возвращенных этими методами. При реализации методов SetText и SetValidator можно считать, что параметр ind всегда лежит в допустимом диапазоне (от&nbsp;0 до n&nbsp;&#8722;&nbsp;1, где n&nbsp;&#8212; размер набора&nbsp;tb). </p><p class="ptTaskContinue">Даны три целых числа&nbsp;N, A,&nbsp;B, причем&nbsp;N лежит в диапазоне от&nbsp;1 до&nbsp;10. Также дано целое число&nbsp;K, не превосходящее&nbsp;N, и набор из K пар (ind, val), где ind является целым числом в диапазоне от&nbsp;0 до N&nbsp;&#8722;&nbsp;1, а val является одним из символов &#34;E&#34;, &#34;N&#34;, &#34;R&#34;. Все значения ind являются различными. Кроме того, дано пять наборов строк, каждый из которых содержит по N элементов. </p><p class="ptTaskContinue">Создать объект tf типа TextForm, вызвав его конструктор с параметром&nbsp;N. Для каждой пары (ind, val) вызвать метод SetValidator объекта tf с первым параметром ind и вторым параметром&nbsp;&#8212; ссылкой на объект-валидатор, тип которого соответствует символу val: &#34;E&#34;&nbsp;&#8212; EmptyValidator, &#34;N&#34;&nbsp;&#8212; NumberValidator, &#34;R&#34;&nbsp;&#8212; RangeValidator; для объекта RangeValidator использовать конструктор с параметрами&nbsp;A и&nbsp;B, где&nbsp;A и&nbsp;B&nbsp;&#8212; ранее указанные числа. Для каждого из пяти данных наборов строк выполнить следующие действия: добавить набор строк в объект tf (вызвав требуемое число раз метод SetText объекта tf) и проверить правильность этого набора строк (вызвав метод Validate объекта tf и выведя его результат). </p><pre class="pt">class Validator
{
public:
    virtual string Validate(string s);
};

virtual string Validator::Validate(string s)
{
    return &quot;&quot;;
}

// РЕАЛИЗУЙТЕ КЛАССЫ-ПОТОМКИ EmptyValidator,
//   NumberValidator И RangeValidator

// РЕАЛИЗУЙТЕ КЛАССЫ TextBox И TextForm</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav5°</span>. </p><p class="ptPicture"><img src="file:///D:\Program\PT4\LIB\Graph\OOPTemplateMethod.png" alt="D:\Program\PT4\LIB\Graph\OOPTemplateMethod.png" border=1></p><p class="ptTaskContinue"><b>Template Method</b> (<b>Шаблонный метод</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: средняя. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: определяет основу алгоритма и позволяет подклассам определить (или переопределить) некоторые шаги алгоритма, не изменяя его структуру в целом. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>AbstractClass</i> (<i>Абстрактный класс</i>)&nbsp;&#8212; определяет абстрактные примитивные операции, замещаемые в конкретных подклассах для реализации шагов алгоритма; реализует шаблонный метод, определяющий последовательность действий алгоритма (шаблонный метод вызывает примитивные операции, а также операции, определенные в классе AbstractClass или в других объектах); </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteClass</i> (<i>Конкретный класс</i>)&nbsp;&#8212; реализует примитивные операции, выполняющие шаги алгоритма способом, который зависит от подкласса. </p><p class="ptTaskContinue">Помимо абстрактных примитивных операций шаблонного метода, которые <i>необходимо</i> переопределить в конкретных классах, шаблонный метод может включать операции-<i>перехватчики</i> (hooks), которые могут быть переопределены в конкретных класса, а могут быть оставлены без изменения. Использование шаблонного метода позволяет избавиться от избыточного кода в подклассах. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать иерархию классов, связанную с формированием рецептов приготовления напитков и включающую абстрактный класс AbstractClass и четыре его потомка: ConcreteClass1, ConcreteClass2 (непосредственные потомки абстрактного класса), ConcreteClass3 (потомок ConcreteClass1) и ConcreteClass4 (потомок ConcreteClass2). В абстрактном классе реализовать шаблонный метод TemplateMethod, формирующий и возвращающий строковое значение. Это значение получается путем последовательного добавления к результирующей строке значений, возвращаемых методами BasicOperation1, PrimitiveOperation, BasicOperation2 и HookOperation. Метод PrimitiveOperation является абстрактным методом, остальные методы имеют реализацию: метод BasicOperation1 возвращает строку &#34;Boil water&#34; (вскипятить воду), метод BasicOperation2 возвращает строку &#34;=Pour into a cup&#34; (налить в чашку), метод HookOperation возвращает пустую строку, причем данный метод является защищенным. </p><p class="ptTaskContinue">В классе ConcreteClass1 реализовать метод PrimitiveOperation, возвращающий строку &#34;=Brew tea&#34; (заварить чай), в классе ConcreteClass2 реализовать этот же метод, возвращающий строку &#34;=Brew coffee&#34; (заварить кофе). В классе ConcreteClass3 переопределить метод HookOperation таким образом, чтобы он возвращал строку &#34;=Add sugar and lemon&#34; (добавить сахар и лимон), в классе ConcreteClass4 переопределить этот же метод так, чтобы он возвращал строку &#34;=Add sugar and milk&#34; (добавить сахар и молоко). Конструкторы всех конкретных классов не имеют параметров и не выполняют дополнительных действий. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;10) и набор из N целых чисел, принимающих значения от&nbsp;1 до&nbsp;4. Создать структуру (например, массив) из N элементов-ссылок типа AbstractClass и инициализировать ее элементы экземплярами конкретных классов в зависимости от значений соответствующих чисел исходного набора (если число равно&nbsp;1, то создается экземпляр класса ConcreteClass1, если число равно&nbsp;2, то создается экземпляр класса ConcreteClass2 и т.&nbsp;д.). Перебирая элементы созданной структуры <i>в обратном порядке</i>, вызвать для каждого из них метод TemplateMethod и вывести возвращенную им строку. </p><pre class="pt">class AbstractClass
{
public:
    virtual string PrimitiveOperation() = 0;
    // РЕАЛИЗУЙТЕ МЕТОДЫ TemplateMethod,
    // BasicOperation1, BasicOperation2 И HookOperation
};

// РЕАЛИЗУЙТЕ КЛАССЫ-ПОТОМКИ ConcreteClass1,
//   ConcreteClass2, ConcreteClass3 И ConcreteClass4</pre>
<h2>Iterator, Command, State</h2>
<p class="ptTask"><span class="ptSpecial">OOP3Behav8°</span>. </p><p class="ptPicture"><img src="file:///D:\Program\PT4\LIB\Graph\OOPCommand.png" alt="D:\Program\PT4\LIB\Graph\OOPCommand.png" border=1></p><p class="ptTaskContinue"><b>Command</b> (<b>Команда</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue">Известен также под именем <b>Action</b> (<b>Действие</b>), <b>Transaction</b> (<b>Транзакция</b>). </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: выше средней. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: инкапсулирует запрос (действие, операцию) как объект, позволяя тем самым задавать параметры клиентов для обработки соответствующих запросов, ставить запросы в очередь или протоколировать их, а также поддерживать отмену операций. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Command</i> (<i>Команда</i>)&nbsp;&#8212; объявляет интерфейс для выполнения запроса; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteCommand</i> (<i>Конкретная команда</i>)&nbsp;&#8212; определяет связь между объектом-получателем Receiver и требуемым запросом; реализует метод Execute путем вызова требуемых методов объекта Receiver; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Client</i> (<i>Клиент</i>)&nbsp;&#8212; создает объект класса ConcreteCommand и задает его получателя; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Invoker</i> (<i>Инициатор</i>)&nbsp;&#8212; обращается к команде для выполнения запроса; не использует никакой информации о конкретном получателе запроса; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Receiver</i> (<i>Получатель</i>)&nbsp;&#8212; располагает информацией об операциях, необходимых для выполнения запроса; в роли получателя может выступать любой класс. </p><p class="ptTaskContinue">Основной особенностью паттерна Command является то, что он отделяет объект-инициатор Invoker, выдающий запросы, от объекта-получателя Receiver, который умеет эти запросы выполнять. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать классы, связанные с организацией запросов на основе паттерна Command. Иерархия классов-<i>команд</i> включает абстрактный класс Command с абстрактным методом Execute (который не имеет параметров и ничего не возвращает) и классы ConcreteCommandA и ConcreteCommandB, связанные с конкретными командами A и B. Классы ConcreteCommandA и ConcreteCommandA включают поле recv, определяющее получателя соответствующей команды; это поле является ссылкой на объект класса ReceiverA для команды A и ссылкой на объект класса ReceiverB для команды B; поле recv определяется в конструкторе конкретной команды, имеющем параметр recv соответствующего типа. Метод Execute конкретной команды A вызывает метод ActionA для объекта recv (типа ReceiverA), метод Execute конкретной команды B вызывает метод ActionB для объекта recv (типа ReceiverB). </p><p class="ptTaskContinue">Классы-<i>получатели</i> ReceiverA и ReceiverB содержат поле cli&nbsp;&#8212; ссылку на объект класса Client и поле info строкового типа; эти поля инициализируются в конструкторе, имеющем одноименные параметры cli и info. Метод ActionA класса ReceiverA вызывает метод AddLeft(info) объекта cli; метод ActionB класса ReceiverB вызывает метод AllRight(info) объекта cli. Следует подчеркнуть, что классы-получатели не входят в какую-либо особую иерархию, и каждый из них реализует свой собственный набор методов. </p><p class="ptTaskContinue">Класс-<i>клиент</i> Client содержит строковое поле info, которое инициализируется пустой строкой в конструкторе (конструктор не имеет параметров). Класс Client также содержит три метода: AddLeft(newInfo), AddRight(newInfo) и GetInfo. Методы AddLeft и AddRight имеют строковый параметр newInfo и добавляют строку newInfo соответственно в начало и конец поля info; эти методы ничего не возвращают. Метод GetInfo без параметров возвращает значение поля info. </p><p class="ptTaskContinue">Класс-<i>инициатор</i> Invoker предназначен для выполнения связанной с ним команды. Он содержит поле cmd&nbsp;&#8212; ссылку на объект типа Command, которая инициализируется в конструкторе с одноименным параметром cmd, а также метод Invoke, в котором выполняется вызов метода Execute команды cmd. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;10), задающее количество различных команд, и набор S из N различных строк, каждая из которых начинается либо с символа &#34;A&#34;, либо с символа &#34;B&#34;. Создать объект cli типа Client и набор cmd из N команд (например, массив) с элементами-ссылками типа Command. Каждый элемент набора cmd является либо командой ConcreteCommandA (если соответствующая строка набора S начинается с символа &#34;A&#34;), либо командой ConcreteCommandB (если соответствующая строка набора S начинается с символа &#34;B&#34;); при создании команд A и B используются объекты типа ReceiverA или ReceiverB соответственно, которые, в свою очередь, создаются с помощью конструкторов, имеющих  следующие параметры: ранее созданный объект cli типа Client и соответствующая строка из набора S. Например, если очередной строкой набора S является строка &#34;Apqr&#34;, то соответствующим элементом набора cmd должен быть объект ConcreteCommandA, причем его конструктору должен передаваться объект ReceiverA, в конструкторе которого указываются параметры cli и &#34;Apqr&#34;. </p><p class="ptTaskContinue">Также дано целое число K (&#8804;&nbsp;30), задающее количество различных инициаторов (объектов типа Invoker), и набор из K целых чисел со значениями из диапазона от 0 до N&nbsp;&#8722;&nbsp;1 (каждый элемент набора определяет <i>индекс</i> некоторой команды из набора cmd). Создать набор inv из K инициаторов (например, массив) с элементами-ссылками типа Invoker и инициализировать каждого инициатора командой с соответствующим индексом из набора cmd (например, если начальным элементом набора из K целых чисел является число 5, то начальный инициатор inv[0] должен инициализироваться командой cmd[5]). Несколько инициаторов может быть связано с одной и той же командой (что является стандартной ситуацией при организации пользовательского интерфейса, когда одну и ту же команду можно выполнить, например, с помощью пункта меню, кнопки быстрого доступа или горячей клавиши). </p><p class="ptTaskContinue">Наконец, дано целое число M (&#8804;&nbsp;20), задающее количество команд для выполнения, и набор из M целых чисел со значениями из диапазона от 0 до K&nbsp;&#8722;&nbsp;1 (каждый элемент набора определяет <i>индекс</i> того инициатора из набора inv, который должен использоваться для выполнения требуемой команды). Выполнить требуемые команды, вызвав метод Invoke для элементов набора inv с указанными индексами. После выполнения каждой команды выводить текущее состояние объекта cli, используя его метод GetInfo. </p><pre class="pt">// РЕАЛИЗУЙТЕ КЛАССЫ Client, ReceiverA И ReceiverB

class Command
{
public:
    virtual void Execute() = 0;
};

// РЕАЛИЗУЙТЕ КЛАССЫ-ПОТОМКИ ConcreteCommandA
//   И ConcreteCommandB

class Invoker
{
    Command* cmd;
public:
    Invoker(Command* cmd) : cmd(cmd) {}
    void Invoke();
};

void Invoker::Invoke()
{
    cmd-&gt;Execute();
}</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav10°</span>. </p><p class="ptPicture"><img src="file:///D:\Program\PT4\LIB\Graph\OOPState.png" alt="D:\Program\PT4\LIB\Graph\OOPState.png" border=1></p><p class="ptTaskContinue"><b>State</b> (<b>Состояние</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: средняя. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: позволяет объекту варьировать свое поведение в зависимости от внутреннего состояния, которое определяется одним из нескольких объектов, связанных с конкретными состояниями и имеющими одинаковый интерфейс. Извне создается впечатление, что изменился класс объекта. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Context</i> (<i>Контекст</i>)&nbsp;&#8212; определяет интерфейс, представляющий интерес для клиентов; хранит экземпляр подкласса ConcreteState, которым определяется текущее состояние; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>State</i> (<i>Состояние</i>)&nbsp;&#8212; определяет интерфейс для инкапсуляции поведения, ассоциированного с конкретным состоянием контекста Context; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteStateA</i>, <i>ConcreteStateB</i> (<i>Конкретные состояния</i>)&nbsp;&#8212; реализуют поведение, ассоциированное с некоторым состоянием контекста Context. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать набор классов, связанных с разбором текста на основе паттерна State. Предполагается, что обрабатываемый текст включает обычное содержимое (токен Normal), строковые литералы, заключенные в двойные кавычки (токен String), и комментарии, заключенные в фигурные скобки (токен Comm). Фигурные скобки в строковых литералах считаются обычными символами, как и двойные кавычки в комментариях. Если в строковом литерале встречаются две двойных кавычки подряд, то они рассматриваются как обычный символ &#34;двойная кавычка&#34;, входящий в строковый литерал. Комментарии не являются вложенными; открывающая фигурная скобка внутри комментария рассматривается как обычный символ. </p><p class="ptTaskContinue">Признаком конца разбираемого текста является наличие точки, которая не считается входящей в сам текст. В токены String не включаются обрамляющие кавычки, в токены Comm не включаются обрамляющие фигурные скобки. Если последний строковый литерал или комментарий не заканчивается требуемым символом (кавычкой или фигурной скобкой соответственно), то подобный фрагмент текста считается <i>ошибочным токеном</i> ErrString или ErrComm соответственно; такой токен должен содержать символы от начала строкового литерала или комментария вплоть до завершающей точки (не включая эту точку). </p><p class="ptTaskContinue">Любые виды токенов могут быть пустыми; в начале и конце текста, а также между специальными токенами String и Comm обязательно присутствует токен Normal (возможно, пустой). Исключением являются ошибочные токены ErrString и ErrComm, после которых разбор текста завершается. </p><p class="ptTaskContinue">Иерархия классов-<i>состояний</i> включает абстрактный класс State с абстрактным методом GetNextToken (не имеет параметров, возвращает строку с описанием очередного токена разбираемого текста) и классы ConcreteStateNormal, ConcreteStateString, ConcreteStateComm и ConcreteStateFinal. Каждый конкретный класс, кроме класса ConcreteStateFinal, содержит поле ct&nbsp;&#8212; ссылку на объект Context&nbsp;&#8212; и поле index целого типа, которые инициализируются в конструкторе с использованием соответствующих параметров. Поле ct определяет объект, содержащий разбираемый текст, а поле index определяет индекс позиции, начиная с которой требуется продолжить разбор текста. </p><p class="ptTaskContinue">Метод GetNextToken возвращает строку, содержащую полученный токен (возможно, пустой), перед которым указывается его тип и двоеточие (например, &#34;Normal:abc&#34;, &#34;ErrString:mn2&#34;, &#34;Comm:&#34;). Класс ConcreteStateFinal не содержит полей, его конструктор не выполняет дополнительных действий, а метод GetNextToken всегда возвращает пустую строку. После определения текущего токена Normal метод GetNextToken класса ConcreteStateNormal вызывает метод SetState контекста ct, указывая в качестве параметра экземпляр класса ConcreteStateString (если обнаружен символ &#34;двойная кавычка&#34;), ConcreteStateComm (если обнаружен символ &#34;{&#34;) или ConcreteStateFinal (если обнаружен символ &#34;точка&#34;). После определения текущего <i>правильного</i> токена String или Comm метод GetNextToken классов ConcreteStateString и ConcreteStateComm вызывает метод SetState контекста ct, указывая в качестве параметра экземпляр класса ConcreteStateNormal. После определения <i>ошибочного</i> токена ErrString или ErrComm метод GetNextToken классов ConcreteStateString и ConcreteStateComm вызывает метод SetState контекста ct с экземпляром класса ConcreteStateFinal. </p><p class="ptTaskContinue">Класс-<i>контекст</i> Context содержит строковое поле text с разбираемым текстом и поле-ссылку currentState типа State. Конструктор класса имеет параметр text, используемый для инициализации поля text; поле currentState инициализируется объектом типа ConcreteStateNormal. Класс Context имеет методы GetCharAt(index), SetState(newState) и GetNextToken. Метод GetCharAt возвращает символ поля text с индексом index (предполагается, что индекс находится в допустимом диапазоне); метод SetState изменяет поле currentState, присваивая ему значение параметра newState (этот метод, наряду с методом GetCharAt, используется в методах классов-состояний); метод GetNextToken возвращает очередной токен разбираемого текста, вызывая одноименный метод объекта currentState. </p><p class="ptTaskContinue">Дана строка, которая оканчивается точкой. Используя объект ct типа Context, выполнить разбор данной строки, вызывая метод GetNextToken объекта ct и выводя его возвращаемый результат, пока очередной вызов не вернет пустую строку (пустую строку выводить не следует). </p><pre class="pt">class State
{
public:
    virtual string GetNextToken() = 0;
};

// РЕАЛИЗУЙТЕ КЛАСС Context

// РЕАЛИЗУЙТЕ КЛАССЫ-ПОТОМКИ ConcreteStateNormal,
//   ConcreteStateString, ConcreteStateComm
//   И ConcreteStateFin</pre>
<h2>Mediator, Chain of&nbsp;Responsibility, Visitor, Interpreter</h2>
<p class="ptTask"><span class="ptSpecial">OOP3Behav15°</span>. </p><p class="ptPicture"><img src="file:///D:\Program\PT4\LIB\Graph\OOPVisitor.png" alt="D:\Program\PT4\LIB\Graph\OOPVisitor.png" border=1></p><p class="ptTaskContinue"><b>Visitor</b> (<b>Посетитель</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: низкая. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: описывает операцию, выполняемую с каждым объектом из некоторой структуры. Паттерн Visitor позволяет определить новую операцию, не изменяя классы этих объектов и используя различные варианты операции для объектов различных типов, входящих в одну структуру. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Visitor</i> (<i>Посетитель</i>)&nbsp;&#8212; объявляет группу методов Visit, в которой для каждого класса ConcreteElement в структуре объектов предусмотрен свой метод; имя метода (например, VisitConcreteElementA) и его параметр идентифицируют объект, который вызывает данный метод для отправки посетителю соответствующего запроса (это позволяет посетителю определить, элемент какого конкретного класса он посещает, и обращаться к элементу напрямую через его интерфейс); </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteVisitor1</i>, <i>ConcreteVisitor2</i> (<i>Конкретные посетители</i>)&nbsp;&#8212; реализуют все операции, объявленные в классе Visitor и связанные с обработкой объектов различных типов, содержащихся в обрабатываемой структуре; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Element</i> (<i>Элемент</i>)&nbsp;&#8212; определяет метод Accept, который принимает посетителя в качестве аргумента; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteElementA</i>, <i>ConcreteElementB</i> (<i>Конкретные</i> <i>элементы</i>)&nbsp;&#8212; реализуют метод Accept, принимающий посетителя как аргумент (как правило, в этом методе происходит вызов того метода из группы методов Visit указанного посетителя, который соответствует данному конкретному элементу); </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ObjectStructure</i> (<i>Структура объектов</i>)&nbsp;&#8212; может перечислять свои элементы, а также предоставлять посетителю высокоуровневый интерфейс для посещения своих элементов. </p><p class="ptTaskContinue">Совместное использование методов Accept и группы методов Visit в паттерне Visitor обеспечивает <i>двойную диспетчеризацию</i> запросов, при которой характер запроса определяется двумя объектами: конкретным посетителем и конкретным элементом. Двойная диспетчеризация позволяет посетителю по-разному обрабатывать элементы различных классов. </p><p class="ptTaskContinue">Применение паттерна Visitor оправдано, если иерархия классов-элементов является стабильной (т.&nbsp;е. в нее редко добавляются новые классы) и при этом часто возникает необходимость в новых операциях, которые требуется по-разному выполнять для элементов различных типов. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать две иерархии классов, связанные с применением паттерна Visitor. Первая иерархия является иерархией классов-<i>элементов</i> и включает абстрактный класс Element, содержащий абстрактный метод Accept с параметром-ссылкой типа Visitor (не возвращает результата), и конкретные классы ConcreteElementA, ConcreteElementB, ConcreteElementC. Каждый конкретный класс содержит поле data; для класса ConcreteElementA оно целочисленное, для класса ConcreteElementB оно строковое, для класса ConcreteElementC оно является вещественным числом. Поле data инициализируется в конструкторе класса с помощью параметра data того же типа, что и инициализируемое поле. Конкретные классы-элементы&nbsp;A,&nbsp;B и&nbsp;C реализуют метод Accept(v), в котором для параметра&nbsp;v типа Visitor выполняется вызов соответствующего метода класса Visitor, определяемого типом класса-элемента: для элемента&nbsp;A это VisitConcreteElementA, для элемента&nbsp;B&nbsp;&#8212; VisitConcreteElementB, для элемента C&nbsp;&#8212; VisitConcreteElementC (параметром методов Visit является ссылка на объект, вызвавший метод Accept). </p><p class="ptTaskContinue">Кроме того, классы-элементы имеют методы для доступа на чтение и запись к полю data: метод GetData без параметров возвращает значение поля data, метод SetData с параметром newData изменяет значение поля data на значение параметра newData. Следует подчеркнуть, что методы GetData и SetData являются <i>специфическими</i> для каждого конкретного класса-элемента (в данном случае это аналоги специфических методов OperationA и OperationB, приведенных на диаграмме классов). </p><p class="ptTaskContinue">С иерархией классов-элементов также связан класс ObjectStructure. Поле struc этого класса является структурой (например, массивом) с элементами-ссылками на объекты типа Element (можно считать, что число элементов структуры struc не превосходит&nbsp;10). Поле struc инициализируется в конструкторе с помощью параметра struc того же типа. Класс ObjectStructure содержит метод Accept(v) с параметром-ссылкой типа Visitor. Этот метод перебирает все элементы структуры struc и для каждого элемента вызывает его метод Accept с параметром v. </p><p class="ptTaskContinue">Вторая иерархия является иерархией классов-<i>посетителей</i>, связанных с ранее описанными конкретными классами. Она включает абстрактный класс Visitor и конкретные классы ConcreteVisitor1, ConcreteVisitor2 и ConcreteVisitor3. Класс Visitor содержит три абстрактных метода: VisitConcreteElementA(e), VisitConcreteElementB(e), VisitConcreteElementC(e). Эти методы не возвращают значений; их параметрами являются ссылки на соответствующие объекты-элементы (например, VisitConcreteElementA имеет параметр типа ConcreteElementA). Напомним, что именно эти методы должны вызываться в методе Accept каждого конкретного класса-элемента. </p><p class="ptTaskContinue">Конкретные классы-посетители&nbsp;1, 2,&nbsp;3 реализуют различные наборы операций, связанных с классами-элементами&nbsp;A, B,&nbsp;C, определяя методы VisitConcreteElementA(e), VisitConcreteElementB(e), VisitConcreteElementC(e). Класс ConcreteVisitor1 обеспечивает <i>вывод</i> поля data в окно задачника, вызывая в каждом из указанных методов соответствующую команду вывода для значения GetData элемента&nbsp;e. Класс ConcreteVisitor2 <i>преобразует</i> поле data различным образом для разных классов-элементов, используя метод SetData элемента&nbsp;e: для элементов типа&nbsp;A он изменяет знак целого числа data на противоположный, для элементов типа&nbsp;B он изменяет порядок следования символов строки data на противоположный, для элементов типа&nbsp;C он изменяет любое ненулевое вещественное число data на обратное к нему (равное 1/data). Класс ConcreteVisitor3 определяет некоторую <i>общую характеристику</i> для всех однотипных элементов обрабатываемой структуры: для элементов типа&nbsp;A определяется сумма их целочисленных полей data, для элементов типа&nbsp;B находится строка, получаемая сцеплением всех строковых полей data, для элементов типа&nbsp;C находится произведение вещественных полей data. Для хранения полученных характеристик надо использовать в классе ConcreteVisitor3 поля resultA, resultB, resultC, а для доступа к ним&nbsp;&#8212; методы GetResultA, GetResultB, GetResultC. Конструкторы объектов-посетителей не имеют параметров и не выполняют дополнительных действий. </p><p class="ptTaskContinue">Дано целое число&nbsp;N (&#8804;&nbsp;10) и N&nbsp;пар значений. Первое значение каждой пары представляет собой символ &#34;A&#34;, &#34;B&#34; или &#34;C&#34;; он определяет тип создаваемого объекта-элемента (A,&nbsp;B или&nbsp;C). Второе значение каждой пары определяет поле data создаваемого элемента: для элемента типа&nbsp;A это целое число, для элемента типа&nbsp;B&nbsp;&#8212; строка, для элемента типа&nbsp;C&nbsp;&#8212; вещественное число. </p><p class="ptTaskContinue">Создать объект&nbsp;s типа ObjectStructure и поместить в него все исходные элементы. Также создать три объекта-посетителя&nbsp;v1, v2,&nbsp;v3 типа ConcreteVisitor1, ConcreteVisitor2, ConcreteVisitor3 соответственно. Вывести содержимое структуры&nbsp;s, используя вызов ее метода Accept(v1), после чего преобразовать это содержимое, используя вызов Accept(v2), и вывести преобразованное содержимое с помощью еще одного вызова Accept(v1). Затем вызвать метод Accept(v3) и вывести найденные в нем характеристики элементов структуры&nbsp;s с помощью методов GetResultA, GetResultB и GetResultC объекта&nbsp;v3. </p><pre class="pt">class Visitor;

class Element
{
public:
    virtual void Accept(Visitor* v) = 0;
};

class ConcreteElementA : public Element
{
    // ДОБАВЬТЕ НЕОБХОДИМЫЕ ПОЛЯ
public:
    void Accept(Visitor* v) override;
    // ДОБАВЬТЕ НЕОБХОДИМЫЕ МЕТОДЫ
};

class ConcreteElementB : public Element
{
    // ДОБАВЬТЕ НЕОБХОДИМЫЕ ПОЛЯ
public:
    void Accept(Visitor* v) override;
    // ДОБАВЬТЕ НЕОБХОДИМЫЕ МЕТОДЫ
};

class ConcreteElementC : public Element
{
    // ДОБАВЬТЕ НЕОБХОДИМЫЕ ПОЛЯ
public:
    void Accept(Visitor* v)  override;
    // ДОБАВЬТЕ НЕОБХОДИМЫЕ МЕТОДЫ
};

class ObjectStructure
{
    vector&lt;Element*&gt; struc;
public:
    ObjectStructure(vector&lt;Element*&gt;&amp; struc) : struc(struc) {}
    void Accept(Visitor* v);
};

void ObjectStructure::Accept(Visitor* v)
{
    for (auto e : struc)
        e-&gt;Accept(v);
}

class Visitor
{
public:
    virtual void VisitConcreteElementA(ConcreteElementA* e) = 0;
    virtual void VisitConcreteElementB(ConcreteElementB* e) = 0;
    virtual void VisitConcreteElementC(ConcreteElementC* e) = 0;
};

void ConcreteElementA::Accept(Visitor* v)
{
    // РЕАЛИЗУЙТЕ МЕТОД
}
void ConcreteElementB::Accept(Visitor* v)
{
    // РЕАЛИЗУЙТЕ МЕТОД
}
void ConcreteElementC::Accept(Visitor* v)
{
    // РЕАЛИЗУЙТЕ МЕТОД
}

// РЕАЛИЗУЙТЕ КЛАССЫ-ПОТОМКИ ConcreteVisitor1,
//   ConcreteVisitor2 И ConcreteVisitor3</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav14°</span>. <b>Chain of Responsibility</b> (<b>Цепочка обязанностей</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue">В данном задании рассматривается вариант иерархии классов обработчиков, в которой базовый класс обеспечивает в методе HandleRequest всю необходимую функциональность для передачи запроса по цепочке обработчиков, а подклассы расширяют эту функциональность. Кроме того, в задании рассматривается вариант представления запросов в виде иерархии классов, инкапсулирующих параметры запроса. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 2</span>. Реализовать две иерархии классов, связанные с применением паттерна Chain of Responsibility. Первая иерархия является иерархией классов-<i>запросов</i> и включает абстрактный класс Request и два конкретных класса RequestA и RequestB. Класс Request содержит абстрактный метод ToStr без параметров, возвращающий строковое описание запроса. В классах RequestA и RequestB определено поле param, задающее параметр запроса, причем для класса A параметр является целочисленным, а для класса B&nbsp;&#8212; строковым. Поле param инициализируется в конструкторе с помощью одноименного параметра конструктора. Также в этих классах определен метод GetParam, возвращающий значение поля param, и метод ToStr, возвращающий описание запроса, включающее тип запроса (букву &#34;A&#34; или &#34;B&#34;), двоеточие и параметр запроса (целое число для запроса A и строку для запроса B), например, &#34;A:34&#34;, &#34;B:sm&#34;. </p><p class="ptTaskContinue">Вторая иерархия является иерархией классов-<i>обработчиков</i> и включает конкретный базовый класс Handler и классы-потомки HandlerA и HandlerB. Класс Handler содержит поле successor (ссылку на объект Handler) и метод HandleRequest(req) (не возвращает значений, имеет параметр-ссылку req типа Request, определяющий вид запроса). Метод HandleRequest работает следующим образом: если поле successor не является пустой ссылкой, то вызывается метод HandleRequest(req) для объекта successor, в противном случае выводится текст &#34;Request &lt;req&gt; not processed&#34; (запрос &lt;req&gt; не обработан), где на позиции &lt;req&gt; указывается значение, возвращаемое методом ToStr параметра req. Класс Handler имеет конструктор с параметром-ссылкой successor типа Handler, который инициализирует одноименное поле. Таким образом, данный класс обеспечивает всю необходимую функциональность для организации цепочки обработчиков. </p><p class="ptTaskContinue">Классы HandlerA и HandlerB предназначены для обработки запросов соответствующего типа (A или B) и имеют целочисленное поле id (идентификатор обработчика) и поля param1 и param2 (определяют диапазон параметров запросов, которые может обработать данный обработчик). Тип полей param1 и param2 соответствует типу параметра обрабатываемого запроса: для класса HandlerA это целый тип, для класса HandlerB&nbsp;&#8212; строковый. Конструктор классов HandlerA и HandlerB имеет четыре параметра: successor типа ссылки на Handler, id целого типа, param1 и param2 типа, соответствующего типу одноименных полей. В конструкторе вызывается конструктор базового класса с параметром successor и инициализируются поля id, param1 и param2. </p><p class="ptTaskContinue">Метод HandleRequest(req) классов HandlerA и HandlerB выполняет следующие действия. Вначале проверяется <i>тип времени выполнения</i> параметра req, и в случае, если этот тип соответствует типу обрабатываемого запроса (RequestA для HandlerA, RequestB для HandlerB), проверяется, лежит ли параметр param запроса req в диапазоне от param1 до param2 (строковые параметры для запроса RequestB сравниваются лексикографически). Если обе проверки являются успешными, то запрос обрабатывается путем вывода текста &#34;Request &lt;req&gt; processed by handler &lt;id&gt;&#34; (запрос &lt;req&gt; обработан обработчиком &lt;id&gt;), где на позиции &lt;req&gt; указывается значение, возвращаемое методом ToStr объекта req, а на позиции &lt;id&gt; указывается значение поля id обработчика. В противном случае выполняется вызов метода HandleRequest(req) базового класса (в котором либо происходит переход к следующему обработчику в цепочке, либо, при его отсутствии, выводится сообщение о невозможности обработать запрос). </p><p class="ptTaskContinue">Вспомогательный класс Client содержит поле h&nbsp;&#8212; ссылку типа Handler на обработчик, являющийся первым в ранее сформированной цепочке обработчиков. Поле h инициализируется в конструкторе с помощью одноименного параметра. Класс Client также содержит метод SendRequest(req), имеющий параметр-ссылку типа Request и не возвращающий значения; в этом методе выполняется вызов метода HandleRequest(req) для объекта&nbsp;h. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;10) и N троек элементов. В каждой тройке первый элемент является символом &#34;A&#34; или &#34;B&#34;, а тип остальных двух элементов (p1,&nbsp;p2) зависит от символа: в случае символа &#34;A&#34; это целые числа, а в случае &#34;B&#34;&nbsp;&#8212; строки. В любом случае выполняется неравенство p1&nbsp;&#8804;&nbsp;p2, где для чисел используется обычное сравнение, а для строк&nbsp;&#8212; лексикографическое. Используя переменную h&nbsp;&#8212; ссылку на объект Handler, последовательно создать один объект типа Handler (передав ему в качестве параметра пустую ссылку) и N объектов типа HandlerA или HandlerB (тип определяется первым элементом соответствующей тройки). Ссылки на создаваемые объекты записываются в одну и ту же переменную&nbsp;h; параметрами конструктора для объектов HandlerA и HandlerB должны быть значения&nbsp;h,&nbsp;i, p1,&nbsp;p2, где i&nbsp;&#8212; индекс очередной тройки из исходного набора (тройки индексируются от&nbsp;0), а p1 и p2&nbsp;&#8212; второй и третий элемент этой тройки. В результате будет создана цепочка из N&nbsp;+&nbsp;1 обработчика, причем первым элементом этой цепочки (ссылка на который будет храниться в переменной&nbsp;h) будет обработчик типа HandlerA или HandlerB с идентификатором N&nbsp;&#8722;&nbsp;1, предпоследним&nbsp;&#8212; обработчик типа HandlerA или HandlerB с идентификатором&nbsp;0, а последним&nbsp;&#8212; обработчик типа Handler (не имеющий идентификатора). Создать объект cli типа Client, указав в качестве параметра его конструктора значение ссылки h. </p><p class="ptTaskContinue">Также дано целое число K (&#8804;&nbsp;20) и набор из K&nbsp;различных запросов, определяемых парами элементов (c, p), где c&nbsp;&#8212; символ &#34;A&#34; или &#34;B&#34;, а p&nbsp;&#8212; параметр запроса (целочисленный в случае &#34;A&#34;, строковый в случае &#34;B&#34;). Для каждой пары создать запрос req соответствующего типа и выполнить вызов метода SendRequest(req) объекта cli. Выводить какие-либо результаты не требуется, так как вывод осуществляется в методах HandleRequest объектов-обработчиков. </p><pre class="pt">class Request
{
public:
    virtual string ToStr() = 0;
};

// РЕАЛИЗУЙТЕ КЛАССЫ-ПОТОМКИ RequestA И RequestB

class Handler
{
    Handler* successor;
public:
    Handler(Handler* successor) : successor(successor) {}
    virtual void HandleRequest(Request* req);
    ~Handler();
};

void Handler::HandleRequest(Request* req)
{
    // РЕАЛИЗУЙТЕ МЕТОД
}
Handler::~Handler()
{
    // РЕАЛИЗУЙТЕ ДЕСТРУКТОР
}

// РЕАЛИЗУЙТЕ КЛАССЫ-ПОТОМКИ HandlerA И HandlerB

class Client
{
    Handler* h;
public:
    Client(Handler* h) : h(h) {}
    void SendRequest(Request* req);
    ~Client();
};

void Client::SendRequest(Request* req)
{
    h-&gt;HandleRequest(req);
}
Client::~Client()
{
    // РЕАЛИЗУЙТЕ ДЕСТРУКТОР
}</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav17°</span>. <b>Interpreter</b> (<b>Интерпретатор</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 2</span>. Реализовать иерархию классов, которая определяет следующую грамматику строкового выражения: </p><p class="ptTaskCenter"><table align="center"><tr><td align=left>&lt;expr&gt;   <td align=center><tt>::=</tt> <td align=left>&lt;concat&gt; | &lt;if&gt; | &lt;loop&gt; | &lt;str&gt;        <tr><td align=left>&lt;concat&gt; <td align=center><tt>::=</tt> <td align=left>&lt;expr&gt;&lt;expr&gt; | &lt;concat&gt;&lt;expr&gt;          <tr><td align=left>&lt;if&gt;     <td align=center><tt>::=</tt> <td align=left>(var?&lt;expr&gt;:&lt;expr&gt;)                    <tr><td align=left>&lt;loop&gt;   <td align=center><tt>::=</tt> <td align=left>(var:&lt;expr&gt;)                           <tr><td align=left>&lt;str&gt;    <td align=center><tt>::=</tt> <td align=left>&lt;строка без символов &#34;(&#34;, &#34;)&#34;, &#34;?&#34;, &#34;:&#34;&gt;<tr><td align=left>&lt;var&gt;    <td align=center><tt>::=</tt> <td align=left>&lt;имя целочисленной переменной&gt;         </table></p><p class="ptTaskContinue"></p><p class="ptTaskContinue">Выражение concat возвращает конкатенацию нескольких выражений expr (двух или более); выражение if анализирует значение переменной var, и если var&nbsp;&#8800;&nbsp;0, то возвращает первое из указанных выражений expr, в противном случае возвращает второе из указанных выражений; выражение loop возвращает выражение expr, повторенное столько раз, каково значение переменной var (или пустую строку, если var&nbsp;&#8804;&nbsp;0). </p><p class="ptTaskContinue">Иерархия классов содержит абстрактный класс AbstractExpression, классы NontermConcat, NontermIf и NontermLoop, определяющие нетерминальные выражения concat, if, loop соответственно, и класс TermStr, определяющий терминальное выражение str. Класс AbstractExpression содержит два абстрактных метода InterpretA(cont) и InterpretB(cont), возвращающих строковое значение и определяющих два варианта интерпретации выражения (параметр-ссылка cont имеет тип Context, описываемый далее). В каждом конкретном классе (NontermConcat, NontermIf, NontermLoop и TermStr) требуется переопределить эти абстрактные методы. </p><p class="ptTaskContinue">Интерпретация A состоит в <i>восстановлении</i> строкового представления выражения, удовлетворяющего приведенной выше грамматике, по его синтаксическому дереву разбора; при этом имена переменных берутся из контекста (экземпляра класса Context). Интерпретация B состоит в <i>построении</i> конкретной строки по выражению, представленному синтаксическим деревом разбора; при этом значения переменных также берутся из контекста. </p><p class="ptTaskContinue">Примеры интерпретаций A и B для одного и того же синтаксического дерева разбора: строка &#34;abc(var1?(n:x):dd)yz&#34; и строка &#34;abcxxxxyz&#34; (при условии, что контекст содержит переменные var1&nbsp;=&nbsp;1 и n&nbsp;=&nbsp;4). </p><p class="ptTaskContinue">Класс Context должен содержать два набора элементов размера&nbsp;10: строковый набор names с именами доступных переменных и набор целых чисел values со значениями соответствующих переменных (для хранения наборов можно использовать массив или другую структуру данных). Конструктор класса Context не имеет параметров; он заносит в набор names односимвольные имена переменных от&nbsp;a до&nbsp;j, а в набор values&nbsp;&#8212; нулевые значения. Класс Context включает три метода: SetVar(ind, name, value), GetName(ind), GetValue(ind). Параметр ind во всех методах определяет индекс обрабатываемой переменной (число от&nbsp;0 до&nbsp;9). Метод SetVar задает для переменной с индексом ind имя (строку name) и значение (целое число value). Метод GetName возвращает имя переменной с индексом ind, метод GetValue возвращает значение переменной с индексом ind. При реализации этих методов можно не проверять допустимость значений параметра ind, а также не контролировать возможную ошибочную ситуацию, когда два элемента набора name совпадают (т.е. когда две разные переменные имеют одинаковые имена). </p><p class="ptTaskContinue">Класс NontermConcat содержит структуру exprs (например, массив) с элементами-ссылками типа AbstractExpression, которая инициализируется в конструкторе, имеющем соответствующий параметр-структуру. Можно считать, что выражение concat содержит не более 5 выражений expr. Класс NontermIf содержит поля expr1 и expr2&nbsp;&#8212; ссылки на AbstractExpression (первое и второе выражение expr в правой части определения выражения if)&nbsp;&#8212; и целочисленное поле ind&nbsp;&#8212; индекс переменной var в некотором объекте-контексте. Класс NontermLoop содержит поле expr&nbsp;&#8212; ссылку на AbstractExpression (выражение expr в правой части определения выражения loop)&nbsp;&#8212; и целочисленное поле ind&nbsp;&#8212; индекс переменной var в некотором объекте-контексте. Значения полей этих классов задаются в их конструкторах с помощью одноименных параметров. </p><p class="ptTaskContinue">Класс TermStr содержит строковое поле s, задаваемое в конструкторе с помощью строкового параметра. В методах InterpretA и InterpretB этого класса должно возвращаться значение поля&nbsp;s без каких-либо изменений. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;30) и N наборов значений, каждый из которых определяет один узел синтаксического дерева разбора. Последующие узлы могут содержать ссылки на предыдущие, поэтому все узлы следует сохранять в структуре nodes (например, массиве) с элементами-ссылками типа AbstractExpression. Каждый набор, соответствующий узлу синтаксического дерева, начинается с символа &#34;C&#34;, &#34;I&#34;, &#34;L&#34; или &#34;S&#34;. Объекту класса NontermConcat соответствует символ &#34;C&#34;, за которым следует целое число K (2&nbsp;&#8804;&nbsp;K&nbsp;&#8804;&nbsp;5) и K индексов узлов из уже заполненной части структуры nodes (индексирование элементов структуры nodes ведется от&nbsp;0); все узлы в указанном порядке должны входить в структуру exprs объекта NontermConcat. Объекту класса NontermIf соответствует символ &#34;I&#34;, за которым следует индекс V переменной в некотором контексте (целое число в диапазоне от&nbsp;0 до&nbsp;9) и индексы двух узлов из уже заполненной части структуры nodes. Объекту класса NontermLoop соответствует символ &#34;L&#34;, за которым следует индекс V переменной в некотором контексте и индекс некоторого узла из уже заполненной части структуры nodes. Наконец, объекту класса TermStr соответствует символ &#34;S&#34;, за которым следует строка&nbsp;&#8212; значение выражения str. </p><p class="ptTaskContinue">Также даны три набора значений, определяющих три различных контекста. Определение каждого контекста содержит целое число M (&#8804;&nbsp;10) и M наборов троек (ind, name, val), в которых ind определяет индекс переменной в контексте, name определяет имя переменной, а val&nbsp;&#8212; ее значение (для остальных переменных контекста сохраняются имена и значения по умолчанию). </p><p class="ptTaskContinue">Используя исходные данные, сформировать элементы синтаксического дерева разбора и сохранить их в структуре nodes, а также создать и настроить три объекта типа Context. Для последнего элемента структуры nodes вызвать методы InterpretA и InterpretB, указав в качестве параметра каждый из созданных контекстов, и вывести их возвращаемые значения (вначале выводятся значения, соответствующие первому контексту, затем второму, затем третьему). </p><pre class="pt">class Context
{
    // ДОБАВЬТЕ КОНСТРУКТОР, НЕОБХОДИМЫЕ ПОЛЯ И МЕТОДЫ
};

class AbstractExpression
{
public:
    virtual string InterpretA(Context* cont) = 0;
    virtual string InterpretB(Context* cont) = 0;
};

// РЕАЛИЗУЙТЕ КЛАССЫ-ПОТОМКИ TermStr, NontermConcat,
//   NontermIf И NontermLoop</pre>
<hr noshade>
<p class="ptFooter">Page generation date: 2021/11/29.</p>
</body></html>
