<!-- Programming Taskbook 4.22 | Copyright (c) M. Abramyan, 1998-2022 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>PT4Tasks</title>
<style type="text/css">
H1{font-family:"Arial";font-size:20pt;text-indent:0px;margin-top:10px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
H2{font-family:"Arial";font-size:16pt;text-indent:0px;margin-top:5px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
P{font-family:"Times New Roman";text-align:left;font-size:12pt;text-indent:0px;margin-top:0px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
TD{font-family:"Times New Roman";font-size:12pt;}
LI{font-family:"Times New Roman";font-size:12pt;}
UL{font-family:"Times New Roman";font-size:12pt;}
SUB{font-family:"Times New Roman";font-size:8pt;}
SUP{font-family:"Times New Roman";font-size:8pt;}
TABLE{margin-top:0px; margin-bottom:0px;}
P.ptAuthor{text-align:right;font-size:10pt;font-style:italic;}
P.ptTask{text-align:justify;text-indent:-50px;margin-top:5px; margin-left:60px;}
P.ptTaskQuote{text-align:left;margin-left:120px;margin-top:5px;margin-bottom:0px;}
P.ptTaskCenter{text-align:center;margin-left:60px;margin-top:5px;margin-bottom:0px;}
P.ptTaskContinue{text-align:justify;margin-left:60px;margin-top:5px; }
P.ptComment{text-align:justify;text-indent:50px;margin-top:5px;}
P.ptCommentCenter{text-align:center;margin-top:0px;}
P.ptCommentQuote{text-align:left;margin-left:120px;margin-top:0px;margin-bottom:0px;}
P.ptCommentContinue{text-align:justify;margin-top:0px;}
P.ptFooter{text-align:right;font-size:10pt;font-style:italic;margin-right:0px;}
SPAN.ptSpecial{font-family:"Arial";}
PRE{font-family:"Courier New";text-align:left;font-size:10pt;text-indent:0px;margin-top:5px; margin-right:10px; margin-bottom:0px; margin-left:60px;}
CODE{font-size:10pt;}
TT{font-size:10pt;}
P.ptPicture{font-family:Arial, sans-serif;margin-top: 5px;margin-bottom: 5px;margin-left: 60px;font-size: small;color: #000080;text-indent: 0pt;text-align: justify}
</style>
</head><body>
<h1>Characters and&nbsp;strings</h1>
<p class="ptAuthor">M.&nbsp;E.&nbsp;Abramyan, 2021</p>
<h2>Characters and&nbsp;strings: basic operations</h2>
<p class="ptTask"><span class="ptSpecial">XString8°</span>. Given an integer&nbsp;<i>N</i> (&gt;&nbsp;0) and a character&nbsp;<i>C</i>, output a string that is of length&nbsp;<i>N</i> and contains characters&nbsp;<i>C</i>. </p>
<p class="ptTask"><span class="ptSpecial">XString16°</span>. Given a string, convert all Latin capital letters of the string to lowercase. </p>
<p class="ptTask"><span class="ptSpecial">XString25°</span>. Given a string with the decimal representation of a positive integer, output a new string with the binary representation of this integer. </p>
<p class="ptTask"><span class="ptSpecial">XString30°</span>. Given a character&nbsp;<i>C</i> and two strings&nbsp;<i>S</i>, <i>S</i><sub>0</sub>, insert the string&nbsp;<i>S</i><sub>0</sub> into the string&nbsp;<i>S</i> after each occurrence of the character&nbsp;<i>C</i>. </p>
<p class="ptTask"><span class="ptSpecial">XString40°</span>. A string with at least one blank character is given. Output the substring of&nbsp;<i>S</i> that contains all characters between the first and the last blank character. If the string&nbsp;<i>S</i> contains only one blank character then output an empty string. </p>
<h2>Characters and&nbsp;strings: word processing</h2>
<p class="ptTask"><span class="ptSpecial">XString48°</span>. A string that contains English words separated by one or more blank characters is given. All string letters are in uppercase. Process each word as follows: replace all next occurrences of its first letter by the character &#34;.&#34; (for example, the word &#34;MINIMUM&#34; must be transformed into &#34;MINI.U.&#34;). Do not change blank characters in the string. </p>
<h2>Characters and&nbsp;strings: additional tasks</h2>
<p class="ptTask"><span class="ptSpecial">XString59°</span>. A string that contains a <i>fully qualified path name</i> (that is, the drive and directory parts, the file name and extension) is given. Extract the extension (without the preceding dot character) from the string. </p>
<p class="ptTask"><span class="ptSpecial">XString64°</span>. A string with an encrypted English sentence and an integer&nbsp;<i>K</i> (0&nbsp;&lt;&nbsp;<i>K</i>&nbsp;&lt;&nbsp;10) are given. The string is encrypted by means of the right cyclic shift of any letter by <i>K</i>&nbsp;positions of the English alphabet (see XString63). Decrypt the given string. </p>
<h1>Binary files</h1>
<p class="ptAuthor">M&nbsp;E.&nbsp;Abramyan, 2021</p>
<h2>Binary files: basic operations</h2>
<p class="ptTask"><span class="ptSpecial">XFile13°</span>. A file of integers is given. Create two new files; the first resulting file must contain the given file components (in inverse order) whose values are positive numbers, the second resulting file must contain the given file components (in inverse order too) whose values are negative numbers. If the given file does not contain positive or negative numbers then the corresponding resulting file must be empty. </p>
<p class="ptTask"><span class="ptSpecial">XFile34°</span>. Given a file of integers, remove file components with negative values. </p>
<h2>Work with several numeric files. Archival files</h2>
<p class="ptTask"><span class="ptSpecial">XFile55°</span>. A string&nbsp;<i>S</i><sub>0</sub>, an integer&nbsp;<i>N</i> (&#8804;&nbsp;4), and <i>N</i>&nbsp;files of integers called <i>S</i><sub>1</sub>,&nbsp;&#8230;, <i>S</i><sub><i>N</i></sub> are given. Create a new file called&nbsp;<i>S</i><sub>0</sub>; this file (an <i>archival file</i>) must contain data of all given files in the following format: the amount of components of the file&nbsp;<i>S</i><sub>1</sub> and values of all its components in the same order; the amount of components of the file&nbsp;<i>S</i><sub>2</sub> and values of all its components in the same order;&nbsp;&#8230;; the amount of components of the file&nbsp;<i>S</i><sub><i>N</i></sub> and values of all its components in the same order. </p>
<h2>Files of&nbsp;characters and&nbsp;files of&nbsp;strings</h2>
<p class="ptTask"><span class="ptSpecial">XFile70°</span>. A file of strings is given; the file contains dates in the &#34;day/month/year&#34; format (see XFile67). Write its components that corresponds to winter dates to a new file (in inverse order). If the given file does not contain required dates then the resulting file must be empty. </p>
<h1>Text files</h1>
<p class="ptAuthor">M.&nbsp;E.&nbsp;Abramyan, 2021</p>
<h2>Text files: basic operations</h2>
<p class="ptTask"><span class="ptSpecial">XText18°</span>. Given an integer&nbsp;<i>K</i> and a text file, remove <i>K</i>&nbsp;leading characters from each line of the file. If the length of some line is less than&nbsp;<i>K</i> then remove all characters from the line. </p>
<h2>Text analysis and&nbsp;formatting</h2>
<p class="ptTask"><span class="ptSpecial">XText36°</span>. A text file whose lines are right-aligned is given. Make the given text centered by means of removing a half of leading blank characters from all nonempty lines. If the amount of leading blank characters of line is an odd number then remove one blank character from the beginning of this line before centering. </p>
<h2>Text files with numeric data</h2>
<p class="ptTask"><span class="ptSpecial">XText42°</span>. Real numbers&nbsp;<i>A</i>, <i>B</i> and an integer&nbsp;<i>N</i> are given. Create a text file that contains table of values of the function&nbsp;(<i>x</i>)<sup>1/2</sup> at points of the segment&nbsp;[<i>A</i>,&nbsp;<i>B</i>] with the step <i>H</i>&nbsp;=&nbsp;(<i>B</i>&nbsp;&#8722;&nbsp;<i>A</i>)/<i>N</i> (that is, at the points&nbsp;<i>A</i>, <i>A</i>&nbsp;+&nbsp;<i>H</i>, <i>A</i>&nbsp;+&nbsp;2&#183;<i>H</i>,&nbsp;&#8230;, <i>B</i>). The table consists of two columns, the first column contains arguments&nbsp;<i>x</i>, the second one contains the function values&nbsp;(<i>x</i>)<sup>1/2</sup>. The width of the columns is&nbsp;10 and&nbsp;15 characters respectively; the width of the fractional part of arguments and function values is&nbsp;4 and&nbsp;8 respectively; all string representations of numbers are right-aligned with respect to column boundary. </p>
<p class="ptTask"><span class="ptSpecial">XText46°</span>. A text file is given. Each line of the file represents several integers and real numbers that are separated by one or more blank characters. All real numbers have nonzero fractional part. Create a binary file of real numbers that contains all given numbers with nonzero fractional part (in the same order). </p>
<p class="ptTask"><span class="ptSpecial">XText49°</span>. A text file and a binary file of integers are given. Add a string representation of each integer from the binary file to the end of the corresponding line of the text file. If the amount of integers is less than the amount of text lines  then do not change remaining text lines. </p>
<h2>Text files: additional tasks</h2>
<p class="ptTask"><span class="ptSpecial">XText55°</span>. A text file is given. Create a new binary file of characters that contains all characters of the given text (without repetitions) including blank character and punctuation marks. The characters must be in ascending order of their numeric values in the character set. </p>
<h1>Порождающие паттерны</h1>
<p class="ptAuthor">М.&nbsp;Э.&nbsp;Абрамян, 2021</p>
<h2>Singleton, Prototype, Builder</h2>
<p class="ptTask"><span class="ptSpecial">OOP1Creat6°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPSingleton.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPSingleton.png" border=1></p><p class="ptTaskContinue"><b>Singleton</b> (<b>Одиночка</b>)&nbsp;&#8212; порождающий паттерн. </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: выше средней. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Singleton</i> (<i>Одиночка</i>)&nbsp;&#8212; определяет операцию Instance, которая позволяет клиентам получать доступ к единственному экземпляру (операция Instance обычно оформляется в виде <i>статического</i>, т.&nbsp;е. классового, метода); может обеспечивать <i>отложенную инициализацию</i> данного экземпляра. </p><p class="ptTaskContinue">Чтобы проиллюстрировать особенности паттерна Singleton, в задании предлагается реализовать не только его стандартный вариант, но и основанные на той же идее варианты, допускающие использование <i>ограниченного количества</i> экземпляров. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать иерархию классов, включающую абстрактный базовый класс BaseClass и классы-потомки Singleton, Doubleton и Tenton, обеспечивающие создание ограниченного количества своих экземпляров. </p><p class="ptTaskContinue">Класс BaseClass включает целочисленное поле data и два связанных с ним метода: метод IncData(increment) увеличивает значение data на величину целочисленного параметра increment, метод GetData без параметров возвращает текущее значение поля data. Поле data инициализируется нулевым значением. </p><p class="ptTaskContinue">Класс Singleton реализует стандартный паттерн &#34;Одиночка&#34;. Он включает статическое поле uniqueInstance&nbsp;&#8212; ссылку на тип Singleton (инициализируется нулевой ссылкой), закрытый конструктор без параметров, не выполняющий дополнительных действий, и статический метод Instance (без параметров, возвращает ссылку на тип Singleton). Метод Instance выполняет следующие действия: если поле uniqueInstance является нулевой ссылкой, то метод создает объект Singleton, помещает ссылку на него в поле uniqueInstance и возвращает эту ссылку как результат своей работы; если поле uniqueInstance уже содержит ссылку на объект Singleton, то метод Instance просто возвращает эту ссылку. Дополнительно реализовать статический метод InstanceCount (без параметров), который возвращает&nbsp;0, если поле uniqueInstance содержит нулевую ссылку, и&nbsp;1 в противном случае. </p><p class="ptTaskContinue">Классы Doubleton и Tenton реализуют вариант паттерна, допускающий использование <i>не более двух</i> и <i>не более десяти</i> экземпляров соответственно. </p><p class="ptTaskContinue">Класс Doubleton включает статический массив instances из двух элементов-ссылок типа Doubleton (элементы инициализируются нулевыми значениями), закрытый конструктор и статические методы Instance1 и Instance2, которые выполняют действия, аналогичные действиям метода Instance класса Singleton, но обращаются соответственно к элементам массива instances с индексами&nbsp;0 и&nbsp;1. </p><p class="ptTaskContinue">Класс Tenton отличается от класса Doubleton тем, что его статический массив instances содержит 10&nbsp;элементов-ссылок типа Tenton, а вместо двух методов Instance1 и Instance2 он включает статический метод Instance(index) с целочисленным параметром, определяющим индекс элемента массива instances, к которому обращается данный метод. Если параметр находится вне диапазона 0&#8211;9, то метод Instance может возвращать нулевую ссылку или возбуждать исключение (при выполнении задания такая ситуация не будет возникать). </p><p class="ptTaskContinue">В классах Doubleton и Tenton дополнительно реализовать статический метод InstanceCount (без параметров), который возвращает количество элементов массива instances, не являющихся нулевыми ссылками. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;10) и набор из N строк, которые могут принимать значения &#34;S&#34;, &#34;D1&#34;, &#34;D2&#34;, &#34;T0&#34;, &#34;T1&#34;, &#8230;, &#34;T9&#34;. Создать массив&nbsp;b из N&nbsp;элементов&nbsp;&#8212; ссылок на BaseClass и инициализировать его элементы экземплярами классов Singleton, Doubleton, Tenton, используя следующие варианты статических методов в зависимости от значения соответствующей строки из исходного набора: для строки &#34;S&#34; используется метод Instance класса Singleton; для строк &#34;D1&#34;, &#34;D2&#34;&nbsp;&#8212; соответственно методы Instance1 и Instance2 класса Doubleton; для строк &#34;T0&#34;, &#34;T1&#34;,&nbsp;&#8230;, &#34;T9&#34;&nbsp;&#8212; метод Instance(index) класса Tenton с параметром index, соответствующим цифре, указанной в строке. </p><p class="ptTaskContinue">После создания всех элементов массива b вывести значения метода InstanceCount для классов Singleton, Doubleton, Tenton в указанном порядке. </p><p class="ptTaskContinue">Также дано целое число K (&#8804;&nbsp;20) и набор из K пар целых чисел (index, increment), в котором первое число находится в диапазоне от&nbsp;0 до N&nbsp;&#8722;&nbsp;1 и определяет индекс элемента в массиве&nbsp;b, а второе число определяет параметр метода IncData(increment), который надо вызвать для элемента b[index]. После вызова всех требуемых методов IncData вывести итоговые значения поля data для всех объектов массива&nbsp;b, используя метод GetData. </p><p class="ptTaskContinue"><span class="ptSpecial">Указание.</span> Для языка C# задачник Programming Taskbook выполняет тестирование при <i>однократном</i> запуске программы путем <i>многократного</i> вызова ее функции Solve. Так как между вызовами функции Solve содержимое статических полей классов сохраняется, в случае данного задания это приведет к ошибочным результатам, начиная со <i>второго</i> тестового испытания. Чтобы избежать сообщения об ошибке, следует реализовать в классах Singleton, Doubleton и Tenton вспомогательный статический метод Reset, который обнуляет все статические ссылки (uniqueInstance для класса Singleton, элементы массива instances для классов Doubleton и Tenton), и вызывать методы Reset для этих классов после вывода всех результирующих данных.</p>
<pre class="pt">public abstract class BaseClass
{
    int data;
    public void IncData(int increment)
    {
        data += increment;
    }
    public int GetData()
    {
        return data;
    }
}

public class Singleton : BaseClass
{
    static Singleton uniqueInstance;
    Singleton() {}
    public static void Reset()
    {
        uniqueInstance = null;
    }
    // Complete the implementation of the class
}

public class Doubleton : BaseClass
{
    static Doubleton[] instances = new Doubleton[2];
    Doubleton() {}
    public static void Reset()
    {
        instances[0] = instances[1] = null;
    }
    // Complete the implementation of the class
}

public class Tenton : BaseClass
{
    static Tenton[] instances = new Tenton[10];
    Tenton() {}
    public static void Reset()
    {
        for (int i = 0; i &lt; instances.Length; i++)
            instances[i] = null;
    }
    // Complete the implementation of the class
}</pre>
<h2>Factory Method, Abstract Factory</h2>
<p class="ptTask"><span class="ptSpecial">OOP1Creat4°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPAbstractFactory.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPAbstractFactory.png" border=1></p><p class="ptTaskContinue"><b>Abstract Factory</b> (<b>Абстрактная фабрика</b>)&nbsp;&#8212; порождающий паттерн. </p><p class="ptTaskContinue">Известен также под именем <b>Kit</b> (<b>Инструментарий</b>). </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: высокая. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя конкретные классы этих объектов. Методы абстрактной фабрики обычно реализуются как <i>фабричные методы</i> (см.&nbsp;OOP1Creat1). </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>AbstractFactory</i> (<i>Абстрактная фабрика</i>)&nbsp;&#8212; объявляет интерфейс для операций, создающих абстрактные объекты-продукты; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteFactory</i> (<i>Конкретная фабрика</i>)&nbsp;&#8212; реализует операции, создающие конкретные объекты-продукты; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>AbstractProduct</i> (<i>Абстрактный продукт</i>)&nbsp;&#8212; объявляет интерфейс для типа объекта-продукта; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteProduct</i> (<i>Конкретный продукт</i>)&nbsp;&#8212; определяет объект-продукт, создаваемый соответствующей конкретной фабрикой; реализует интерфейс AbstractProduct; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Client</i> (<i>Клиент</i>) &nbsp;&#8212; пользуется исключительно интерфейсами, которые объявлены в классах AbstractFactory и AbstractProduct. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать три иерархии классов, в одну из которых входят абстрактная фабрика AbstractFactory и две конкретные фабрики ConcreteFactory1 и ConcreteFactory2, в другую&nbsp;&#8212; абстрактный продукт (типа A) AbstractProductA и два его потомка ProductA1 и ProductA2, а в третью&nbsp;&#8212; абстрактный продукт (типа B) AbstractProductB и два его потомка ProductB1 и ProductB2. Все фабрики включают методы CreateProductA и CreateProductB, конкретные фабрики&nbsp;1 и&nbsp;2 возвращают конкретные продукты с соответствующим номером (фабрика&nbsp;1 возвращает продукты ProductA1 и ProductB1, фабрика&nbsp;2&nbsp;&#8212; продукты ProductA2 и ProductB2). </p><p class="ptTaskContinue">Все классы-продукты имеют метод GetInfo, возвращающий строковое значение. Кроме того, в продукте первого типа определен метод&nbsp;A без параметров, а в продукте второго типа&nbsp;&#8212; метод&nbsp;В с параметром типа AbstractProductA (методы не возвращают значений). Конкретные продукты содержат строковое поле info, которое инициализируется в конструкторе с помощью его параметра <i>целого типа</i> (в поле info записывается строковое представление целочисленного параметра конструктора). Метод GetInfo конкретных классов-продуктов возвращает текущее значение поля info. </p><p class="ptTaskContinue">Для класса-продукта ProductA1 метод&nbsp;A переводит поле info в целое число, удваивает его и сохраняет строковое представления результата в поле info; для класса-продукта ProductA2 метод&nbsp;A просто удваивает строку info. Для класса-продукта ProductB1 вызов objB.B(objA) преобразует поля objB.info и objA.info в целые числа, складывает их и сохраняет строковое представление результата в поле objB.info; для класса-продукта ProductB2 вызов objB.B(objA) находит сумму строк objB.info + objA.info и сохраняет результат в поле objB.info. </p><p class="ptTaskContinue">Дано целое число Nf, которое может быть равно&nbsp;1 или&nbsp;2, целые числа&nbsp;Na и&nbsp;Nb и строка&nbsp;S, содержащая только символы&nbsp;A и&nbsp;B. Описать ссылочные переменные&nbsp;f типа AbstractFactory, pa типа AbstractProductA и pb типа AbstractProductB. Если число Nf равно 1, то связать f с конкретной фабрикой&nbsp;1, если Nf равно&nbsp;2, то связать f с конкретной фабрикой&nbsp;2. Используя фабричные методы созданной фабрики, создать конкретные продукты типа&nbsp;A и&nbsp;B, инициализировав их данными числами Na и Nb соответственно, и связать их с переменными pa и pb. Затем для созданных продуктов pa и pb выполнить методы&nbsp;A и&nbsp;B в порядке, указанном в исходной строке S. При этом метод&nbsp;A должен вызываться для продукта pa, а метод&nbsp;B&nbsp;&#8212; для продукта pb, причем параметром метода&nbsp;B должен быть продукт pa. Используя методы GetInfo, вывести итоговые значения объектов-продуктов pa и pb (в указанном порядке). </p><p class="ptTaskContinue"><span class="ptSpecial">Примечание</span>. При выполнении задания используются только ссылки на абстрактные классы, а также только методы, определенные в абстрактных классах (за исключением конструктора создаваемой конкретной фабрики), что и составляет суть паттерна &#34;Абстрактная фабрика&#34;. </p><pre class="pt">public abstract class AbstractProductA
{
    public abstract void A();
    public abstract string GetInfo();
}

// Implement the ProductA1 and ProductA2 descendant classes

public abstract class AbstractProductB
{
    public abstract void B(AbstractProductA objA);
    public abstract string GetInfo();
}

// Implement the ProductB1 and ProductB2 descendant classes

public abstract class AbstractFactory
{
    public abstract AbstractProductA CreateProductA(int info);
    public abstract AbstractProductB CreateProductB(int info);
}

// Implement the ConcreteFactory1
//   and ConcreteFactory2 descendant classes</pre>
<h2>Singleton, Prototype, Builder</h2>
<p class="ptTask"><span class="ptSpecial">OOP1Creat7°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPPrototype.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPPrototype.png" border=1></p><p class="ptTaskContinue"><b>Prototype</b> (<b>Прототип</b>)&nbsp;&#8212; порождающий паттерн. </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: средняя. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: задает виды создаваемых объектов с помощью экземпляра-прототипа и создает новые объекты путем копирования (&#34;клонирования&#34;) этого прототипа. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Prototype</i> (<i>Прототип</i>)&nbsp;&#8212; объявляет интерфейс для клонирования самого себя; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcretePrototype</i> (<i>Конкретный прототип</i>)&nbsp;&#8212; реализует операцию клонирования себя; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Client</i> (<i>Клиент</i>)&nbsp;&#8212; создает новый объект, обращаясь к прототипу с запросом клонировать себя. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать иерархию классов, которая содержит абстрактный прототип Prototype и два конкретных прототипа ConcretePrototype1 и ConcretePrototype2. Все классы включают метод Clone без параметров, возвращающий копию объекта, вызвавшего данный метод, а также методы GetInfo и ChangeId. Метод GetInfo без параметров возвращает строку, метод ChangeId имеет целочисленный параметр id и не возвращает значений. В классе Prototype методы Clone, GetInfo и ChangeId являются абстрактными. Конкретные прототипы содержат строковое поле data и целочисленное поле id, которые инициализируются соответствующими параметрами конструктора. Метод GetInfo для конкретных прототипов возвращает строку, содержащую краткое имя типа (CP1 для типа ConcretePrototype1 и CP2 для типа ConcretePrototype2) и значения полей data и id (части описания разделяются символом &#34;=&#34;, например, &#34;CP1=TEXT=34&#34;). Метод ChangeId изменяет значение поля id. При реализации метода Clone можно использовать специальные средства стандартной библиотеки или обычный вызов конструктора. </p><p class="ptTaskContinue">Также реализовать класс Client, предназначенный для работы с группой объектов типа ConcretePrototype1 или ConcretePrototype2. Конструктор класса Client имеет параметр-ссылку типа Prototype, определяющий прототип объектов, включаемых в группу (прототип в группу не входит и сохраняется в специальном поле prot; для хранения группы объектов удобно использовать динамическую структуру). Класс Client также содержит методы AddObject(id) и GetObjects. Метод AddObject добавляет в набор новый объект, получаемый путем клонирования прототипа и последующего изменения поля id полученного объекта в соответствии со значением параметра метода AddObject. Метод GetObjects без параметров возвращает строку с описанием всех объектов группы (описания разделяются пробелом). Все объекты создаваемой группы имеют одно и то же поле data и различные поля id (задаваемые в методе AddObject). </p><p class="ptTaskContinue">Дана строка S, целое число N (&#8804;&nbsp;10) и набор из N целых чисел. С помощью двух объектов класса Client сформировать два набора из N объектов типа ConcretePrototype1 (для первого объекта Client) и ConcretePrototype2 (для второго объекта Client). Все созданные объекты должны иметь одинаковые поля data, равные строке S, и значения полей id, взятые из исходного набора целых чисел. Используя метод GetObjects, вывести строковые описания каждого из полученных наборов объектов. </p><p class="ptTaskContinue"><span class="ptSpecial">Примечание</span>. В реальной ситуации подход, основанный на паттерне &#34;Прототип&#34; будет эффективным, если объем действий по обычному созданию объекта превосходит объем действий по его клонированию и последующей настройке некоторых свойств. </p><pre class="pt">public abstract class Prototype
{
    public abstract Prototype Clone();
    public abstract void ChangeId(int id);
    public abstract string GetInfo();
}

// Implement the ConcretePrototype1
//   and ConcretePrototype2 descendant classes

public class Client
{
    // Add required fields
    public Client(Prototype p)
    {
        // Implement the constructor
    }
    public void AddObject(int id)
    {
        // Implement the method
    }
    public string GetObjects()
    {
        return &quot;&quot;;
        // Remove the previous statement and implement the method
    }
}</pre>
<p class="ptTask"><span class="ptSpecial">OOP1Creat9°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPBuilder.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPBuilder.png" border=1></p><p class="ptTaskContinue"><b>Builder</b> (<b>Строитель</b>)&nbsp;&#8212; порождающий паттерн. </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: ниже средней. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Builder</i> (<i>Строитель</i>)&nbsp;&#8212; задает абстрактный интерфейс для создания частей объекта Product; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteBuilder</i> (<i>Конкретный</i> <i>строитель</i>)&nbsp;&#8212; конструирует и собирает вместе части продукта посредством реализации интерфейса Builder, предоставляет интерфейс для доступа к продукту; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Director</i> (<i>Распорядитель</i>)&nbsp;&#8212; конструирует объект Product, пользуясь интерфейсом Builder; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Product</i> (<i>Продукт</i>)&nbsp;&#8212; представляет сложный конструируемый объект. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать иерархию классов-строителей, конструирующих продукты-строки. Иерархия включает абстрактный класс Builder, который предоставляет интерфейс для инициализации продукта (BuildStart) и создания трех его фрагментов (BuildPartA, BuildPartB, BuildPartC), и конкретные классы ConcreteBuilder1 и ConcreteBuilder2, которые определяют конкретные способы конструирования. Методы BuildStart, BuildPartA, BuildPartB, BuildPartC не имеют параметров и не возвращают значений. В абстрактном классе Builder подобные методы обычно не выполняют никаких действий, хотя и не являются абстрактными; это позволяет конкретному классу-строителю не переопределять некоторые из них, если его устраивает поведение по умолчанию. Кроме того, в классе Builder определен абстрактный метод GetResult без параметров, возвращающий строку-продукт. </p><p class="ptTaskContinue">Конкретные классы ConcreteBuilder1 и ConcreteBuilder2 содержат строковое поле product; их метод GetResult возвращает текущее значение поля product. В конструкторе этих классов поле product инициализируется пустой строкой, это же действие выполняет и метод BuildStart. Каждый из методов BuildPartA, BuildPartB, BuildPartC добавляет к строке product новый текстовый фрагмент; для класса ConcreteBuilder1 фрагменты A, B, C представляют собой строки &#34;-1-&#34;, &#34;-2-&#34; и &#34;-3-&#34;, а для класса ConcreteBuilder2&nbsp;&#8212; строки &#34;=*=&#34;, &#34;=**=&#34; и &#34;=***=&#34;. </p><p class="ptTaskContinue">Также определить класс Director, содержащий поле b&nbsp;&#8212; ссылку на объект типа Builder (поле b инициализируется в конструкторе с использованием параметра конструктора того же типа) и два метода: Construct(templat) и GetResult. Метод GetResult не имеет параметров и возвращает значение метода GetResult объекта&nbsp;b, т.&nbsp;е. построенный продукт. Метод Construct обеспечивает построение продукта; его строковый параметр templat определяет план строительства. В данном случае план определяется последовательностью символов &#34;A&#34;, &#34;B&#34;, &#34;C&#34;, каждый из которых соответствует фрагменту A, B, C, добавляемому к конструируемой строке в указанном порядке. Строка templat может содержать символы, отличные от &#34;A&#34;, &#34;B&#34;, &#34;C&#34;; подобные символы игнорируются. В начале своей работы метод Construct должен вызвать метод BuildStart. </p><p class="ptTaskContinue">Даны пять строк, каждая из которых содержит план строительства. Создать два экземпляра d1 и d2 класса Director, передав первому экземпляру объект типа ConcreteBuilder1, а второму&nbsp;&#8212; объект типа ConcreteBuilder2. Вызвать метод Construct объектов d1 и d2 для каждой из исходных строк и вывести полученные результаты, используя метод GetResult (вначале выводятся результаты для первой исходной строки, затем для второй и т.&nbsp;д.). </p><pre class="pt">public abstract class Builder
{
    public virtual void BuildStart() {}
    public virtual void BuildPartA() {}
    public virtual void BuildPartB() {}
    public virtual void BuildPartC() {}
    public abstract string GetResult();
}

// Implement the ConcreteBuilder1
//   and ConcreteBuilder2 descendant classes

public class Director
{
    Builder b;
    public Director(Builder b)
    {
        this.b = b;
    }
    public string GetResult()
    {
        return b.GetResult();
    }
    public void Construct(string templat)
    {
        // Implement the method
    }
}</pre>
<h1>Структурные паттерны</h1>
<p class="ptAuthor">М.&nbsp;Э.&nbsp;Абрамян, 2021</p>
<h2>Adapter, Composite, Decorator</h2>
<p class="ptTask"><span class="ptSpecial">OOP2Struc3°</span>. <b>Adapter</b> (<b>Адаптер</b>)&nbsp;&#8212; структурный паттерн. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 3</span>. Дан абстрактный класс Shape, предоставляющий интерфейс для графических объектов: метод GetInfo без параметров, возвращающий строку с именем объекта и координатами левой верхней и правой нижней вершины ограничивающего прямоугольника (считается, что ось <i>OY</i> направлена вниз), и метод MoveBy(a, b) с двумя целочисленными параметрами, определяющими вектор, на который надо сместить данный графический объект (метод не возвращает значений). В классе Shape методы GetInfo и MoveBy являются абстрактными. </p><p class="ptTaskContinue">Также дан конкретный класс RectShape&nbsp;&#8212; потомок класса Shape, реализующий прямоугольник и имеющий конструктор с параметрами (x1, y1, x2, y2), задающими координаты левой верхней и правой нижней вершины этого прямоугольника. Метод GetInfo для данного класса возвращает строку вида &#34;R(x1,y1)(x2,y2)&#34; с текущими значениями координат. </p><p class="ptTaskContinue">Дан класс TextView для работы с текстовыми объектами. Он содержит поля x, y (координаты точки привязки&nbsp;&#8212; левого верхнего угла текстовой области), width, height (ширина и высота текстовой области) и методы GetOrigin (возвращает координаты точки привязки), SetOrigin (изменяет точку привязки), GetSize (возвращает размеры текстовой области) и SetSize (изменяет размеры текстовой области). Методы GetOrigin и GetSize возвращают результаты либо с помощью выходных параметров, либо с помощью структурного возвращаемого значения&nbsp;&#8212; массива или кортежа. Конструктор класса не имеет параметров (поля x и y полагаются равными&nbsp;0, поля width и height&nbsp;&#8212; равными&nbsp;1). </p><p class="ptTaskContinue">Реализовать класс TextShape, адаптирующий класс TextView к интерфейсу класса Shape. Класс должен быть адаптером объекта: он порождается от класса Shape и включает поле tview, являющееся ссылкой на экземпляр адаптируемого объекта TextView (других полей класс TextShape не содержит). Метод GetInfo класса TextShape должен возвращать строку вида &#34;T(x1,y1)(x2,y2)&#34; с текущими значениями левой верхней и правой нижней вершины ограничивающего прямоугольника. Включить в класс TextShape конструктор с параметрами (tview, x1, y1, x2, y2); смысл четырех последних параметров аналогичен смыслу параметров конструктора класса RectShape. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;8) и набор из N пятерок (C, X1, Y1, X2, Y2), где C является символом &#34;R&#34; или &#34;T&#34;, а остальные элементы являются целыми числами. Кроме того, даны целые числа A и B. Создать структуру данных (например, массив) с элементами типа Shape и заполнить ее объектами типа RectShape (для пятерок с символом &#34;R&#34;) и TextShape (для пятерок с символом &#34;T&#34;), используя значения X1, Y1, X2, Y2 в качестве параметров соответствующего конструктора. Применить к каждому элементу созданного набора метод MoveBy с параметрами A и B и вывести строковые представления элементов набора с помощью метода GetInfo (перебирая элементы в исходном порядке). </p><pre class="pt">public class TextView
{
    // Do not change the implementation of the class
    int x, y;
    int width = 1, height = 1;
    public void GetOrigin(out int x, out int y)
    {
        x = this.x;
        y = this.y;
    }
    public void SetOrigin(int x, int y)
    {
        this.x = x;
        this.y = y;
    }
    public void GetSize(out int width, out int height)
    {
        width = this.width;
        height = this.height;
    }
    public void SetSize(int width, int height)
    {
        this.width = width;
        this.height = height;
    }
}

public abstract class Shape
{
    public abstract string GetInfo();
    public abstract void MoveBy(int a, int b);
}

// Implement the RectShape and TextShape descendant classes</pre>
<p class="ptTask"><span class="ptSpecial">OOP2Struc7°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPDecorator.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPDecorator.png" border=1></p><p class="ptTaskContinue"><b>Decorator</b> (<b>Декоратор</b>)&nbsp;&#8212; структурный паттерн. </p><p class="ptTaskContinue">Известен также под именем <b>Wrapper</b> (<b>Обертка</b>). </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: средняя. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: динамически добавляет объекту новые возможности, приводящие к изменению его состояния и/или поведения. Является гибкой альтернативой порождению подклассов с целью расширения функциональности. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Component</i> (<i>Компонент</i>)&nbsp;&#8212; определяет интерфейс для объектов, к которым могут быть динамически добавлены новые возможности; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteComponent</i> (<i>Конкретный компонент</i>)&nbsp;&#8212; определяет объект, к которому могут быть добавлены новые возможности; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Decorator</i> (<i>Декоратор</i>)&nbsp;&#8212; хранит ссылку на объект Component и определяет интерфейс, соответствующий интерфейсу Component; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteDecoratorA</i> и <i>ConcreteDecoratorB</i> (<i>Конкретные декораторы</i>)&nbsp;&#8212; добавляют к компоненту новые возможности, изменяющие его состояние и/или поведение. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать иерархию классов, которая включает абстрактный класс Component с абстрактным методом Show (не имеет параметров, возвращает строку), абстрактный класс Decorator, который является потомком класса Component и содержит защищенное поле comp&nbsp;&#8212; ссылку на объект типа Component, и конкретные классы ConcreteComponent (потомок класса Component), ConcreteDecoratorA и ConcreteDecoratorB (потомки класса Decorator). </p><p class="ptTaskContinue">Класс ConcreteComponent содержит строковое поле text, которое инициализируется в конструкторе с помощью одноименного параметра. Метод Show класса ConcreteComponent возвращает строку text. Классы ConcreteDecoratorA и ConcreteDecoratorB имеют конструктор с параметром comp, являющимся ссылкой на объект типа Component; этот параметр присваивается полю comp. Метод Show конкретного декоратора A возвращает строку, полученную путем добавления строки &#34;==&#34; перед и после текста, возвращенного методом Show объекта comp. Метод Show конкретного декоратора B возвращает строку, полученную путем добавления символа &#34;(&#34; перед текстом, возвращенным методом Show объекта comp, и символа &#34;)&#34; после этого текста. Таким образом, каждый декоратор изменяет поведение метода Show исходного объекта Component, добавляя к возвращаемому значению дополнительный префикс и суффикс. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;9) и N пар строк (S,&nbsp;D), причем строка S является непустой, а строка D содержит только буквы &#34;A&#34; и &#34;B&#34; и может быть пустой. Создать набор из N объектов типа Component, формируя каждый элемент этого набора на основе соответствующей пары строк (S,&nbsp;D) следующим образом: вначале создать объект типа ConcreteComponent, вызвав его конструктор с параметром S, а затем последовательно применять к результирующему объекту декораторы A или В, причем количество и порядок декораторов определяется строкой D (например, в случае строки &#34;AAB&#34; к исходному объекту типа ConcreteComponent надо последовательно применить декораторы A, A и B). Перебирая созданный набор из N объектов <i>в обратном порядке</i>, вызвать для каждого из них метод Show и вывести его возвращаемое значение. </p><pre class="pt">public abstract class Component
{
    public abstract string Show();
}

// Implement the ConcreteComponent descendant class

public abstract class Decorator : Component
{
    protected Component comp;
}

// Implement the ConcreteDecoratorA
//   and ConcreteDecoratorB descendant classes</pre>
<h2>Proxy, Bridge, Flyweight</h2>
<p class="ptTask"><span class="ptSpecial">OOP2Struc9°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPProxy.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPProxy.png" border=1></p><p class="ptTaskContinue"><b>Proxy</b> (<b>Заместитель</b>)&nbsp;&#8212; структурный паттерн. </p><p class="ptTaskContinue">Известен также под именем <b>Surrogate</b> (<b>Суррогат</b>). </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: выше средней. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: является суррогатом другого объекта и контролирует доступ к нему. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Subject</i> (<i>Субъект</i>)&nbsp;&#8212; определяет общий для RealSubject и Proxy интерфейс, так что класс Proxy можно использовать везде, где ожидается RealSubject; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>RealSubject</i> (<i>Реальный субъект</i>)&nbsp;&#8212; определяет реальный объект, представленный заместителем; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Proxy</i> (<i>Заместитель</i>)&nbsp;&#8212; хранит ссылку, которая позволяет заместителю обратиться к реальному субъекту; контролирует доступ к реальному субъекту и может отвечать за его создание и удаление; прочие обязанности зависят от вида заместителя (<i>удаленный заместитель</i> отвечает за отправление запроса реальному субъекту в другом адресном пространстве; <i>виртуальный заместитель</i> может отложить создание реального субъекта и вызывать некоторые его методы самостоятельно; <i>защищающий заместитель</i> проверяет, имеет ли вызывающий объект необходимые для выполнения запроса права). </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать иерархию классов, включающую абстрактный класс Subject с абстрактными методами OperationA, OperationB, OperationC, OperationD и конкретные классы RealSubject и Proxy&nbsp;&#8212; потомки класса Subject. Указанные методы не имеют параметров и возвращают строку. Класс RealSubject не имеет полей, его методы возвращают следующие строки: &#34;A (Real)&#34;, &#34;B (Real)&#34;, &#34;C (Real)&#34;, &#34;D (Real)&#34;. </p><p class="ptTaskContinue">Класс Proxy является заместителем класса RealSubject, комбинирующим черты виртуального и защищающего заместителя. Предполагается, что операции&nbsp;A и&nbsp;B являются простыми и могут быть реализованы в самом заместителе, в то время как операции&nbsp;C и&nbsp;D являются сложными и доступны только в классе RealSubject. Кроме того, операции&nbsp;A и&nbsp;C являются безопасными, а операции&nbsp;B и&nbsp;D&nbsp;&#8212; потенциально опасными, и в некоторых ситуациях их целесообразно заблокировать. Поэтому класс Proxy содержит два логических поля: deferredMode (отложенный режим) и protectedMode (защищенный режим), которые задаются в его конструкторе и определяют его поведение по отношению к реальному субъекту. Кроме того, класс Proxy содержит поле rsubj&nbsp;&#8212; ссылку на объект типа RealSubject. </p><p class="ptTaskContinue">Если поле deferredMode равно false, то объект RealSubject создается в конструкторе класса Proxy (и связывается со ссылкой rsubj), если deferredMode равно true, то начальное значение ссылки rsubj является пустым. Если поле protectedMode равно false и при этом ссылка rsubj не является пустой, то все операции переадресуются объекту, на который ссылается rsubj. Если protectedMode равно false, а ссылка rsubj является пустой, то простые операции&nbsp;A и&nbsp;B выполняются самим объектом Proxy и при этом возвращаются строки &#34;A (Proxy)&#34; и &#34;B (Proxy)&#34;, а в случае вызова операции&nbsp;C или&nbsp;D объект RealSubject создается и связывается со ссылкой rsubj, после чего эта операция переадресуется ему. Если protectedMode равно true, то выполнение операций&nbsp;A и&nbsp;C не отличается от ранее описанного, а при попытке вызова операций&nbsp;B и&nbsp;D они отменяются (независимо от значения ссылки rsubj), причем соответствующие методы возвращают строки &#34;B denied&#34; и &#34;D denied&#34;. </p><p class="ptTaskContinue">Дан набор из трех целых чисел, принимающих значения от&nbsp;&#8722;1 до&nbsp;3, и строка, содержащая только символы из набора &#34;A&#34;, &#34;B&#34;, &#34;C&#34;, &#34;D&#34;&nbsp;&#8212; имена операций. Создать массив из трех ссылочных элементов типа Subject, инициализировав элементы конкретными объектами в зависимости от значения исходных чисел: &#8722;1&nbsp;&#8212; RealSubject, 0&nbsp;&#8212; Proxy(false, false), 1&nbsp;&#8212; Proxy(true, false), 2&nbsp;&#8212; Proxy(false, true), 3&nbsp;&#8212; Proxy(true, true). Для каждого из созданных объектов выполнить набор операций, определяемый исходной строкой, и вывести результат, возвращаемый каждой операцией. </p><pre class="pt">public abstract class Subject
{
    public abstract string OperationA();
    public abstract string OperationB();
    public abstract string OperationC();
    public abstract string OperationD();
}

// Implement the RealSubject and Proxy descendant classes</pre>
<p class="ptTask"><span class="ptSpecial">OOP2Struc10°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPBridge.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPBridge.png" border=1></p><p class="ptTaskContinue"><b>Bridge</b> (<b>Мост</b>)&nbsp;&#8212; структурный паттерн. </p><p class="ptTaskContinue">Известен также под именем <b>Handle/Body</b> (<b>Описатель/Тело</b>). </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: средняя. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: отделяет абстракцию от ее реализации так, чтобы то и другое можно было изменять независимо. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Abstraction</i> (<i>Абстракция</i>)&nbsp;&#8212; определяет интерфейс абстракции; хранит ссылку на объект типа Implementor; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>RefinedAbstraction</i> (<i>Уточненная</i> <i>абстракция</i>)&nbsp;&#8212; расширяет интерфейс, определенный абстракцией Abstraction; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Implementor</i> (<i>Реализатор</i>)&nbsp;&#8212; определяет интерфейс для классов реализации; не обязан точно соответствовать интерфейсу класса Abstraction (обычно предоставляет только примитивные операции, в то время как класс Abstraction определяет операции более высокого уровня, базирующиеся на этих примитивах); </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteImplementorA</i> и <i>ConcreteImplementorB</i> (<i>Конкретные реализаторы</i>)&nbsp;&#8212; содержат конкретную реализацию интерфейса класса Implementor. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать иерархию классов-<i>реализаторов</i>, содержащую абстрактного реализатора Implementor и два конкретных реализатора ConcreteImplementorA и ConcreteImplementorB. Классы отвечают за представление горизонтальных линий и текста и включают методы DrawLine(size) и DrawText(text), возвращающие строковые значения. Параметр size определяет размер линии (в символах), параметр text&nbsp;&#8212; выводимый текст. В классе Implementor методы DrawLine и DrawText являются абстрактными. Конкретный реализатор&nbsp;A представляет линию в виде набора символов &#34;&#8722;&#34;, а текст отображает в нижнем регистре. Конкретный реализатор&nbsp;B представляет линию в виде набора символов &#34;=&#34;, а текст отображает в верхнем регистре. Оба конкретных реализатора имеют конструкторы без параметров, не выполняющие дополнительных действий. </p><p class="ptTaskContinue">Реализовать класс Abstraction, предназначенный для отображения и корректировки строки заголовка. Конструктор класса принимает параметры imp типа Implementor (ссылку на используемый реализатор) и size целого типа (размер заголовка). Класс также содержит метод Show без параметров, возвращающий строку-заголовок, и метод SetSize(n), задающий размер заголовка равным значению&nbsp;n (целое неотрицательное число). Класс Abstraction реализует простейший вариант заголовка, представляющий собой линию указанного размера. </p><p class="ptTaskContinue">Реализовать класс RefinedAbstraction, который является усовершенствованным вариантом класса Abstraction и позволяет включать в заголовок текст. Конструктор класса RefinedAbstraction содержит, кроме параметров imp и size, имеющих тот же смысл, что и для конструктора класса Abstraction, строковый параметр caption. Заголовок формируется следующим образом: вначале указывается линия размера&nbsp;1, затем строка caption, затем линия такого размера, чтобы суммарный размер заголовка был равен size. Для малых значений size строка caption может урезаться справа. Переопределить нужным образом метод Show в классе RefinedAbstraction. </p><p class="ptTaskContinue">Дано целое положительное число size (начальный размер заголовка) и строка caption (необязательный элемент заголовка). Также даны пять целых положительных чисел (новые размеры заголовков). Создать экземпляры классов Abstraction и RefinedAbstraction с указанными параметрами и каждым из конкретных реализаторов&nbsp;A и&nbsp;B и вывести соответствующие заголовки методом Show. Затем, используя каждый из новых размеров, изменить размер каждого заголовка и вывести измененные заголовки. Порядок вывода заголовков для каждого размера: Abstraction с реализатором&nbsp;A, Abstraction с реализатором&nbsp;B, RefinedAbstraction с реализатором&nbsp;A, RefinedAbstraction с реализатором&nbsp;B. Для хранения созданных объектов использовать массив из четырех ссылочных элементов типа Abstraction. </p><pre class="pt">public abstract class Implementor
{
    public abstract string DrawLine(int size);
    public abstract string DrawText(string text);
}

// Implement the ConcreteImplementorA
//   and ConcreteImplementorB descendant classes

public class Abstraction
{
    protected int size;
    protected Implementor imp;
    public Abstraction(Implementor imp, int size)
    {
        this.imp = imp;
        this.size = size;
    }
    // Complete the implementation of the class
}

// Implement the RefinedAbstraction descendant class</pre>
<h1>Паттерны поведения</h1>
<p class="ptAuthor">М.&nbsp;Э.&nbsp;Абрамян, 2021</p>
<h2>Iterator, Command, State</h2>
<p class="ptTask"><span class="ptSpecial">OOP3Behav7°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPIterator.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPIterator.png" border=1></p><p class="ptTaskContinue"><b>Iterator</b> (<b>Итератор</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue">Известен также под именем <b>Cursor</b> (<b>Курсор</b>). </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: высокая. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: предоставляет способ последовательного доступа ко всем элементам составного объекта, не раскрывая его внутреннего представления. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Iterator</i> (<i>Итератор</i>)&nbsp;&#8212; определяет интерфейс для доступа и обхода элементов; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteIterator</i> (<i>Конкретный итератор</i>)&nbsp;&#8212; реализует интерфейс класса Iterator; следит за текущей позицией при обходе агрегата; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Aggregate</i> (<i>Агрегат</i>)&nbsp;&#8212; определяет интерфейс для создания объекта-итератора; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteAggregate</i> (<i>Конкретный агрегат</i>)&nbsp;&#8212; реализует интерфейс создания итератора и возвращает экземпляр подходящего класса ConcreteIterator. </p><p class="ptTaskContinue">Во многих современных языках программирования итераторы реализованы в стандартных библиотеках или даже на уровне языковых конструкций. Данное задание можно выполнять, используя либо базовые средства ООП, либо специализированные средства выбранного языка. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать две иерархии классов, связанные с применением паттерна Iterator. Первая иерархия является иерархией классов-<i>агрегатов</i> и включает абстрактный класс Aggregate, содержащий абстрактный метод CreateIterator (не имеет параметров, возвращает ссылку на объект Iterator), и классы ConcreteAggregateA, ConcreteAggregateB и ConcreteAggregateC. Каждый из конкретных классов содержит поле data; для класса ConcreteAggregateA оно целочисленное, для класса ConcreteAggregateB оно строковое, для класса ConcreteAggregateC оно представляет собой структуру с целочисленными элементами (например, массив; можно считать, что число элементов структуры не превосходит&nbsp;10). Поле data инициализируется в конструкторе класса с помощью параметра data того же типа, что и инициализируемое поле. Конкретные классы-агрегаты&nbsp;A,&nbsp;B и&nbsp;C реализуют метод CreateIterator возвращающий итератор, тип которого определяется типом класса-агрегата: для агрегата&nbsp;A это ConcreteIteratorA, для агрегата&nbsp;B&nbsp;&#8212; ConcreteIteratorB, для агрегата&nbsp;C&nbsp;&#8212; ConcreteIteratorC. При создании итератора в методе CreateIterator конструктору итератора передается параметр, являющийся ссылкой на объект-агрегат, вызвавший метод CreateIterator. Классы-агрегаты также имеют метод GetData без параметров, возвращающий поле data. </p><p class="ptTaskContinue">Вторая иерархия является иерархией классов-<i>итераторов</i>; она включает абстрактный класс Iterator и классы ConcreteIteratorA, ConcreteIteratorB и ConcreteIteratorC. Класс Iterator содержит четыре абстрактных метода без параметров: First и Next (не возвращают значений), IsDone (возвращает логическое значение), CurrentItem (возвращает целочисленное значение). </p><p class="ptTaskContinue">Метод First устанавливает итератор на первый элемент перебираемого набора данных, метод Next переводит итератор на следующий элемент (или за конец набора), метод IsDone возвращает значение true, если итератор указывает на позицию за концом набора, и false, если итератор указывает на некоторый элемент набора; метод CurrentItem возвращает элемент набора, на который указывает итератор, или&nbsp;&#8722;1, если итератор находится за последним элементом набора (возможен также вариант, когда в последней ситуации возбуждается исключение, поскольку в программе такая ситуация обычно свидетельствует об ошибке). Для пустого набора метод First сразу устанавливает итератор за конец набора; при нахождении итератора за концом набора метод Next не выполняет никаких действий. </p><p class="ptTaskContinue">Конкретные классы-итераторы&nbsp;A, B,&nbsp;C связаны с ранее описанными классами-агрегатами&nbsp;A, B,&nbsp;C и обеспечивают особый способ перебора содержащихся в них данных. Итератор&nbsp;A перебирает все <i>цифры</i> целочисленного поля data агрегата A <i>в обратном порядке</i> (знак числа игнорируется); для числа&nbsp;0 возвращается цифра 0 (это единственная ситуация, когда последним элементом набора является цифра&nbsp;0). Итератор&nbsp;B перебирает все <i>цифровые символы</i> строкового поля data агрегата B <i>в обратном порядке</i>. Итератор C перебирает все цифры всех элементов структуры data агрегата C, причем как сами элементы, так и их цифры должны перебираться <i>в обратном порядке</i>. Для итераторов&nbsp;B и&nbsp;C возможна ситуация, когда перебираемый набор является пустым (если строковое поле data не содержит цифровых символов или структура data не содержит ни одного элемента). Каждый конкретный итератор содержит поле aggr, которое является ссылкой на связанный с ним объект-агрегат; это поле инициализируется в конструкторе итератора с помощью соответствующего параметра. Кроме того, итераторы содержат вспомогательные поля, используемые при реализации методов First, Next, IsDone и CurrentItem. </p><p class="ptTaskContinue">Дано целое число&nbsp;N (&#8804;&nbsp;10) и N&nbsp;наборов элементов. Первый элемент каждого набора представляет собой символ &#34;A&#34;, &#34;B&#34; или &#34;C&#34;; он определяет тип создаваемого объекта-агрегата (A,&nbsp;B или&nbsp;C). Следующие элементы каждого набора определяют поле data создаваемого агрегата: для агрегата&nbsp;A это одно целое число, для агрегата&nbsp;B&nbsp;&#8212; одна строка, для агрегата&nbsp;C&nbsp;&#8212; целое число&nbsp;K (&#8804;&nbsp;10), определяющее размер структуры данных data, и К&nbsp;целых чисел&nbsp;&#8212; элементов этой структуры (число K может быть равно&nbsp;0). </p><p class="ptTaskContinue">Описать структуру (например, массив) из N&nbsp;элементов-ссылок типа Aggregate, сохранить в ней исходные объекты-агрегаты и выполнить обработку этих объектов, перебирая их <i>в обратном порядке</i>. Для каждого объекта-агрегата требуется вывести сумму цифр, возвращаемых его итератором (или&nbsp;0, если итератор ничего не возвращает), а затем&nbsp;&#8212; сами цифры, возвращаемые его итератором. </p><p class="ptTaskContinue"><span class="ptSpecial">Примечание</span>. В языках с С-подобным синтаксисом для перебора элементов с применением итератора it, имеющего описанный выше набор методов, можно использовать следующий вариант цикла for: <tt>for (it.First(); !it.IsDone(); it.Next()) &lt;обработка it.CurrentItem()&gt;</tt> </p><pre class="pt">public abstract class Aggregate
{
    public abstract Iterator CreateIterator();
}

// Implement the ConcreteAggregateA, ConcreteAggregateB
//   and ConcreteAggregateC descendant classes

public abstract class Iterator
{
    public abstract void First();
    public abstract void Next();
    public abstract bool IsDone();
    public abstract int CurrentItem();
}

// Implement the ConcreteIteratorA, ConcreteIteratorB
//   and ConcreteIteratorC descendant classes</pre>
<h2>Observer, Strategy, Template Method</h2>
<p class="ptTask"><span class="ptSpecial">OOP3Behav4°</span>. <b>Strategy</b> (<b>Стратегия</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 2</span>. Реализовать иерархию классов-<i>валидаторов</i>, включающую класс Validator и его классы-потомки EmptyValidator, NumberValidator и RangeValidator. Классы-валидаторы предназначены для проверки правильности введенных строковых данных. Классы Validator, EmptyValidator и NumberValidator не имеют полей, их конструкторы не имеют параметров и не выполняют дополнительных действий. В классе Validator определен метод Validate(s), имеющий строковый параметр s и возвращающий строку с описанием ошибки, обнаруженной в строке s. Метод Validate класса Validator всегда возвращает пустую строку; таким образом, класс Validator считает допустимой любую строку. </p><p class="ptTaskContinue">Для класса EmptyValidator метод Validate(s) возвращает пустую строку, если параметр s не является пустой строкой; в противном случае он возвращает строку &#34;!Empty text&#34;. </p><p class="ptTaskContinue">Для класса NumberValidator метод Validate(s) возвращает пустую строку, если параметр s содержит строковое представление некоторого целого числа; в противном случае он возвращает строку вида &#34;!'&lt;s&gt;': not a number&#34;, где в позиции &lt;s&gt; указывается содержимое параметра&nbsp;s. </p><p class="ptTaskContinue">Класс RangeValidator содержит целочисленные поля min и max; его конструктор имеет целочисленные параметры a и b, инициализирующие поля таким образом, чтобы поле min было равно минимальному из чисел a и b, а поле max&nbsp;&#8212; максимальному из этих чисел. Для класса RangeValidator метод Validate(s) возвращает пустую строку, если параметр s содержит строковое представление некоторого целого числа и при этом данное число лежит в диапазоне от min до max включительно; в противном случае метод возвращает строку вида &#34;!'&lt;s&gt;': not in range &lt;min&gt;..&lt;max&gt;&#34;, где в позиции &lt;s&gt; указывается содержимое параметра s, а в позициях &lt;min&gt; и &lt;max&gt;&nbsp;&#8212; значения соответствующих полей. </p><p class="ptTaskContinue">Реализовать класс TextBox, содержащий строковое поле text и поле v&nbsp;&#8212; ссылку на объект типа Validator. Конструктор класса не имеет параметров, в нем создается объект типа Validator и ссылка на него присваивается полю v, а поле text инициализируется пустой строкой. Класс TextBox включает три метода: SetText(text)&nbsp;&#8212; задает или изменяет поле text; SetValidator(v)&nbsp;&#8212; изменяет поле v; Validate (без параметров)&nbsp;&#8212; вызывает для объекта v метод Validate с параметром text и возвращает значение, возвращенное этим методом. </p><p class="ptTaskContinue">Также реализовать класс TextForm. Он содержит набор tb элементов типа TextBox (можно использовать массив или другую структуру данных). Конструктор класса TextForm имеет параметр n, определяющий размер набора tb (можно считать, что параметр n не превосходит&nbsp;10); в конструкторе создаются все элементы набора tb. Класс TextForm включает три метода: SetText(ind, text)&nbsp;&#8212; задает или изменяет поле text для элемента набора tb с индексом ind; SetValidator(ind, v)&nbsp;&#8212; изменяет поле&nbsp;v для элемента набора tb с индексом ind; Validate (без параметров)&nbsp;&#8212; последовательно вызывает методы Validate для всех элементов набора tb и возвращает строку, полученную объединением строк, возвращенных этими методами. При реализации методов SetText и SetValidator можно считать, что параметр ind всегда лежит в допустимом диапазоне (от&nbsp;0 до n&nbsp;&#8722;&nbsp;1, где n&nbsp;&#8212; размер набора&nbsp;tb). </p><p class="ptTaskContinue">Даны три целых числа&nbsp;N, A,&nbsp;B, причем&nbsp;N лежит в диапазоне от&nbsp;1 до&nbsp;10. Также дано целое число&nbsp;K, не превосходящее&nbsp;N, и набор из K пар (ind, val), где ind является целым числом в диапазоне от&nbsp;0 до N&nbsp;&#8722;&nbsp;1, а val является одним из символов &#34;E&#34;, &#34;N&#34;, &#34;R&#34;. Все значения ind являются различными. Кроме того, дано пять наборов строк, каждый из которых содержит по N элементов. </p><p class="ptTaskContinue">Создать объект tf типа TextForm, вызвав его конструктор с параметром&nbsp;N. Для каждой пары (ind, val) вызвать метод SetValidator объекта tf с первым параметром ind и вторым параметром&nbsp;&#8212; ссылкой на объект-валидатор, тип которого соответствует символу val: &#34;E&#34;&nbsp;&#8212; EmptyValidator, &#34;N&#34;&nbsp;&#8212; NumberValidator, &#34;R&#34;&nbsp;&#8212; RangeValidator; для объекта RangeValidator использовать конструктор с параметрами&nbsp;A и&nbsp;B, где&nbsp;A и&nbsp;B&nbsp;&#8212; ранее указанные числа. Для каждого из пяти данных наборов строк выполнить следующие действия: добавить набор строк в объект tf (вызвав требуемое число раз метод SetText объекта tf) и проверить правильность этого набора строк (вызвав метод Validate объекта tf и выведя его результат). </p><pre class="pt">public class Validator
{
    public virtual string Validate(string s)
    {
        return &quot;&quot;;
    }
}

// Implement the EmptyValidator, NumberValidator
//   and RangeValidator descendant classes

// Implement the TextBox and TextForm classes</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav5°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPTemplateMethod.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPTemplateMethod.png" border=1></p><p class="ptTaskContinue"><b>Template Method</b> (<b>Шаблонный метод</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: средняя. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: определяет основу алгоритма и позволяет подклассам определить (или переопределить) некоторые шаги алгоритма, не изменяя его структуру в целом. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>AbstractClass</i> (<i>Абстрактный класс</i>)&nbsp;&#8212; определяет абстрактные примитивные операции, замещаемые в конкретных подклассах для реализации шагов алгоритма; реализует шаблонный метод, определяющий последовательность действий алгоритма (шаблонный метод вызывает примитивные операции, а также операции, определенные в классе AbstractClass или в других объектах); </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteClass</i> (<i>Конкретный класс</i>)&nbsp;&#8212; реализует примитивные операции, выполняющие шаги алгоритма способом, который зависит от подкласса. </p><p class="ptTaskContinue">Помимо абстрактных примитивных операций шаблонного метода, которые <i>необходимо</i> переопределить в конкретных классах, шаблонный метод может включать операции-<i>перехватчики</i> (hooks), которые могут быть переопределены в конкретных класса, а могут быть оставлены без изменения. Использование шаблонного метода позволяет избавиться от избыточного кода в подклассах. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать иерархию классов, связанную с формированием рецептов приготовления напитков и включающую абстрактный класс AbstractClass и четыре его потомка: ConcreteClass1, ConcreteClass2 (непосредственные потомки абстрактного класса), ConcreteClass3 (потомок ConcreteClass1) и ConcreteClass4 (потомок ConcreteClass2). В абстрактном классе реализовать шаблонный метод TemplateMethod, формирующий и возвращающий строковое значение. Это значение получается путем последовательного добавления к результирующей строке значений, возвращаемых методами BasicOperation1, PrimitiveOperation, BasicOperation2 и HookOperation. Метод PrimitiveOperation является абстрактным методом, остальные методы имеют реализацию: метод BasicOperation1 возвращает строку &#34;Boil water&#34; (вскипятить воду), метод BasicOperation2 возвращает строку &#34;=Pour into a cup&#34; (налить в чашку), метод HookOperation возвращает пустую строку, причем данный метод является защищенным. </p><p class="ptTaskContinue">В классе ConcreteClass1 реализовать метод PrimitiveOperation, возвращающий строку &#34;=Brew tea&#34; (заварить чай), в классе ConcreteClass2 реализовать этот же метод, возвращающий строку &#34;=Brew coffee&#34; (заварить кофе). В классе ConcreteClass3 переопределить метод HookOperation таким образом, чтобы он возвращал строку &#34;=Add sugar and lemon&#34; (добавить сахар и лимон), в классе ConcreteClass4 переопределить этот же метод так, чтобы он возвращал строку &#34;=Add sugar and milk&#34; (добавить сахар и молоко). Конструкторы всех конкретных классов не имеют параметров и не выполняют дополнительных действий. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;10) и набор из N целых чисел, принимающих значения от&nbsp;1 до&nbsp;4. Создать структуру (например, массив) из N элементов-ссылок типа AbstractClass и инициализировать ее элементы экземплярами конкретных классов в зависимости от значений соответствующих чисел исходного набора (если число равно&nbsp;1, то создается экземпляр класса ConcreteClass1, если число равно&nbsp;2, то создается экземпляр класса ConcreteClass2 и т.&nbsp;д.). Перебирая элементы созданной структуры <i>в обратном порядке</i>, вызвать для каждого из них метод TemplateMethod и вывести возвращенную им строку. </p><pre class="pt">public abstract class AbstractClass
{
    public abstract string PrimitiveOperation();
    // Implement methods TemplateMethod,
    // BasicOperation1, BasicOperation2 and HookOperation
}

// Implement the ConcreteClass1, ConcreteClass2, ConcreteClass3
//   and ConcreteClass4 descendant classes</pre>
<h2>Iterator, Command, State</h2>
<p class="ptTask"><span class="ptSpecial">OOP3Behav8°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPCommand.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPCommand.png" border=1></p><p class="ptTaskContinue"><b>Command</b> (<b>Команда</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue">Известен также под именем <b>Action</b> (<b>Действие</b>), <b>Transaction</b> (<b>Транзакция</b>). </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: выше средней. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: инкапсулирует запрос (действие, операцию) как объект, позволяя тем самым задавать параметры клиентов для обработки соответствующих запросов, ставить запросы в очередь или протоколировать их, а также поддерживать отмену операций. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Command</i> (<i>Команда</i>)&nbsp;&#8212; объявляет интерфейс для выполнения запроса; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteCommand</i> (<i>Конкретная команда</i>)&nbsp;&#8212; определяет связь между объектом-получателем Receiver и требуемым запросом; реализует метод Execute путем вызова требуемых методов объекта Receiver; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Client</i> (<i>Клиент</i>)&nbsp;&#8212; создает объект класса ConcreteCommand и задает его получателя; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Invoker</i> (<i>Инициатор</i>)&nbsp;&#8212; обращается к команде для выполнения запроса; не использует никакой информации о конкретном получателе запроса; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Receiver</i> (<i>Получатель</i>)&nbsp;&#8212; располагает информацией об операциях, необходимых для выполнения запроса; в роли получателя может выступать любой класс. </p><p class="ptTaskContinue">Основной особенностью паттерна Command является то, что он отделяет объект-инициатор Invoker, выдающий запросы, от объекта-получателя Receiver, который умеет эти запросы выполнять. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать классы, связанные с организацией запросов на основе паттерна Command. Иерархия классов-<i>команд</i> включает абстрактный класс Command с абстрактным методом Execute (который не имеет параметров и ничего не возвращает) и классы ConcreteCommandA и ConcreteCommandB, связанные с конкретными командами A и B. Классы ConcreteCommandA и ConcreteCommandB включают поле recv, определяющее получателя соответствующей команды; это поле является ссылкой на объект класса ReceiverA для команды A и ссылкой на объект класса ReceiverB для команды B; поле recv определяется в конструкторе конкретной команды, имеющем параметр recv соответствующего типа. Метод Execute конкретной команды A вызывает метод ActionA для объекта recv (типа ReceiverA), метод Execute конкретной команды B вызывает метод ActionB для объекта recv (типа ReceiverB). </p><p class="ptTaskContinue">Классы-<i>получатели</i> ReceiverA и ReceiverB содержат поле cli&nbsp;&#8212; ссылку на объект класса Client и поле info строкового типа; эти поля инициализируются в конструкторе, имеющем одноименные параметры cli и info. Метод ActionA класса ReceiverA вызывает метод AddLeft(info) объекта cli; метод ActionB класса ReceiverB вызывает метод AllRight(info) объекта cli. Следует подчеркнуть, что классы-получатели не входят в какую-либо особую иерархию, и каждый из них реализует свой собственный набор методов. </p><p class="ptTaskContinue">Класс-<i>клиент</i> Client содержит строковое поле info, которое инициализируется пустой строкой в конструкторе (конструктор не имеет параметров). Класс Client также содержит три метода: AddLeft(newInfo), AddRight(newInfo) и GetInfo. Методы AddLeft и AddRight имеют строковый параметр newInfo и добавляют строку newInfo соответственно в начало и конец поля info; эти методы ничего не возвращают. Метод GetInfo без параметров возвращает значение поля info. </p><p class="ptTaskContinue">Класс-<i>инициатор</i> Invoker предназначен для выполнения связанной с ним команды. Он содержит поле cmd&nbsp;&#8212; ссылку на объект типа Command, которая инициализируется в конструкторе с одноименным параметром cmd, а также метод Invoke, в котором выполняется вызов метода Execute команды cmd. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;10), задающее количество различных команд, и набор S из N различных строк, каждая из которых начинается либо с символа &#34;A&#34;, либо с символа &#34;B&#34;. Создать объект cli типа Client и набор cmd из N команд (например, массив) с элементами-ссылками типа Command. Каждый элемент набора cmd является либо командой ConcreteCommandA (если соответствующая строка набора S начинается с символа &#34;A&#34;), либо командой ConcreteCommandB (если соответствующая строка набора S начинается с символа &#34;B&#34;); при создании команд A и B используются объекты типа ReceiverA или ReceiverB соответственно, которые, в свою очередь, создаются с помощью конструкторов, имеющих  следующие параметры: ранее созданный объект cli типа Client и соответствующая строка из набора S. Например, если очередной строкой набора S является строка &#34;Apqr&#34;, то соответствующим элементом набора cmd должен быть объект ConcreteCommandA, причем его конструктору должен передаваться объект ReceiverA, в конструкторе которого указываются параметры cli и &#34;Apqr&#34;. </p><p class="ptTaskContinue">Также дано целое число K (&#8804;&nbsp;30), задающее количество различных инициаторов (объектов типа Invoker), и набор из K целых чисел со значениями из диапазона от 0 до N&nbsp;&#8722;&nbsp;1 (каждый элемент набора определяет <i>индекс</i> некоторой команды из набора cmd). Создать набор inv из K инициаторов (например, массив) с элементами-ссылками типа Invoker и инициализировать каждого инициатора командой с соответствующим индексом из набора cmd (например, если начальным элементом набора из K целых чисел является число 5, то начальный инициатор inv[0] должен инициализироваться командой cmd[5]). Несколько инициаторов может быть связано с одной и той же командой (что является стандартной ситуацией при организации пользовательского интерфейса, когда одну и ту же команду можно выполнить, например, с помощью пункта меню, кнопки быстрого доступа или горячей клавиши). </p><p class="ptTaskContinue">Наконец, дано целое число M (&#8804;&nbsp;20), задающее количество команд для выполнения, и набор из M целых чисел со значениями из диапазона от 0 до K&nbsp;&#8722;&nbsp;1 (каждый элемент набора определяет <i>индекс</i> того инициатора из набора inv, который должен использоваться для выполнения требуемой команды). Выполнить требуемые команды, вызвав метод Invoke для элементов набора inv с указанными индексами. После выполнения каждой команды выводить текущее состояние объекта cli, используя его метод GetInfo. </p><pre class="pt">// Implement the Client, ReceiverA and ReceiverB classes

public abstract class Command
{
    public abstract void Execute();
}

// Implement the ConcreteCommandA
//   and ConcreteCommandB descendant classes

public class Invoker
{
    Command cmd;
    public Invoker(Command cmd)
    {
        this.cmd = cmd;
    }
    public void Invoke()
    {
        cmd.Execute();
    }
}</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav10°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPState.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPState.png" border=1></p><p class="ptTaskContinue"><b>State</b> (<b>Состояние</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: средняя. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: позволяет объекту варьировать свое поведение в зависимости от внутреннего состояния, которое определяется одним из нескольких объектов, связанных с конкретными состояниями и имеющими одинаковый интерфейс. Извне создается впечатление, что изменился класс объекта. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Context</i> (<i>Контекст</i>)&nbsp;&#8212; определяет интерфейс, представляющий интерес для клиентов; хранит экземпляр подкласса ConcreteState, которым определяется текущее состояние; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>State</i> (<i>Состояние</i>)&nbsp;&#8212; определяет интерфейс для инкапсуляции поведения, ассоциированного с конкретным состоянием контекста Context; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteStateA</i>, <i>ConcreteStateB</i> (<i>Конкретные состояния</i>)&nbsp;&#8212; реализуют поведение, ассоциированное с некоторым состоянием контекста Context. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать набор классов, связанных с разбором текста на основе паттерна State. Предполагается, что обрабатываемый текст включает обычное содержимое (токен Normal), строковые литералы, заключенные в двойные кавычки (токен String), и комментарии, заключенные в фигурные скобки (токен Comm). Фигурные скобки в строковых литералах считаются обычными символами, как и двойные кавычки в комментариях. Если в строковом литерале встречаются две двойных кавычки подряд, то они рассматриваются как обычный символ &#34;двойная кавычка&#34;, входящий в строковый литерал. Комментарии не являются вложенными; открывающая фигурная скобка внутри комментария рассматривается как обычный символ. </p><p class="ptTaskContinue">Признаком конца разбираемого текста является наличие точки, которая не считается входящей в сам текст. В токены String не включаются обрамляющие кавычки, в токены Comm не включаются обрамляющие фигурные скобки. Если последний строковый литерал или комментарий не заканчивается требуемым символом (кавычкой или фигурной скобкой соответственно), то подобный фрагмент текста считается <i>ошибочным токеном</i> ErrString или ErrComm соответственно; такой токен должен содержать символы от начала строкового литерала или комментария вплоть до завершающей точки (не включая эту точку). </p><p class="ptTaskContinue">Любые виды токенов могут быть пустыми; в начале и конце текста, а также между специальными токенами String и Comm обязательно присутствует токен Normal (возможно, пустой). Исключением являются ошибочные токены ErrString и ErrComm, после которых разбор текста завершается. </p><p class="ptTaskContinue">Иерархия классов-<i>состояний</i> включает абстрактный класс State с абстрактным методом GetNextToken (не имеет параметров, возвращает строку с описанием очередного токена разбираемого текста) и классы ConcreteStateNormal, ConcreteStateString, ConcreteStateComm и ConcreteStateFinal. Каждый конкретный класс, кроме класса ConcreteStateFinal, содержит поле ct&nbsp;&#8212; ссылку на объект Context&nbsp;&#8212; и поле index целого типа, которые инициализируются в конструкторе с использованием соответствующих параметров. Поле ct определяет объект, содержащий разбираемый текст, а поле index определяет индекс позиции, начиная с которой требуется продолжить разбор текста. </p><p class="ptTaskContinue">Метод GetNextToken возвращает строку, содержащую полученный токен (возможно, пустой), перед которым указывается его тип и двоеточие (например, &#34;Normal:abc&#34;, &#34;ErrString:mn2&#34;, &#34;Comm:&#34;). Класс ConcreteStateFinal не содержит полей, его конструктор не выполняет дополнительных действий, а метод GetNextToken всегда возвращает пустую строку. После определения текущего токена Normal метод GetNextToken класса ConcreteStateNormal вызывает метод SetState контекста ct, указывая в качестве параметра экземпляр класса ConcreteStateString (если обнаружен символ &#34;двойная кавычка&#34;), ConcreteStateComm (если обнаружен символ &#34;{&#34;) или ConcreteStateFinal (если обнаружен символ &#34;точка&#34;). После определения текущего <i>правильного</i> токена String или Comm метод GetNextToken классов ConcreteStateString и ConcreteStateComm вызывает метод SetState контекста ct, указывая в качестве параметра экземпляр класса ConcreteStateNormal. После определения <i>ошибочного</i> токена ErrString или ErrComm метод GetNextToken классов ConcreteStateString и ConcreteStateComm вызывает метод SetState контекста ct с экземпляром класса ConcreteStateFinal. </p><p class="ptTaskContinue">Класс-<i>контекст</i> Context содержит строковое поле text с разбираемым текстом и поле-ссылку currentState типа State. Конструктор класса имеет параметр text, используемый для инициализации поля text; поле currentState инициализируется объектом типа ConcreteStateNormal. Класс Context имеет методы GetCharAt(index), SetState(newState) и GetNextToken. Метод GetCharAt возвращает символ поля text с индексом index (предполагается, что индекс находится в допустимом диапазоне); метод SetState изменяет поле currentState, присваивая ему значение параметра newState (этот метод, наряду с методом GetCharAt, используется в методах классов-состояний); метод GetNextToken возвращает очередной токен разбираемого текста, вызывая одноименный метод объекта currentState. </p><p class="ptTaskContinue">Дана строка, которая оканчивается точкой. Используя объект ct типа Context, выполнить разбор данной строки, вызывая метод GetNextToken объекта ct и выводя его возвращаемый результат, пока очередной вызов не вернет пустую строку (пустую строку выводить не следует). </p><pre class="pt">public abstract class State
{
    public abstract string GetNextToken();
}

// Implement the ConcreteStateNormal, ConcreteStateString,
//   ConcreteStateComm and ConcreteStateFin descendant classes

// Implement the Context class</pre>
<h2>Mediator, Chain of&nbsp;Responsibility, Visitor, Interpreter</h2>
<p class="ptTask"><span class="ptSpecial">OOP3Behav15°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPVisitor.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPVisitor.png" border=1></p><p class="ptTaskContinue"><b>Visitor</b> (<b>Посетитель</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: низкая. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: описывает операцию, выполняемую с каждым объектом из некоторой структуры. Паттерн Visitor позволяет определить новую операцию, не изменяя классы этих объектов и используя различные варианты операции для объектов различных типов, входящих в одну структуру. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Visitor</i> (<i>Посетитель</i>)&nbsp;&#8212; объявляет группу методов Visit, в которой для каждого класса ConcreteElement в структуре объектов предусмотрен свой метод; имя метода (например, VisitConcreteElementA) и его параметр идентифицируют объект, который вызывает данный метод для отправки посетителю соответствующего запроса (это позволяет посетителю определить, элемент какого конкретного класса он посещает, и обращаться к элементу напрямую через его интерфейс); </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteVisitor1</i>, <i>ConcreteVisitor2</i> (<i>Конкретные посетители</i>)&nbsp;&#8212; реализуют все операции, объявленные в классе Visitor и связанные с обработкой объектов различных типов, содержащихся в обрабатываемой структуре; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Element</i> (<i>Элемент</i>)&nbsp;&#8212; определяет метод Accept, который принимает посетителя в качестве аргумента; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteElementA</i>, <i>ConcreteElementB</i> (<i>Конкретные</i> <i>элементы</i>)&nbsp;&#8212; реализуют метод Accept, принимающий посетителя как аргумент (как правило, в этом методе происходит вызов того метода из группы методов Visit указанного посетителя, который соответствует данному конкретному элементу); </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ObjectStructure</i> (<i>Структура объектов</i>)&nbsp;&#8212; может перечислять свои элементы, а также предоставлять посетителю высокоуровневый интерфейс для посещения своих элементов. </p><p class="ptTaskContinue">Совместное использование методов Accept и группы методов Visit в паттерне Visitor обеспечивает <i>двойную диспетчеризацию</i> запросов, при которой характер запроса определяется двумя объектами: конкретным посетителем и конкретным элементом. Двойная диспетчеризация позволяет посетителю по-разному обрабатывать элементы различных классов. </p><p class="ptTaskContinue">Применение паттерна Visitor оправдано, если иерархия классов-элементов является стабильной (т.&nbsp;е. в нее редко добавляются новые классы) и при этом часто возникает необходимость в новых операциях, которые требуется по-разному выполнять для элементов различных типов. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать две иерархии классов, связанные с применением паттерна Visitor. Первая иерархия является иерархией классов-<i>элементов</i> и включает абстрактный класс Element, содержащий абстрактный метод Accept с параметром-ссылкой типа Visitor (не возвращает результата), и конкретные классы ConcreteElementA, ConcreteElementB, ConcreteElementC. Каждый конкретный класс содержит поле data; для класса ConcreteElementA оно целочисленное, для класса ConcreteElementB оно строковое, для класса ConcreteElementC оно является вещественным числом. Поле data инициализируется в конструкторе класса с помощью параметра data того же типа, что и инициализируемое поле. Конкретные классы-элементы&nbsp;A,&nbsp;B и&nbsp;C реализуют метод Accept(v), в котором для параметра&nbsp;v типа Visitor выполняется вызов соответствующего метода класса Visitor, определяемого типом класса-элемента: для элемента&nbsp;A это VisitConcreteElementA, для элемента&nbsp;B&nbsp;&#8212; VisitConcreteElementB, для элемента C&nbsp;&#8212; VisitConcreteElementC (параметром методов Visit является ссылка на объект, вызвавший метод Accept). </p><p class="ptTaskContinue">Кроме того, классы-элементы имеют методы для доступа на чтение и запись к полю data: метод GetData без параметров возвращает значение поля data, метод SetData с параметром newData изменяет значение поля data на значение параметра newData. Следует подчеркнуть, что методы GetData и SetData являются <i>специфическими</i> для каждого конкретного класса-элемента (в данном случае это аналоги специфических методов OperationA и OperationB, приведенных на диаграмме классов). </p><p class="ptTaskContinue">С иерархией классов-элементов также связан класс ObjectStructure. Поле struc этого класса является структурой (например, массивом) с элементами-ссылками на объекты типа Element (можно считать, что число элементов структуры struc не превосходит&nbsp;10). Поле struc инициализируется в конструкторе с помощью параметра struc того же типа. Класс ObjectStructure содержит метод Accept(v) с параметром-ссылкой типа Visitor. Этот метод перебирает все элементы структуры struc и для каждого элемента вызывает его метод Accept с параметром v. </p><p class="ptTaskContinue">Вторая иерархия является иерархией классов-<i>посетителей</i>, связанных с ранее описанными конкретными классами. Она включает абстрактный класс Visitor и конкретные классы ConcreteVisitor1, ConcreteVisitor2 и ConcreteVisitor3. Класс Visitor содержит три абстрактных метода: VisitConcreteElementA(e), VisitConcreteElementB(e), VisitConcreteElementC(e). Эти методы не возвращают значений; их параметрами являются ссылки на соответствующие объекты-элементы (например, VisitConcreteElementA имеет параметр типа ConcreteElementA). Напомним, что именно эти методы должны вызываться в методе Accept каждого конкретного класса-элемента. </p><p class="ptTaskContinue">Конкретные классы-посетители&nbsp;1, 2,&nbsp;3 реализуют различные наборы операций, связанных с классами-элементами&nbsp;A, B,&nbsp;C, определяя методы VisitConcreteElementA(e), VisitConcreteElementB(e), VisitConcreteElementC(e). Класс ConcreteVisitor1 обеспечивает <i>вывод</i> поля data в окно задачника, вызывая в каждом из указанных методов соответствующую команду вывода для значения GetData элемента&nbsp;e. Класс ConcreteVisitor2 <i>преобразует</i> поле data различным образом для разных классов-элементов, используя метод SetData элемента&nbsp;e: для элементов типа&nbsp;A он изменяет знак целого числа data на противоположный, для элементов типа&nbsp;B он изменяет порядок следования символов строки data на противоположный, для элементов типа&nbsp;C он изменяет любое ненулевое вещественное число data на обратное к нему (равное 1/data). Класс ConcreteVisitor3 определяет некоторую <i>общую характеристику</i> для всех однотипных элементов обрабатываемой структуры: для элементов типа&nbsp;A определяется сумма их целочисленных полей data, для элементов типа&nbsp;B находится строка, получаемая сцеплением всех строковых полей data, для элементов типа&nbsp;C находится произведение вещественных полей data. Для хранения полученных характеристик надо использовать в классе ConcreteVisitor3 поля resultA, resultB, resultC, а для доступа к ним&nbsp;&#8212; методы GetResultA, GetResultB, GetResultC. Конструкторы объектов-посетителей не имеют параметров и не выполняют дополнительных действий. </p><p class="ptTaskContinue">Дано целое число&nbsp;N (&#8804;&nbsp;10) и N&nbsp;пар значений. Первое значение каждой пары представляет собой символ &#34;A&#34;, &#34;B&#34; или &#34;C&#34;; он определяет тип создаваемого объекта-элемента (A,&nbsp;B или&nbsp;C). Второе значение каждой пары определяет поле data создаваемого элемента: для элемента типа&nbsp;A это целое число, для элемента типа&nbsp;B&nbsp;&#8212; строка, для элемента типа&nbsp;C&nbsp;&#8212; вещественное число. </p><p class="ptTaskContinue">Создать объект&nbsp;s типа ObjectStructure и поместить в него все исходные элементы. Также создать три объекта-посетителя&nbsp;v1, v2,&nbsp;v3 типа ConcreteVisitor1, ConcreteVisitor2, ConcreteVisitor3 соответственно. Вывести содержимое структуры&nbsp;s, используя вызов ее метода Accept(v1), после чего преобразовать это содержимое, используя вызов Accept(v2), и вывести преобразованное содержимое с помощью еще одного вызова Accept(v1). Затем вызвать метод Accept(v3) и вывести найденные в нем характеристики элементов структуры&nbsp;s с помощью методов GetResultA, GetResultB и GetResultC объекта&nbsp;v3. </p><pre class="pt">public abstract class Element
{
    public abstract void Accept(Visitor v);
}

public class ConcreteElementA : Element
{
    // Add required fields and methods
    public override void Accept(Visitor v)
    {
        // Implement the method
    }
}

public class ConcreteElementB : Element
{
    // Add required fields and methods
    public override void Accept(Visitor v)
    {
        // Implement the method
    }
}

public class ConcreteElementC : Element
{
    // Add required fields and methods
    public override void Accept(Visitor v)
    {
        // Implement the method
    }
}

public class ObjectStructure
{
    Element[] struc;
    public ObjectStructure(Element[] struc)
    {
        // Implement the constructor
    }
    public void Accept(Visitor v)
    {
        foreach (var e in struc)
            e.Accept(v);
    }
}

public abstract class Visitor
{
    public abstract void VisitConcreteElementA(ConcreteElementA e);
    public abstract void VisitConcreteElementB(ConcreteElementB e);
    public abstract void VisitConcreteElementC(ConcreteElementC e);
}

// Implement the ConcreteVisitor1, ConcreteVisitor2
//   and ConcreteVisitor3 descendant classes</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav14°</span>. <b>Chain of Responsibility</b> (<b>Цепочка обязанностей</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue">В данном задании рассматривается вариант иерархии классов обработчиков, в которой базовый класс обеспечивает в методе HandleRequest всю необходимую функциональность для передачи запроса по цепочке обработчиков, а подклассы расширяют эту функциональность. Кроме того, в задании рассматривается вариант представления запросов в виде иерархии классов, инкапсулирующих параметры запроса. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 2</span>. Реализовать две иерархии классов, связанные с применением паттерна Chain of Responsibility. Первая иерархия является иерархией классов-<i>запросов</i> и включает абстрактный класс Request и два конкретных класса RequestA и RequestB. Класс Request содержит абстрактный метод ToStr без параметров, возвращающий строковое описание запроса. В классах RequestA и RequestB определено поле param, задающее параметр запроса, причем для класса A параметр является целочисленным, а для класса B&nbsp;&#8212; строковым. Поле param инициализируется в конструкторе с помощью одноименного параметра конструктора. Также в этих классах определен метод GetParam, возвращающий значение поля param, и метод ToStr, возвращающий описание запроса, включающее тип запроса (букву &#34;A&#34; или &#34;B&#34;), двоеточие и параметр запроса (целое число для запроса A и строку для запроса B), например, &#34;A:34&#34;, &#34;B:sm&#34;. </p><p class="ptTaskContinue">Вторая иерархия является иерархией классов-<i>обработчиков</i> и включает конкретный базовый класс Handler и классы-потомки HandlerA и HandlerB. Класс Handler содержит поле successor (ссылку на объект Handler) и метод HandleRequest(req) (не возвращает значений, имеет параметр-ссылку req типа Request, определяющий вид запроса). Метод HandleRequest работает следующим образом: если поле successor не является пустой ссылкой, то вызывается метод HandleRequest(req) для объекта successor, в противном случае выводится текст &#34;Request &lt;req&gt; not processed&#34; (запрос &lt;req&gt; не обработан), где на позиции &lt;req&gt; указывается значение, возвращаемое методом ToStr параметра req. Класс Handler имеет конструктор с параметром-ссылкой successor типа Handler, который инициализирует одноименное поле. Таким образом, данный класс обеспечивает всю необходимую функциональность для организации цепочки обработчиков. </p><p class="ptTaskContinue">Классы HandlerA и HandlerB предназначены для обработки запросов соответствующего типа (A или B) и имеют целочисленное поле id (идентификатор обработчика) и поля param1 и param2 (определяют диапазон параметров запросов, которые может обработать данный обработчик). Тип полей param1 и param2 соответствует типу параметра обрабатываемого запроса: для класса HandlerA это целый тип, для класса HandlerB&nbsp;&#8212; строковый. Конструктор классов HandlerA и HandlerB имеет четыре параметра: successor типа ссылки на Handler, id целого типа, param1 и param2 типа, соответствующего типу одноименных полей. В конструкторе вызывается конструктор базового класса с параметром successor и инициализируются поля id, param1 и param2. </p><p class="ptTaskContinue">Метод HandleRequest(req) классов HandlerA и HandlerB выполняет следующие действия. Вначале проверяется <i>тип времени выполнения</i> параметра req, и в случае, если этот тип соответствует типу обрабатываемого запроса (RequestA для HandlerA, RequestB для HandlerB), проверяется, лежит ли параметр param запроса req в диапазоне от param1 до param2 (строковые параметры для запроса RequestB сравниваются лексикографически). Если обе проверки являются успешными, то запрос обрабатывается путем вывода текста &#34;Request &lt;req&gt; processed by handler &lt;id&gt;&#34; (запрос &lt;req&gt; обработан обработчиком &lt;id&gt;), где на позиции &lt;req&gt; указывается значение, возвращаемое методом ToStr объекта req, а на позиции &lt;id&gt; указывается значение поля id обработчика. В противном случае выполняется вызов метода HandleRequest(req) базового класса (в котором либо происходит переход к следующему обработчику в цепочке, либо, при его отсутствии, выводится сообщение о невозможности обработать запрос). </p><p class="ptTaskContinue">Вспомогательный класс Client содержит поле h&nbsp;&#8212; ссылку типа Handler на обработчик, являющийся первым в ранее сформированной цепочке обработчиков. Поле h инициализируется в конструкторе с помощью одноименного параметра. Класс Client также содержит метод SendRequest(req), имеющий параметр-ссылку типа Request и не возвращающий значения; в этом методе выполняется вызов метода HandleRequest(req) для объекта&nbsp;h. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;10) и N троек элементов. В каждой тройке первый элемент является символом &#34;A&#34; или &#34;B&#34;, а тип остальных двух элементов (p1,&nbsp;p2) зависит от символа: в случае символа &#34;A&#34; это целые числа, а в случае &#34;B&#34;&nbsp;&#8212; строки. В любом случае выполняется неравенство p1&nbsp;&#8804;&nbsp;p2, где для чисел используется обычное сравнение, а для строк&nbsp;&#8212; лексикографическое. Используя переменную h&nbsp;&#8212; ссылку на объект Handler, последовательно создать один объект типа Handler (передав ему в качестве параметра пустую ссылку) и N объектов типа HandlerA или HandlerB (тип определяется первым элементом соответствующей тройки). Ссылки на создаваемые объекты записываются в одну и ту же переменную&nbsp;h; параметрами конструктора для объектов HandlerA и HandlerB должны быть значения&nbsp;h,&nbsp;i, p1,&nbsp;p2, где i&nbsp;&#8212; индекс очередной тройки из исходного набора (тройки индексируются от&nbsp;0), а p1 и p2&nbsp;&#8212; второй и третий элемент этой тройки. В результате будет создана цепочка из N&nbsp;+&nbsp;1 обработчика, причем первым элементом этой цепочки (ссылка на который будет храниться в переменной&nbsp;h) будет обработчик типа HandlerA или HandlerB с идентификатором N&nbsp;&#8722;&nbsp;1, предпоследним&nbsp;&#8212; обработчик типа HandlerA или HandlerB с идентификатором&nbsp;0, а последним&nbsp;&#8212; обработчик типа Handler (не имеющий идентификатора). Создать объект cli типа Client, указав в качестве параметра его конструктора значение ссылки h. </p><p class="ptTaskContinue">Также дано целое число K (&#8804;&nbsp;20) и набор из K&nbsp;различных запросов, определяемых парами элементов (c, p), где c&nbsp;&#8212; символ &#34;A&#34; или &#34;B&#34;, а p&nbsp;&#8212; параметр запроса (целочисленный в случае &#34;A&#34;, строковый в случае &#34;B&#34;). Для каждой пары создать запрос req соответствующего типа и выполнить вызов метода SendRequest(req) объекта cli. Выводить какие-либо результаты не требуется, так как вывод осуществляется в методах HandleRequest объектов-обработчиков. </p><pre class="pt">public abstract class Request
{
    public abstract string ToStr();
}

// Implement the RequestA and RequestB descendant classes

public class Handler
{
    Handler successor;
    public Handler(Handler successor)
    {
        this.successor = successor;
    }
    public virtual void HandleRequest(Request req)
    {
        // Implement the method
    }
}

// Implement the HandlerA and HandlerB descendant classes

public class Client
{
    Handler h;
    public Client(Handler h)
    {
        this.h = h;
    }
    public void SendRequest(Request req)
    {
        h.HandleRequest(req);
    }
}</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav17°</span>. <b>Interpreter</b> (<b>Интерпретатор</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 2</span>. Реализовать иерархию классов, которая определяет следующую грамматику строкового выражения: </p><p class="ptTaskCenter"><table align="center"><tr><td align=left>&lt;expr&gt;   <td align=center><tt>::=</tt> <td align=left>&lt;concat&gt; | &lt;if&gt; | &lt;loop&gt; | &lt;str&gt;        <tr><td align=left>&lt;concat&gt; <td align=center><tt>::=</tt> <td align=left>&lt;expr&gt;&lt;expr&gt; | &lt;concat&gt;&lt;expr&gt;          <tr><td align=left>&lt;if&gt;     <td align=center><tt>::=</tt> <td align=left>(var?&lt;expr&gt;:&lt;expr&gt;)                    <tr><td align=left>&lt;loop&gt;   <td align=center><tt>::=</tt> <td align=left>(var:&lt;expr&gt;)                           <tr><td align=left>&lt;str&gt;    <td align=center><tt>::=</tt> <td align=left>&lt;строка без символов &#34;(&#34;, &#34;)&#34;, &#34;?&#34;, &#34;:&#34;&gt;<tr><td align=left>&lt;var&gt;    <td align=center><tt>::=</tt> <td align=left>&lt;имя целочисленной переменной&gt;         </table></p><p class="ptTaskContinue"></p><p class="ptTaskContinue">Выражение concat возвращает конкатенацию нескольких выражений expr (двух или более); выражение if анализирует значение переменной var, и если var&nbsp;&#8800;&nbsp;0, то возвращает первое из указанных выражений expr, в противном случае возвращает второе из указанных выражений; выражение loop возвращает выражение expr, повторенное столько раз, каково значение переменной var (или пустую строку, если var&nbsp;&#8804;&nbsp;0). </p><p class="ptTaskContinue">Иерархия классов содержит абстрактный класс AbstractExpression, классы NontermConcat, NontermIf и NontermLoop, определяющие нетерминальные выражения concat, if, loop соответственно, и класс TermStr, определяющий терминальное выражение str. Класс AbstractExpression содержит два абстрактных метода InterpretA(cont) и InterpretB(cont), возвращающих строковое значение и определяющих два варианта интерпретации выражения (параметр-ссылка cont имеет тип Context, описываемый далее). В каждом конкретном классе (NontermConcat, NontermIf, NontermLoop и TermStr) требуется переопределить эти абстрактные методы. </p><p class="ptTaskContinue">Интерпретация A состоит в <i>восстановлении</i> строкового представления выражения, удовлетворяющего приведенной выше грамматике, по его синтаксическому дереву разбора; при этом имена переменных берутся из контекста (экземпляра класса Context). Интерпретация B состоит в <i>построении</i> конкретной строки по выражению, представленному синтаксическим деревом разбора; при этом значения переменных также берутся из контекста. </p><p class="ptTaskContinue">Примеры интерпретаций A и B для одного и того же синтаксического дерева разбора: строка &#34;abc(var1?(n:x):dd)yz&#34; и строка &#34;abcxxxxyz&#34; (при условии, что контекст содержит переменные var1&nbsp;=&nbsp;1 и n&nbsp;=&nbsp;4). </p><p class="ptTaskContinue">Класс Context должен содержать два набора элементов размера&nbsp;10: строковый набор names с именами доступных переменных и набор целых чисел values со значениями соответствующих переменных (для хранения наборов можно использовать массив или другую структуру данных). Конструктор класса Context не имеет параметров; он заносит в набор names односимвольные имена переменных от&nbsp;a до&nbsp;j, а в набор values&nbsp;&#8212; нулевые значения. Класс Context включает три метода: SetVar(ind, name, value), GetName(ind), GetValue(ind). Параметр ind во всех методах определяет индекс обрабатываемой переменной (число от&nbsp;0 до&nbsp;9). Метод SetVar задает для переменной с индексом ind имя (строку name) и значение (целое число value). Метод GetName возвращает имя переменной с индексом ind, метод GetValue возвращает значение переменной с индексом ind. При реализации этих методов можно не проверять допустимость значений параметра ind, а также не контролировать возможную ошибочную ситуацию, когда два элемента набора name совпадают (т.е. когда две разные переменные имеют одинаковые имена). </p><p class="ptTaskContinue">Класс NontermConcat содержит структуру exprs (например, массив) с элементами-ссылками типа AbstractExpression, которая инициализируется в конструкторе, имеющем соответствующий параметр-структуру. Можно считать, что выражение concat содержит не более 5 выражений expr. Класс NontermIf содержит поля expr1 и expr2&nbsp;&#8212; ссылки на AbstractExpression (первое и второе выражение expr в правой части определения выражения if)&nbsp;&#8212; и целочисленное поле ind&nbsp;&#8212; индекс переменной var в некотором объекте-контексте. Класс NontermLoop содержит поле expr&nbsp;&#8212; ссылку на AbstractExpression (выражение expr в правой части определения выражения loop)&nbsp;&#8212; и целочисленное поле ind&nbsp;&#8212; индекс переменной var в некотором объекте-контексте. Значения полей этих классов задаются в их конструкторах с помощью одноименных параметров. </p><p class="ptTaskContinue">Класс TermStr содержит строковое поле s, задаваемое в конструкторе с помощью строкового параметра. В методах InterpretA и InterpretB этого класса должно возвращаться значение поля&nbsp;s без каких-либо изменений. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;30) и N наборов значений, каждый из которых определяет один узел синтаксического дерева разбора. Последующие узлы могут содержать ссылки на предыдущие, поэтому все узлы следует сохранять в структуре nodes (например, массиве) с элементами-ссылками типа AbstractExpression. Каждый набор, соответствующий узлу синтаксического дерева, начинается с символа &#34;C&#34;, &#34;I&#34;, &#34;L&#34; или &#34;S&#34;. Объекту класса NontermConcat соответствует символ &#34;C&#34;, за которым следует целое число K (2&nbsp;&#8804;&nbsp;K&nbsp;&#8804;&nbsp;5) и K индексов узлов из уже заполненной части структуры nodes (индексирование элементов структуры nodes ведется от&nbsp;0); все узлы в указанном порядке должны входить в структуру exprs объекта NontermConcat. Объекту класса NontermIf соответствует символ &#34;I&#34;, за которым следует индекс V переменной в некотором контексте (целое число в диапазоне от&nbsp;0 до&nbsp;9) и индексы двух узлов из уже заполненной части структуры nodes. Объекту класса NontermLoop соответствует символ &#34;L&#34;, за которым следует индекс V переменной в некотором контексте и индекс некоторого узла из уже заполненной части структуры nodes. Наконец, объекту класса TermStr соответствует символ &#34;S&#34;, за которым следует строка&nbsp;&#8212; значение выражения str. </p><p class="ptTaskContinue">Также даны три набора значений, определяющих три различных контекста. Определение каждого контекста содержит целое число M (&#8804;&nbsp;10) и M наборов троек (ind, name, val), в которых ind определяет индекс переменной в контексте, name определяет имя переменной, а val&nbsp;&#8212; ее значение (для остальных переменных контекста сохраняются имена и значения по умолчанию). </p><p class="ptTaskContinue">Используя исходные данные, сформировать элементы синтаксического дерева разбора и сохранить их в структуре nodes, а также создать и настроить три объекта типа Context. Для последнего элемента структуры nodes вызвать методы InterpretA и InterpretB, указав в качестве параметра каждый из созданных контекстов, и вывести их возвращаемые значения (вначале выводятся значения, соответствующие первому контексту, затем второму, затем третьему). </p><pre class="pt">public class Context
{
    // Add the constructor, required fields and methods
}

public abstract class AbstractExpression
{
    public abstract string InterpretA(Context cont);
    public abstract string InterpretB(Context cont);
}

// Implement the TermStr, NontermConcat, NontermIf
//   and NontermLoop descendant classes</pre>
<h1>Знакомство с&nbsp;запросами LINQ</h1>
<p class="ptAuthor">М.&nbsp;Э.&nbsp;Абрамян, 2013, 2021</p>
<p class="ptComment"> </p><p class="ptComment">При вводе (выводе) последовательности вначале следует ввести (соответственно, вывести) ее размер, а затем ее элементы. Все входные последовательности являются непустыми. Выходные последовательности могут быть пустыми; в этом случае требуется вывести единственное число 0 &#8212; размер данной последовательности. </p><p class="ptComment">Если в задании идет речь о <i>порядковых номерах</i> элементов последовательности, то предполагается, что нумерация ведется от&nbsp;1 (таким образом, порядковый номер элемента равен <i>индексу</i> этого элемента, <i>увеличенному на</i>&nbsp;1). </p><p class="ptComment">Для обработки входной последовательности в большинстве заданий достаточно указать <i>единственный</i> оператор, содержащий вызовы нужных запросов LINQ to Objects и другие необходимые конструкции, в частности, операцию <tt>??</tt> языка C# (в VB.NET, начиная с версии 9.0, аналогом этой операции является бинарная операция <tt>If</tt>). </p><p class="ptComment">При выполнении заданий с использованием задачника Programming Taskbook можно использовать дополнительные методы, определенные в задачнике: </p><p class="ptComment">&#8226; методы <tt>GetEnumerableInt</tt> и <tt>GetEnumerableString</tt> (<tt>ReadSeqInteger</tt> и <tt>ReadSeqString</tt> в PascalABC.NET) обеспечивают ввод исходных последовательностей с элементами целого и строкового типа соответственно (выполняется ввод размера последовательности и всех ее элементов, возвращается введенная последовательность); </p><p class="ptComment">&#8226; метод <tt>Put</tt> (<tt>WriteAll</tt> в PascalABC.NET) является методом расширения для последовательности и обеспечивает вывод этой последовательности (выводится размер последовательности и все ее элементы); </p><p class="ptComment">&#8226; метод <tt>Show</tt> также является методом расширения для последовательности; он обеспечивает печать последовательности в разделе отладки окна задачника и возвращает эту же последовательность (отладочная печать может сопровождаться <i>комментарием</i>, который указывается в качестве необязательного строкового параметра метода <tt>Show</tt>). </p><p class="ptComment">Использование вспомогательных методов иллюстрируется приведенным ниже фрагментом программы, решающей следующую задачу: извлечь из исходной целочисленной последовательности четные отрицательные числа и заменить порядок их следования на обратный. </p><p class="ptComment">[C#] </p><p class="ptCommentQuote"><i>// Ввод исходных данных</i><br><tt>var a = GetEnumerableInt();</tt><br><i>// Обработка</i><br><tt>var res = a.Where(e =&gt; e % 2 == 0 &amp;&amp; e &lt; 0).Reverse();</tt><br><i>// Вывод результатов</i><br><tt>res.Put();</tt></p><p class="ptCommentContinue"></p><p class="ptComment">[VB.NET] </p><p class="ptCommentQuote"><i>' Ввод исходных данных</i><br><tt>Dim a = GetEnumerableInt()</tt><br><i>' Обработка</i><br><tt>Dim res = a.Where(Function(e) e Mod 2 = 0 AndAlso e &lt; 0).Reverse()</tt><br><i>' Вывод результатов</i><br><tt>res.Put()</tt></p><p class="ptCommentContinue"></p><p class="ptComment">[PascalABC.NET] </p><p class="ptCommentQuote"><i>// Ввод исходных данных</i><br><tt>var a := ReadSeqInteger;</tt><br><i>// Обработка</i><br><tt>var res := a.Where(e -&gt; (e mod 2 = 0) and (e &lt; 0)).Reverse;</tt><br><i>// Вывод результатов</i><br><tt>res.WriteAll;</tt></p><p class="ptCommentContinue"></p><p class="ptComment">Все этапы решения можно объединить в одном операторе, состоящем из цепочки последовательно вызываемых методов: </p><p class="ptComment">[C#] </p><p class="ptCommentQuote"><tt>GetEnumerableInt().Where(e =&gt; e % 2 == 0 &amp;&amp; e &lt; 0)</tt></p><p class="ptCommentContinue"></p><p class="ptCommentQuote"><tt>&nbsp;&nbsp;.Reverse().Put();</tt></p><p class="ptCommentContinue"></p><p class="ptComment">[VB.NET] </p><p class="ptCommentQuote"><tt>GetEnumerableInt().Where(Function(e) e Mod 2 = 0 AndAlso e &lt; 0) _</tt></p><p class="ptCommentContinue"></p><p class="ptCommentQuote"><tt>&nbsp;&nbsp;.Reverse().Put()</tt></p><p class="ptCommentContinue"></p><p class="ptComment">[PascalABC.NET] </p><p class="ptCommentQuote"><tt>ReadSeqInteger.Where(e -&gt; (e mod 2 = 0) and (e &lt; 0))</tt></p><p class="ptCommentContinue"></p><p class="ptCommentQuote"><tt>&nbsp;&nbsp;.Reverse.WriteAll;</tt></p><p class="ptCommentContinue"></p><p class="ptComment">Возможен вариант решения, в котором дополнительно выполняется отладочная печать (в данном случае полученная последовательность четных отрицательных чисел печатается перед изменением порядка следования ее элементов и после этого изменения): </p><p class="ptComment">[C#] </p><p class="ptCommentQuote"><tt>GetEnumerableInt().Where(e =&gt; e % 2 == 0 &amp;&amp; e &lt; 0)</tt></p><p class="ptCommentContinue"></p><p class="ptCommentQuote"><tt>&nbsp;&nbsp;.Show().Reverse().Show().Put();</tt></p><p class="ptCommentContinue"></p><p class="ptComment">[VB.NET] </p><p class="ptCommentQuote"><tt>GetEnumerableInt().Where(Function(e) e Mod 2 = 0 AndAlso e &lt; 0) _</tt></p><p class="ptCommentContinue"></p><p class="ptCommentQuote"><tt>&nbsp;&nbsp;.Show().Reverse().Show().Put()</tt></p><p class="ptCommentContinue"></p><p class="ptComment">[PascalABC.NET] </p><p class="ptCommentQuote"><tt>ReadSeqInteger.Where(e -&gt; (e mod 2 = 0) and (e &lt; 0))</tt></p><p class="ptCommentContinue"></p><p class="ptCommentQuote"><tt>&nbsp;&nbsp;.Show.Reverse.Show.WriteAll;</tt></p><p class="ptCommentContinue"></p><p class="ptComment">Отладочная печать позволяет увидеть состояние последовательности на различных этапах ее преобразования и тем самым облегчает поиск ошибок.</p>
<h2>Поэлементные операции, агрегирование и&nbsp;генерирование последовательностей</h2>
<p class="ptComment"> </p><p class="ptComment">Изучаемые методы LINQ: </p><p class="ptCommentQuote">&#8226; First, FirstOrDefault, Last, LastOrDefault, Single, SingleOrDefault (поэлементные операции);<br>&#8226; Count, Sum, Average, Max, Min, Aggregate (агрегирование);<br>&#8226; Range (генерирование последовательностей).</p>
<p class="ptTask"><span class="ptSpecial">LinqBegin6°</span>. Дана строковая последовательность. Найти сумму длин всех строк, входящих в данную последовательность. </p>
<p class="ptTask"><span class="ptSpecial">LinqBegin14°</span>. Даны целые числа <i>A</i> и <i>B</i> (<i>A</i>&nbsp;&lt;&nbsp;<i>B</i>). Используя методы Range и Average, найти среднее арифметическое квадратов всех целых чисел от <i>A</i> до <i>B</i> включительно: (<i>A</i><sup>2</sup>&nbsp;+&nbsp;(<i>A</i>+1)<sup>2</sup>&nbsp;+&nbsp;&#8230;&nbsp;+&nbsp;<i>B</i><sup>2</sup>)/(<i>B</i>&nbsp;&#8722;&nbsp;<i>A</i>&nbsp;+&nbsp;1) (как вещественное число). </p>
<h2>Фильтрация, сортировка, теоретико-множественные операции</h2>
<p class="ptComment"> </p><p class="ptComment">Изучаемые методы LINQ: </p><p class="ptCommentQuote">&#8226; Where, TakeWhile, SkipWhile, Take, Skip (фильтрация);<br>&#8226; OrderBy, OrderByDescending, ThenBy, ThenByDescending (сортировка);<br>&#8226; Distinct, Reverse (удаление повторяющихся элементов и инвертирование);<br>&#8226; Union, Intersect, Except (теоретико-множественные операции).</p>
<p class="ptTask"><span class="ptSpecial">LinqBegin26°</span>. Даны целые числа <i>K</i><sub>1</sub> и <i>K</i><sub>2</sub> и последовательность непустых строк <i>A</i>; 1&nbsp;&lt;&nbsp;<i>K</i><sub>1</sub>&nbsp;&lt;&nbsp;<i>K</i><sub>2</sub>&nbsp;&#8804;&nbsp;<i>N</i>, где <i>N</i> &#8212; размер последовательности <i>A</i>. Найти среднее арифметическое длин всех элементов последовательности, кроме элементов с порядковыми номерами от <i>K</i><sub>1</sub> до <i>K</i><sub>2</sub> включительно, и вывести его как вещественное число. </p>
<p class="ptTask"><span class="ptSpecial">LinqBegin29°</span>. Даны целые числа <i>D</i> и <i>K</i> (<i>K</i>&nbsp;&gt;&nbsp;0) и целочисленная последовательность <i>A</i>. Найти теоретико-множественное объединение двух фрагментов <i>A</i>: первый содержит все элементы до первого элемента, большего <i>D</i> (не включая его), а второй &#8212; все элементы, начиная с элемента с порядковым номером <i>K</i>. Полученную последовательность (не содержащую одинаковых элементов) отсортировать по убыванию. </p>
<h2>Проецирование</h2>
<p class="ptComment"> </p><p class="ptComment">Изучаемые методы LINQ: </p><p class="ptCommentQuote">&#8226; Select, SelectMany (проецирование).</p>
<p class="ptTask"><span class="ptSpecial">LinqBegin37°</span>. Дана строковая последовательность <i>A</i>. Строки последовательности содержат только заглавные буквы латинского алфавита. Получить новую последовательность строк, элементы которой определяются по соответствующим элементам <i>A</i> следующим образом: пустые строки в новую последовательность не включаются, а к непустым приписывается порядковый номер данной строки в исходной последовательности (например, если пятый элемент <i>A</i> имеет вид &#34;ABC&#34;, то в полученной последовательности он будет иметь вид &#34;ABC5&#34;). При нумерации должны учитываться и пустые строки последовательности <i>A</i>. Отсортировать полученную последовательность в лексикографическом порядке по возрастанию. </p>
<p class="ptTask"><span class="ptSpecial">LinqBegin38°</span>. Дана целочисленная последовательность <i>A</i>. Получить новую последовательность чисел, элементы которой определяются по соответствующим элементам последовательности <i>A</i> следующим образом: если порядковый номер элемента <i>A</i> делится на 3 (3, 6,&nbsp;&#8230;), то этот элемент в новую последовательность не включается; если остаток от деления порядкового номера на 3 равен 1 (1, 4,&nbsp;&#8230;), то в новую последовательность добавляется удвоенное значение этого элемента; в противном случае (для элементов <i>A</i> с номерами 2, 5,&nbsp;&#8230;) элемент добавляется в новую последовательность без изменений. В полученной последовательности сохранить исходный порядок следования элементов. </p>
<h2>Объединение и&nbsp;группировка</h2>
<p class="ptComment"> </p><p class="ptComment">Изучаемые методы LINQ: </p><p class="ptCommentQuote">&#8226; Concat (сцепление);<br>&#8226; Join, GroupJoin (объединение);<br>&#8226; DefaultIfEmpty (замена пустой последовательности на одноэлементную);<br>&#8226; GroupBy (группировка).</p>
<p class="ptTask"><span class="ptSpecial">LinqBegin45°</span>. Даны целые положительные числа <i>L</i><sub>1</sub> и <i>L</i><sub>2</sub> и строковые последовательности <i>A</i> и <i>B</i>. Строки последовательностей содержат только цифры и заглавные буквы латинского алфавита. Получить последовательность, содержащую все строки из <i>A</i> длины <i>L</i><sub>1</sub> и все строки из <i>B</i> длины <i>L</i><sub>2</sub>. Отсортировать полученную последовательность в лексикографическом порядке по убыванию. </p>
<p class="ptTask"><span class="ptSpecial">LinqBegin50°</span>. Даны строковые последовательности <i>A</i> и <i>B</i>; все строки в каждой последовательности различны и имеют ненулевую длину. Получить последовательность строк вида &#34;<i>E</i>:<i>N</i>&#34;, где <i>E</i> обозначает один из элементов последовательности <i>A</i>, а <i>N</i> &#8212; количество элементов из <i>B</i>, начинающихся с того же символа, что и элемент <i>E</i> (например, &#34;abc:4&#34;); количество <i>N</i> может быть равно 0. Порядок элементов полученной последовательности должен определяться исходным порядком элементов последовательности&nbsp;<i>A</i>. </p><p class="ptTaskContinue"><span class="ptSpecial">Указание</span>. Использовать метод GroupJoin. </p>
<p class="ptTask"><span class="ptSpecial">LinqBegin58°</span>. Дана последовательность непустых строк. Среди всех строк, начинающихся с одного и того же символа, выбрать наиболее длинную. Если таких строк несколько, то выбрать первую по порядку их следования в исходной последовательности. Полученную последовательность строк упорядочить по возрастанию кодов их начальных символов. </p>
<h1>Технология LINQ to&nbsp;Objects</h1>
<p class="ptAuthor">М.&nbsp;Э.&nbsp;Абрамян, 2013, 2021</p>
<p class="ptComment"> </p><p class="ptComment">В каждом задании даются имена одного или нескольких текстовых файлов, содержащих исходные последовательности, а также имя текстового файла, в который требуется записать результаты обработки исходных последовательностей (имя результирующего файла указывается последним). Каждая исходная последовательность содержится в отдельном файле. Все исходные файлы содержат текст в кодировке ASCII; эта же кодировка должна использоваться при записи полученных данных в результирующий файл. </p><p class="ptComment">Каждый элемент последовательности размещается в отдельной строке файла, в начале и конце строки пробелы отсутствуют, поля элемента не содержат пробелов и разделяются ровно одним пробелом. Все исходные числовые данные являются положительными. В качестве десятичного разделителя используется <i>точка</i>. </p><p class="ptComment">Если в задание входят дополнительные числовые или строковые исходные данные, то они указываются в начале набора исходных данных (перед именами файлов).</p>
<h2>Обработка отдельных последовательностей</h2>
<p class="ptTask"><span class="ptSpecial">LinqObj3°</span>. Исходная последовательность содержит сведения о клиентах фитнес-центра. Каждый элемент последовательности включает следующие целочисленные поля: </p><p class="ptTaskQuote"><tt>&lt;Год&gt; &lt;Номер месяца&gt; &lt;Продолжительность занятий (в часах)&gt; &lt;Код клиента&gt;</tt></p><p class="ptTaskContinue">Определить год, в котором суммарная продолжительность занятий всех клиентов была наибольшей, и вывести этот год и наибольшую суммарную продолжительность. Если таких годов было несколько, то вывести наименьший из них. </p>
<p class="ptTask"><span class="ptSpecial">LinqObj22°</span>. Исходная последовательность содержит сведения об абитуриентах. Каждый элемент последовательности включает следующие поля: </p><p class="ptTaskQuote"><tt>&lt;Фамилия&gt; &lt;Номер школы&gt; &lt;Год поступления&gt;</tt></p><p class="ptTaskContinue">Для каждой школы найти годы поступления абитуриентов из этой школы и вывести номер школы и найденные для нее годы (годы располагаются на той же строке, что и номер школы, и упорядочиваются по возрастанию). Сведения о каждой школе выводить на новой строке и упорядочивать по возрастанию номеров школ. </p>
<p class="ptTask"><span class="ptSpecial">LinqObj25°</span>. Исходная последовательность содержит сведения о задолжниках по оплате коммунальных услуг, живущих в 144-квартирном 9-этажном доме. Каждый элемент последовательности включает следующие поля: </p><p class="ptTaskQuote"><tt>&lt;Фамилия&gt; &lt;Задолженность&gt; &lt;Номер квартиры&gt;</tt></p><p class="ptTaskContinue">Задолженность указывается в виде дробного числа (целая часть &#8212; рубли, дробная часть &#8212; копейки). В каждом подъезде на каждом этаже располагаются по 4&nbsp;квартиры. Найти номер подъезда, жильцы которого имеют наибольшую суммарную задолженность, и вывести этот номер вместе с размером суммарной задолженности (выводится с двумя дробными знаками). Считать, что суммарные задолженности для всех подъездов имеют различные значения. </p>
<p class="ptTask"><span class="ptSpecial">LinqObj47°</span>. Исходная последовательность содержит сведения об автозаправочных станциях (АЗС). Каждый элемент последовательности включает следующие поля: </p><p class="ptTaskQuote"><tt>&lt;Цена 1 литра (в копейках)&gt; &lt;Компания&gt; &lt;Улица&gt; &lt;Марка бензина&gt;</tt></p><p class="ptTaskContinue">Названия компаний и улиц не содержат пробелов. В качестве марки бензина указываются числа 92, 95 или 98. Каждая компания имеет не более одной АЗС на каждой улице; цены на разных АЗС одной и той же компании могут различаться. Вывести данные обо всех АЗС, предлагавших не менее двух марок бензина (вначале выводится название компании, затем название улицы, затем количество предлагавшихся марок бензина). Сведения о каждой АЗС выводить на новой строке и упорядочивать по названиям компаний в алфавитном порядке, а для одинаковых компаний &#8212; по названиям улиц (также в алфавитном порядке). Если ни одной требуемой АЗС не найдено, то записать в результирующий файл строку &#34;No&#34;. </p>
<p class="ptTask"><span class="ptSpecial">LinqObj58°</span>. Исходная последовательность содержит сведения о результатах сдачи учащимися экзаменов по математике, русскому языку и информатике (в указанном порядке). Каждый элемент последовательности включает следующие поля: </p><p class="ptTaskQuote"><tt>&lt;Фамилия&gt; &lt;Инициалы&gt; &lt;Номер школы&gt; &lt;Баллы&gt;</tt></p><p class="ptTaskContinue">Баллы представляют собой три целых числа в диапазоне от&nbsp;0 до&nbsp;100, которые отделяются друг от друга одним пробелом. Для каждой школы найти трех первых учащихся (в алфавитном порядке), набравших менее 50 баллов хотя бы по одному из предметов, и вывести их фамилию, инициалы и номер школы. Сведения о каждом учащемся выводить на отдельной строке и упорядочивать в алфавитном порядке фамилий и инициалов, а при их совпадении &#8212; по возрастанию номера школы. Если для некоторой школы имеется менее трех учащихся, удовлетворяющих указанным условиям, то вывести сведения обо всех таких учащихся. Если в исходном наборе нет ни одного учащегося, удовлетворяющего указанным условиям, то записать в результирующий файл текст &#34;Required students not found&#34;. </p>
<p class="ptTask"><span class="ptSpecial">LinqObj68°</span>. Исходная последовательность содержит сведения об оценках учащихся по трем предметам: алгебре, геометрии и физике. Каждый элемент последовательности содержит данные об одной оценке и включает следующие поля: </p><p class="ptTaskQuote"><tt>&lt;Класс&gt; &lt;Оценка&gt; &lt;Фамилия&gt; &lt;Инициалы&gt; &lt;Название предмета&gt;</tt></p><p class="ptTaskContinue">Полных однофамильцев (с совпадающей фамилией и инициалами) среди учащихся нет. Класс задается целым числом, оценка &#8212; целое число в диапазоне 2&#8211;5. Название предмета указывается с заглавной буквы. Найти всех <i>хорошистов</i> &#8212; учащихся, не получивших ни одной двойки и тройки, но имеющих хотя бы одну четверку по какому-либо предмету. Вывести сведения о каждом хорошисте: полученное число четверок, фамилию, инициалы и номер класса. Сведения о каждом учащемся выводить на отдельной строке и располагать по возрастанию количества четверок, а при их равенстве &#8212; в алфавитном порядке фамилий и инициалов. Если в наборе исходных данных нет ни одного учащегося, удовлетворяющего указанным условиям, то записать в результирующий файл текст &#34;Required students not found&#34;. </p>
<h2>Обработка нескольких взаимосвязанных последовательностей</h2>
<p class="ptComment"> </p><p class="ptComment">В каждом задании данной подгруппы требуется обработать несколько (от двух до четырех) последовательностей из следующего набора: </p><p class="ptCommentQuote"><i>A</i>: &nbsp; &nbsp;сведения о потребителях, содержащие поля &#34;Код потребителя&#34;, &#34;Год рождения&#34;, &#34;Улица проживания&#34;;<br><i>B</i>: &nbsp; &nbsp;сведения о товарах, содержащие поля &#34;Артикул товара&#34;, &#34;Категория&#34;, &#34;Страна-производитель&#34;;<br><i>C</i>: &nbsp; &nbsp;скидки для потребителей в различных магазинах, содержащие поля &#34;Код потребителя&#34;, &#34;Название магазина&#34;, &#34;Скидка (в процентах)&#34;;<br><i>D</i>: &nbsp; &nbsp;цены товаров в различных магазинах, содержащие поля &#34;Артикул товара&#34;, &#34;Название магазина&#34;, &#34;Цена (в рублях)&#34;;<br><i>E</i>: &nbsp; &nbsp;сведения о покупках потребителей в различных магазинах, содержащие поля &#34;Код потребителя&#34;, &#34;Артикул товара&#34;, &#34;Название магазина&#34;.</p><p class="ptCommentContinue"></p><p class="ptComment">Порядок следования полей для элементов каждой последовательности определяется в формулировке задания. </p><p class="ptComment">В последовательности <i>A</i> все элементы имеют различные значения поля &#34;Код потребителя&#34;. В последовательности <i>B</i> все элементы имеют различные значения поля &#34;Артикул товара&#34;. В последовательности <i>C</i> все элементы имеют различные комбинации полей &#34;Код потребителя&#34; и &#34;Название магазина&#34;. В последовательности <i>D</i> все элементы имеют различные комбинации полей &#34;Артикул товара&#34; и &#34;Название магазина&#34;. Последовательность <i>E</i> может содержать одинаковые элементы (это соответствует ситуации, при которой один и тот же потребитель приобрел в одном и том же магазине несколько одинаковых товаров). </p><p class="ptComment">Все значения кодов потребителей и артикулов товаров, присутствующие в последовательностях <i>C</i>, <i>D</i> и <i>E</i>, обязательно содержатся в последовательностях <i>A</i> и <i>B</i>. Некоторые значения кодов потребителей и артикулов товаров, присутствующие в последовательностях <i>A</i> и <i>B</i>, могут отсутствовать в остальных последовательностях. Любая комбинация &#34;магазин&#8211;товар&#34;, присутствующая в последовательности <i>E</i>, обязательно присутствует и в последовательности <i>D</i>. Комбинация &#34;потребитель&#8211;магазин&#34;, присутствующая в последовательности <i>E</i>, может отсутствовать в последовательности <i>C</i>; это означает, что при покупке указанного товара в данном магазине потребитель не имел скидки (т.&nbsp;е. скидка была равна 0). </p><p class="ptComment">Коды потребителей, годы рождения, скидки и цены задаются целыми числами; значения скидок лежат в диапазоне от 5 до 50. Прочие поля являются строковыми и не содержат пробелов. Артикулы товаров имеют формат &#34;AAddd-dddd&#34;, где на позициях, помеченных символом &#34;A&#34;, располагается какая-либо заглавная латинская буква, а на позициях, помеченных символом &#34;d&#34;, &#8212; какая-либо цифра. </p><p class="ptComment">Если потребитель приобрел товар, имеющий цену <i>p</i>, со скидкой <i>d</i> процентов, то размер скидки на данный товар должен вычисляться по формуле <i>p</i>&nbsp;&#183;&nbsp;<i>d</i>&nbsp;/&nbsp;100, где символ &#34;/&#34; обозначает операцию целочисленного деления (иными словами, при вычислении размера скидки копейки отбрасываются).</p>
<p class="ptTask"><span class="ptSpecial">LinqObj77°</span>. Даны последовательности <i>B</i> и <i>D</i>, включающие следующие поля: </p><p class="ptTaskQuote"><i>B</i>: &nbsp; &nbsp;<tt>&lt;Категория&gt; &lt;Артикул товара&gt; &lt;Страна-производитель&gt;</tt><br><i>D</i>: &nbsp; &nbsp;<tt>&lt;Артикул товара&gt; &lt;Цена (в рублях)&gt; &lt;Название магазина&gt;</tt></p><p class="ptTaskContinue">Свойства последовательностей описаны в преамбуле к данной подгруппе заданий. Для каждой категории товаров определить количество магазинов, предлагающих товары данной категории, а также количество стран, в которых произведены товары данной категории, представленные в магазинах (вначале выводится количество магазинов, затем название категории, затем количество стран). Если для некоторой категории не найдено ни одного товара, представленного в каком-либо магазине, то информация о данной категории не выводится. Сведения о каждой категории выводить на новой строке и упорядочивать по убыванию количества магазинов, а в случае одинакового количества &#8212; по названиям категорий в алфавитном порядке. </p>
<p class="ptTask"><span class="ptSpecial">LinqObj84°</span>. Даны последовательности <i>C</i>, <i>D</i> и <i>E</i>, включающие следующие поля: </p><p class="ptTaskQuote"><i>C</i>: &nbsp; &nbsp;<tt>&lt;Скидка (в процентах)&gt; &lt;Название магазина&gt; &lt;Код потребителя&gt;</tt><br><i>D</i>: &nbsp; &nbsp;<tt>&lt;Артикул товара&gt; &lt;Название магазина&gt; &lt;Цена (в рублях)&gt;</tt><br><i>E</i>: &nbsp; &nbsp;<tt>&lt;Артикул товара&gt; &lt;Название магазина&gt; &lt;Код потребителя&gt;</tt></p><p class="ptTaskContinue">Свойства последовательностей описаны в преамбуле к данной подгруппе заданий. Для каждого магазина и каждого товара определить количество покупок этого товара со скидкой в данном магазине и суммарную стоимость этих покупок с учетом скидки (вначале выводится название магазина, затем артикул товара, затем количество покупок со скидкой и их суммарная стоимость). При вычислении размера скидки на товар копейки отбрасываются. Если для некоторой пары &#34;магазин&#8211;товар&#34; не найдено ни одной покупки со скидкой, то информация о данной паре не выводится. Если не найдено ни одной подходящей пары &#34;магазин&#8211;товар&#34;, то записать в результирующий файл текст &#34;Required data not found&#34;. Сведения о каждой паре &#34;магазин&#8211;товар&#34; выводить на новой строке и упорядочивать по названиям магазинов в алфавитном порядке, а для одинаковых названий &#8212; по артикулам товаров (также в алфавитном порядке). </p>
<p class="ptTask"><span class="ptSpecial">LinqObj100°</span>. Даны последовательности <i>A</i>, <i>B</i>, <i>D</i> и <i>E</i>, включающие следующие поля: </p><p class="ptTaskQuote"><i>A</i>: &nbsp; &nbsp;<tt>&lt;Улица проживания&gt; &lt;Код потребителя&gt; &lt;Год рождения&gt;</tt><br><i>B</i>: &nbsp; &nbsp;<tt>&lt;Артикул товара&gt; &lt;Страна-производитель&gt; &lt;Категория&gt;</tt><br><i>D</i>: &nbsp; &nbsp;<tt>&lt;Название магазина&gt; &lt;Цена (в рублях)&gt; &lt;Артикул товара&gt;</tt><br><i>E</i>: &nbsp; &nbsp;<tt>&lt;Артикул товара&gt; &lt;Код потребителя&gt; &lt;Название магазина&gt;</tt></p><p class="ptTaskContinue">Свойства последовательностей описаны в преамбуле к данной подгруппе заданий. Для каждой страны-производителя и каждого магазина определить потребителя с наибольшим годом рождения, купившего в данном магазине один или более товаров, произведенных в данной стране (вначале выводится название страны, затем название магазина, затем год рождения потребителя, его код, а также суммарная стоимость товаров из данной страны, купленных в данном магазине). Если для некоторой пары &#34;страна&#8211;магазин&#34; отсутствует информация о проданных товарах, то данные об этой паре не выводятся. Если для некоторой пары &#34;страна&#8211;магазин&#34; имеется несколько потребителей с наибольшим годом рождения, то выводятся данные обо всех таких потребителях. Сведения о каждой тройке &#34;страна&#8211;магазин&#8211;потребитель&#34; выводить на новой строке и упорядочивать по названиям стран в алфавитном порядке, для одинаковых названий стран &#8212; по названиям магазинов (также в алфавитном порядке), а для одинаковых магазинов &#8212; по возрастанию кодов потребителей. </p>
<h1>Технология LINQ to&nbsp;XML</h1>
<p class="ptAuthor">М.&nbsp;Э.&nbsp;Абрамян, 2013, 2021</p>
<p class="ptComment"> </p><p class="ptComment"><i>Узлом</i> (node) XML-документа называется любой его компонент,
не являющийся <i>атрибутом</i> (attribute), в частности, <i>комментарий</i> (comment),
<i>инструкция обработки</i> (processing instruction), обычный текст.
<i>Элементом</i> (element) XML-документа называется именованный компонент,
который может содержать другие узлы, а также иметь атрибуты. В
объектной модели X-DOM, входящей в состав интерфейса LINQ to XML, с каждым видом компонентов
XML-документа связан соответствующий класс:
<tt>XObject</tt> &#8212; общий предок всех компонентов,
<tt>XNode</tt> &#8212; общий предок всех узлов,
<tt>XText</tt> &#8212; текстовый узел, т.&nbsp;е. узел, представляющий собой обычный текст, 
<tt>XComment</tt> &#8212; комментарий, <tt>XProcessingInstruction</tt> &#8212; инструкция обработки,
<tt>XElement</tt> &#8212; элемент, <tt>XAttribute</tt> &#8212; атрибут. С XML-документом связан класс <tt>XDocument</tt>.
</p><p class="ptComment">Если некоторый узел <i>B</i> XML-документа содержится внутри некоторого элемента <i>A</i>, то
элемент <i>A</i> называется <i>предком</i> (ancestor) узла <i>B</i>, а узел <i>B</i> &#8212; <i>потомком</i> (descendant)
элемента <i>A</i>. Если элемент <i>A</i> является ближайшим предком узла <i>B</i>, то <i>B</i> называется
<i>дочерним узлом</i> (child node) элемента <i>A</i>, а элемент <i>A</i> &#8212; <i>родительским элементом</i>
(parent) узла <i>B</i>; если при этом узел <i>B</i> является элементом, то он называется <i>дочерним элементом</i>
(child element) элемента <i>A</i>.
Первый элемент XML-документа называется <i>корневым элементом</i> (root); корневой элемент является предком
для всех других элементов XML-документа, сам корневой элемент предков не имеет.
</p><p class="ptComment">Корневой элемент считается элементом <i>нулевого уровня</i>, его дочерние узлы/элементы &#8212;
узлами/элементами <i>первого уровня</i>, их дочерние узлы/элементы &#8212; узлами/элементами <i>второго уровня</i>, и т.&nbsp;д.
В XML-документе имеется единственный элемент нулевого уровня (корневой элемент), однако 
могут присутствовать несколько узлов нулевого уровня (комментариев или инструкций обработки).
</p><p class="ptComment">Если в задании говорится, что элемент содержит текстовую строку (или число), то это означает, что
соответствующая строка (или строковое представление числа) является дочерним текстовым узлом
данного элемента. 
</p><p class="ptComment">Во всех заданиях предполагается, что 
элемент имеет не больше одного дочернего текстового узла, а текстовый узел
содержит хотя бы один значащий символ (т.&nbsp;е. символ, отличный от пробела и управляющих символов). 
При сохранении XML-документа следует использовать метод <tt>Save</tt> класса <tt>XDocument</tt>
с единственным параметром &#8212; именем файла; это обеспечит автоматическое форматирование сохраняемого
документа и удаление всех текстовых узлов, не содержащих значащих символов.
</p><p class="ptComment">Элементы, не содержащие дочерних узлов, могут представляться в двух вариантах:
в виде <i>парных тегов</i>, между которыми отсутствует текст (<tt>&lt;a&gt;&lt;/a&gt;</tt>),
и в виде одного <i>комбинированного тега</i> (<tt>&lt;a&nbsp;/&gt;</tt>). Элементы, не содержащие узлов, могут иметь атрибуты.
</p><p class="ptComment">Если в условии сказано, что дан XML-документ, то это означает, что дано имя
файла, содержащего этот документ. Преобразование XML-документа всегда должно завершаться сохранением
преобразованного документа в том же файле, из которого был считан исходный вариант этого документа.
</p><p class="ptComment">Если в условии упоминаются порядковые номера элементов некоторой последовательности, то предполагается, что
нумерация начинается от&nbsp;1.
</p><p class="ptComment">В заданиях подгрупп, предшествующих подгруппе &#34;Работа с пространствами имен XML-документа&#34;, 
предполагается, что имена всех элементов и атрибутов XML-документа имеют пустое пространство имен.
</p><p class="ptComment">Указания, приведенные к некоторым заданиям, следует учитывать и при выполнении 
последующих заданий текущей подгруппы.</p>
<h2>Создание XML-документа</h2>
<p class="ptComment"> Во всех заданиях данной подгруппы
предполагается, что исходные текстовые файлы содержат текст в кодировке ASCII, 
а все файловые строки являются непустыми. Создаваемые XML-документы должны иметь
кодировку &#34;utf-8&#34;.</p>
<p class="ptTask"><span class="ptSpecial">LinqXml7°</span>. Даны имена существующего текстового файла и создаваемого XML-документа. Каждая строка текстового файла содержит несколько (одно или более) целых чисел, разделенных ровно одним пробелом. Создать XML-документ с корневым элементом <tt>root</tt>, элементами первого уровня <tt>line</tt> и элементами второго уровня <tt>sum-positive</tt> и <tt>number-negative</tt>. Элементы <tt>line</tt> соответствуют строкам исходного файла и не содержат дочерних текстовых узлов, элемент <tt>sum-positive</tt> является первым дочерним элементом каждого элемента <tt>line</tt> и содержит сумму всех положительных чисел из соответствующей строки, элементы <tt>number-negative</tt> содержат по одному отрицательному числу из соответствующей строки (числа располагаются в порядке, обратном порядку их следования в исходной строке). </p>
<h2>Анализ содержимого XML-документа</h2>
<p class="ptTask"><span class="ptSpecial">LinqXml18°</span>. Дан XML-документ, содержащий хотя бы один атрибут. Найти все различные имена атрибутов и вывести эти имена, а также все связанные с ними значения (все значения считаются текстовыми). Порядок имен должен соответствовать порядку их первого вхождения в документ; значения, связанные с каждым именем, выводить в алфавитном порядке. </p>
<h2>Преобразование XML-документа</h2>
<p class="ptTask"><span class="ptSpecial">LinqXml24°</span>. Дан XML-документ. Удалить из документа все комментарии, являющиеся узлами первого или второго уровня (т.&nbsp;е. имеющие своим родительским элементом корневой элемент или элемент первого уровня). </p>
<p class="ptTask"><span class="ptSpecial">LinqXml38°</span>. Дан XML-документ. Для каждого элемента, кроме корня, изменить его имя, добавив к нему слева исходные имена всех его предков, разделенные символом &#34;-&#34; (дефис). Например, если корневой элемент имеет имя <tt>root</tt>, то элемент <tt>bb</tt> второго уровня, родительский элемент которого имеет имя <tt>aa</tt>, должен получить имя <tt>root-aa-bb</tt>. </p><p class="ptTaskContinue"><span class="ptSpecial">Указание</span>. Перебирая все элементы последовательности Descendants корневого элемента, использовать их свойства Parent и Name. </p>
<h2>Преобразование типов при&nbsp;обработке XML-документа</h2>
<p class="ptTask"><span class="ptSpecial">LinqXml47°</span>. Дан XML-документ. Для каждого элемента, имеющего хотя бы один дочерний элемент, добавить дочерний элемент с именем <tt>has-comments</tt> и логическим значением, равным true, если данный элемент содержит в числе своих узлов-потомков один или более комментариев, и false в противном случае. Новый элемент добавить после первого имеющегося дочернего элемента. </p>
<h2>Работа с&nbsp;пространствами имен XML-документа</h2>
<p class="ptTask"><span class="ptSpecial">LinqXml58°</span>. Дан XML-документ и строка <i>S</i>, содержащая некоторое пространство имен. Определить в корневом элементе префикс <tt>node</tt>, связанный с пространством имен, заданным в строке <i>S</i>, и добавить в каждый элемент первого уровня два атрибута: атрибут <tt>node:count</tt> со значением, равным количеству потомков-узлов для данного элемента, и атрибут <tt>xml:count</tt> со значением, равным количеству потомков-элементов для данного элемента (<tt>xml</tt> &#8212; префикс пространства имен XML). </p><p class="ptTaskContinue"><span class="ptSpecial">Указание</span>. Использовать свойство Xml класса XNamespace. </p>
<h2>Дополнительные задания на&nbsp;обработку XML-документов</h2>
<p class="ptComment"> Во всех заданиях данной подгруппы
предполагается, что в корневом элементе исходного XML-документа определено
некоторое пространство имен, распространяющееся на все его элементы-потомки.
Это же пространство имен необходимо использовать для имен всех элементов
преобразованного документа. Префиксы пространств имен в заданиях данной подгруппы не используются.</p>
<p class="ptTask"><span class="ptSpecial">LinqXml76°</span>. Дан XML-документ с информацией о задолженности по оплате коммунальных услуг. Образец элемента первого уровня: </p><p class="ptTaskQuote"><tt>&lt;record&gt;                   </tt><br><tt>&nbsp;&nbsp;&lt;house&gt;12&lt;/house&gt;        </tt><br><tt>&nbsp;&nbsp;&lt;flat&gt;129&lt;/flat&gt;         </tt><br><tt>&nbsp;&nbsp;&lt;name&gt;Sergeev T.M.&lt;/name&gt;</tt><br><tt>&nbsp;&nbsp;&lt;debt&gt;1833.32&lt;/debt&gt;     </tt><br><tt>&lt;/record&gt;                  </tt></p><p class="ptTaskContinue">Здесь <tt>house</tt> &#8212; номер дома (целое число), <tt>flat</tt> &#8212; номер квартиры (целое число), <tt>name</tt> &#8212; фамилия и инициалы жильца (инициалы не содержат пробелов и отделяются от фамилии одним пробелом), <tt>debt</tt> &#8212; размер задолженности в виде дробного числа: целая часть &#8212; рубли, дробная часть &#8212; копейки (незначащие нули не указываются). Все дома являются 144-квартирными, имеют 9 этажей и 4 подъезда; на каждом этаже в каждом подъезде располагаются по 4 квартиры. Преобразовать документ, изменив элементы первого уровня следующим образом: </p><p class="ptTaskQuote"><tt>&lt;debt house="12" flat="129"&gt;</tt><br><tt>&nbsp;&nbsp;&lt;name&gt;Sergeev T.M.&lt;/name&gt; </tt><br><tt>&nbsp;&nbsp;&lt;value&gt;1833.32&lt;/value&gt;    </tt><br><tt>&lt;/debt&gt;                     </tt></p><p class="ptTaskContinue">Порядок следования элементов первого уровня не изменять. </p>
<p class="ptTask"><span class="ptSpecial">LinqXml86°</span>. Дан XML-документ с информацией об оценках учащихся по различным предметам. Образец элемента первого уровня (смысл данных тот же, что и в LinqXml83): </p><p class="ptTaskQuote"><tt>&lt;pupil name="Stepanova D.B." class="9"&gt;</tt><br><tt>&nbsp;&nbsp;&lt;info mark="4" subject="Physics" /&gt; </tt><br><tt>&lt;/pupil&gt;                               </tt></p><p class="ptTaskContinue">Преобразовать документ, выполнив группировку данных по учащимся и изменив элементы первого уровня следующим образом: </p><p class="ptTaskQuote"><tt>&lt;Stepanova_D.B. class="9"&gt;  </tt><br><tt>&nbsp;&nbsp;&lt;mark4 subject="Physics" /&gt;</tt><br><tt>&nbsp;&nbsp;...                       </tt><br><tt>&lt;/Stepanova_D.B.&gt;           </tt></p><p class="ptTaskContinue">Имя элемента первого уровня совпадает с фамилией и инициалами учащегося (пробел между фамилией и инициалами заменяется символом подчеркивания), имя элемента второго уровня должно иметь префикс <tt>mark</tt>, после которого указывается оценка. Элементы первого уровня должны быть отсортированы в алфавитном порядке фамилий и инициалов учащихся, их дочерние элементы &#8212; по убыванию оценок, а для одинаковых оценок &#8212; в алфавитном порядке названий предметов. </p>
<p class="ptTask"><span class="ptSpecial">LinqXml81°</span>. Дан XML-документ с информацией о задолженности по оплате коммунальных услуг. Образец элемента первого уровня (смысл данных тот же, что и в LinqXml76, данные сгруппированы по номерам домов; в качестве имен элементов первого уровня указываются номера домов, снабженные префиксом <tt>house</tt>, а в качестве имен элементов второго уровня &#8212; номера квартир, снабженные префиксом <tt>flat</tt>): </p><p class="ptTaskQuote"><tt>&lt;house12&gt;                                     </tt><br><tt>&nbsp;&nbsp;&lt;flat23 name="Ivanov A.V." debt="1245.64" /&gt;</tt><br><tt>&nbsp;&nbsp;...                                         </tt><br><tt>&lt;/house12&gt;                                    </tt></p><p class="ptTaskContinue">Преобразовать документ, сохранив группировку данных по номеру дома, выполнив в пределах каждого дома группировку по номеру подъезда и оставив сведения только о тех жильцах, размер задолженности которых не меньше среднего размера задолженности по данному подъезду. Изменить элементы первого уровня следующим образом: </p><p class="ptTaskQuote"><tt>&lt;house number="12"&gt;                                   </tt><br><tt>&nbsp;&nbsp;&lt;entrance number="1" count="4" avr-debt="1136"&gt;     </tt><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&lt;debt flat="23" name="Ivanov A.V."&gt;1245.64&lt;/debt&gt; </tt><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&lt;debt flat="28" name="Sidorov P.K."&gt;1383.27&lt;/debt&gt;</tt><br><tt>&nbsp;&nbsp;&lt;/entrance&gt;                                         </tt><br><tt>&nbsp;&nbsp;...                                                 </tt><br><tt>&lt;/house&gt;                                              </tt></p><p class="ptTaskContinue">Атрибут <tt>count</tt> равен количеству задолжников в данном подъезде, атрибут <tt>avr-debt</tt> определяет среднюю задолженность по данному подъезду в рублях (целое число), вычисленную по следующей формуле: &#34;<i>суммарная задолженность</i> <i>в копейках</i>&#34;/(&#34;<i>количество задолжников</i>&#34;*100) (символ &#34;/&#34; обозначает операцию целочисленного деления). Элементы третьего уровня содержат сведения о тех жильцах, размер задолженности которых не меньше величины <tt>avr-debt</tt> для данного подъезда. Элементы первого уровня должны быть отсортированы по возрастанию номеров домов, а их дочерние элементы &#8212; по возрастанию номеров подъездов. Элементы третьего уровня, имеющие общего родителя, должны быть отсортированы по возрастанию номеров квартир. Подъезды, в которых отсутствуют задолжники, не отображаются. </p>
<p class="ptTask"><span class="ptSpecial">LinqXml74°</span>. Дан XML-документ с информацией о ценах автозаправочных станций на бензин. Образец элемента первого уровня (смысл данных тот же, что и в LinqXml68, марки бензина, снабженные префиксом <tt>brand</tt>, указываются в качестве имен элементов первого уровня; атрибут <tt>station</tt> содержит названия улицы и компании, разделенные символом подчеркивания): </p><p class="ptTaskQuote"><tt>&lt;brand92 station="Chekhov-St._Leader" price="2200" /&gt; </tt></p><p class="ptTaskContinue">Преобразовать документ, сгруппировав данные по названиям компаний и изменив элементы первого уровня следующим образом: </p><p class="ptTaskQuote"><tt>&lt;Leader&gt;                                                   </tt><br><tt>&nbsp;&nbsp;&lt;Sadovaya-St. brand92="0" brand95="0" brand98="0" /&gt;     </tt><br><tt>&nbsp;&nbsp;&lt;Chekhov-St. brand92="2200" brand95="2450" brand98="0" /&gt;</tt><br><tt>&nbsp;&nbsp;...                                                     </tt><br><tt>&lt;/Leader&gt;                                                  </tt></p><p class="ptTaskContinue">Имя элемента первого уровня совпадает с названием компании, имя элемента второго уровня совпадает с названием улицы. Атрибуты элементов второго уровня имеют префикс <tt>brand</tt>, после которого указывается марка бензина; их значением является цена 1 литра бензина указанной марки или число 0, если на данной АЗС бензин указанной марки не предлагается. Для каждой компании должна выводиться информация по каждой улице, имеющейся в исходном документе, даже если на этой улице отсутствует АЗС данной компании (в этом случае значения всех атрибутов <tt>brand</tt> должны быть равны 0). Элементы первого уровня должны быть отсортированы в алфавитном порядке названий компаний, а их дочерние элементы &#8212; в алфавитном порядке названий улиц. </p>
<hr noshade>
<p class="ptFooter">Page generation date: 2022/6/25.</p>
</body></html>
