<!-- Programming Taskbook 4.22 | Copyright (c) M. Abramyan, 1998-2022 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>PT4Tasks</title>
<style type="text/css">
H1{font-family:"Arial";font-size:20pt;text-indent:0px;margin-top:10px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
H2{font-family:"Arial";font-size:16pt;text-indent:0px;margin-top:5px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
P{font-family:"Times New Roman";text-align:left;font-size:12pt;text-indent:0px;margin-top:0px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
TD{font-family:"Times New Roman";font-size:12pt;}
LI{font-family:"Times New Roman";font-size:12pt;}
UL{font-family:"Times New Roman";font-size:12pt;}
SUB{font-family:"Times New Roman";font-size:8pt;}
SUP{font-family:"Times New Roman";font-size:8pt;}
TABLE{margin-top:0px; margin-bottom:0px;}
P.ptAuthor{text-align:right;font-size:10pt;font-style:italic;}
P.ptTask{text-align:justify;text-indent:-50px;margin-top:5px; margin-left:60px;}
P.ptTaskQuote{text-align:left;margin-left:120px;margin-top:5px;margin-bottom:0px;}
P.ptTaskCenter{text-align:center;margin-left:60px;margin-top:5px;margin-bottom:0px;}
P.ptTaskContinue{text-align:justify;margin-left:60px;margin-top:5px; }
P.ptComment{text-align:justify;text-indent:50px;margin-top:5px;}
P.ptCommentCenter{text-align:center;margin-top:0px;}
P.ptCommentQuote{text-align:left;margin-left:120px;margin-top:0px;margin-bottom:0px;}
P.ptCommentContinue{text-align:justify;margin-top:0px;}
P.ptFooter{text-align:right;font-size:10pt;font-style:italic;margin-right:0px;}
SPAN.ptSpecial{font-family:"Arial";}
PRE{font-family:"Courier New";text-align:left;font-size:10pt;text-indent:0px;margin-top:5px; margin-right:10px; margin-bottom:0px; margin-left:60px;}
CODE{font-size:10pt;}
TT{font-size:10pt;}
P.ptPicture{font-family:Arial, sans-serif;margin-top: 5px;margin-bottom: 5px;margin-left: 60px;font-size: small;color: #000080;text-indent: 0pt;text-align: justify}
</style>
</head><body>
<h1>Паттерны поведения</h1>
<p class="ptAuthor">М.&nbsp;Э.&nbsp;Абрамян, 2021</p>
<h2>Observer, Strategy, Template Method</h2>
<p class="ptTask"><span class="ptSpecial">OOP3Behav1°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPObserver.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPObserver.png" border=1></p><p class="ptTaskContinue"><b>Observer</b> (<b>Наблюдатель</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue">Известен также под именем <b>Publish-Subscribe</b> (<b>Издатель-Подписчик</b>). </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: высокая. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: определяет зависимость типа &#34;один-ко-многим&#34; между объектами таким образом, что при изменении состояния одного объекта все зависящие от него объекты-наблюдатели оповещаются об этом событии. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Subject</i> (<i>Субъект</i>)&nbsp;&#8212; располагает информацией о своих наблюдателях (за субъектом может следить любое число наблюдателей); предоставляет интерфейс для присоединения и отсоединения наблюдателей; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Observer</i> (<i>Наблюдатель</i>)&nbsp;&#8212; определяет интерфейс обновления для объектов, которые должны быть уведомлены об изменении субъекта; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteSubject</i> (<i>Конкретный субъект</i>)&nbsp;&#8212; сохраняет состояние, представляющее интерес для конкретного наблюдателя ConcreteObserver; посылает информацию своим наблюдателям, когда происходит изменение; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteObserver</i> (<i>Конкретный наблюдатель</i>)&nbsp;&#8212; хранит ссылку на объект класса ConcreteSubject; сохраняет данные, которые должны быть согласованы с данными субъекта. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать две иерархии классов. Первая иерархия включает абстрактный класс Subject с абстрактными методами Attach(observ), Detach(observ) и Notify и класс-потомок ConcreteSubject. Методы Attach и Detach имеют параметр-ссылку типа Observer и не возвращают значений. Метод Notify не имеет параметров и не возвращает значения. </p><p class="ptTaskContinue">В классе ConcreteSubject дополнительно описать поля observers и state. Поле observers является структурой с элементами-ссылками типа Observer, в которой хранятся все наблюдатели, присоединенные в настоящий момент к субъекту (можно считать, что наблюдателей не более&nbsp;10). В качестве такой структуры удобно использовать динамическую структуру, имеющую команды для добавления и удаления элементов. Метод Attach(observ) добавляет объект observ в структуру observers, метод Detach(observ) удаляет объект observ из данной структуры. Поле state имеет символьный тип и моделирует текущее состояние субъекта. С ним связаны два метода: метод SetState(st) изменяет поле state, присваивая ему значение символьного параметра st и дополнительно вызывает метод Notify; метод GetState (без параметров) возвращает текущее значение поля state. В методе Notify выполняется перебор элементов структуры observers: для каждого элемента структуры вызывается его метод Update. При реализации метода Notify необходимо учесть ситуацию, когда во время выполнения метода Update некоторые наблюдатели отсоединятся от субъекта, что приведет к изменению структуры observers. Конструктор класса ConcreteSubject не имеет параметров, поле state инициализируется символом &#34;пробел&#34;. </p><p class="ptTaskContinue">Вторая иерархия включает абстрактный класс Observer с абстрактным методом Update (не имеет параметров и не возвращает значения) и конкретный класс ConcreteObserver, имеющий строковое поле log, символьное поле detachInfo, поле subj&nbsp;&#8212; ссылку на объект типа ConcreteSubject, а также методы Attach, Detach и GetLog. Конструктор класса ConcreteObserver имеет параметры subj и detachInfo, которые инициализируют соответствующие поля; поле log инициализируется пустой строкой. Методы Attach и Detach не имеют параметров и не возвращают значения. В методе Attach выполняется вызов метода Attach объекта subj, в методе Detach выполняется вызов метода Detach объекта subj, причем в качестве параметра в обоих вызываемых методах передается ссылка на объект ConcreteObserver, из которого вызваны эти методы. Метод GetLog не имеет параметров и возвращает значение поля log. </p><p class="ptTaskContinue">Метод Update, переопределяемый в классе ConcreteObserver, является основным методом, обеспечивающим взаимодействие между конкретным субъектом и конкретным наблюдателем. Именно этот метод вызывается конкретным субъектом при изменении его состояния. Таким образом, его вызов означает, что состояние конкретного субъекта изменилось, и наблюдатель может узнать это новое состояние, вызвав в методе Update метод GetState объекта subj. В данном задании в методе Update надо выполнить следующие дополнительные действия: добавить символ, полученный методом GetState, в конец поля log объекта ConcreteObserver, для которого был вызван метод Update, и, кроме того, если полученный символ совпадает со значением поля detachInfo, то немедленно отсоединить наблюдателя ConcreteObserver от субъекта subj, вызвав метод Detach наблюдателя. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;10) и строка&nbsp;S, содержащая различные заглавные латинские буквы и имеющая длину не более&nbsp;26. Создать объект subj типа ConcreteSubject и набор observers из N&nbsp;объектов типа ConcreteObserver, указав в качестве первого параметра конструктора объектов ConcreteObserver ссылку на объект subj, а в качестве второго параметра&nbsp;&#8212; заглавные латинские буквы, перебирая их в алфавитном порядке (&#34;A&#34; для первого объекта ConcreteObserver, &#34;B&#34; для второго объекта и т.&nbsp;д.). Для каждого объекта ConcreteObserver вызвать его метод Attach. Затем для каждого символа из данной строки&nbsp;S вызвать метод SetState объекта subj, передав методу этот символ в качестве параметра. После обработки всех символов строки&nbsp;S вывести значения полей log объектов из набора observers, используя метод GetLog класса ConcreteObserver (выведенные строки должны содержать все начальные символы строки S вплоть до того символа, который вызвал отсоединение наблюдателя от объекта subj). </p><p class="ptTaskContinue"><span class="ptSpecial">Примечание.</span> В языке C# для реализации паттерна Observer удобно использовать <i>делегаты</i> и <i>события</i>. В нашем случае можно удалить методы Attach и Detach из иерархии классов Subject (оставив в абстрактном классе только метод Notify), удалить структуру observers из класса ConcreteSubject, описать делегат: <code>public delegate void NotifyEventHandler()</code>; добавить событие OnNotify в класс ConcreteSubject: <code>public event NotifyEventHandler OnNotify</code>; и определить метод Notify следующим образом: <code>if (OnNotify != null) OnNotify();</code><br> В классе ConcreteObserver методы Attach и Detach будут содержать единственный оператор: <code>subj.OnNotify += Update</code> и <code>subj.OnNotify -= Update</code> соответственно.</p>
<pre class="pt">public abstract class Subject
{
    public abstract void Attach(Observer observ);
    public abstract void Detach(Observer observ);
    public abstract void Notify();
}

// Implement the ConcreteSubject descendant class

public abstract class Observer
{
    public abstract void Update();
}

// Implement the ConcreteObserver descendant class</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav2°</span>. <b>Observer</b> (<b>Наблюдатель</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 2</span>. Реализовать вариант взаимодействия субъектов и наблюдателей, не требующий специальных методов доступа к состоянию субъекта и упрощающий взаимодействие наблюдателя с <i>несколькими</i> субъектами. </p><p class="ptTaskContinue">Первая иерархия классов включает абстрактный класс Subject с абстрактными методами Attach(observ), Detach(observ), SetInfo(info) и класс-потомок ConcreteSubject. Методы Attach и Detach имеют параметр-ссылку типа Observer и не возвращают значений. Метод SetInfo имеет строковый параметр и также не возвращает значения. В классе ConcreteSubject дополнительно описать поле observers&nbsp;&#8212; структуру с элементами-ссылками типа Observer, в которой хранятся все наблюдатели, присоединенные в настоящий момент к субъекту (можно считать, что наблюдателей не более&nbsp;10). В качестве такой структуры удобно использовать динамическую структуру, имеющую команды для добавления и удаления элементов. Метод Attach(observ) добавляет объект observ в структуру observers, метод Detach(observ) удаляет объект observ из данной структуры. В методе SetInfo(info) выполняется перебор элементов структуры observers и для каждого элемента этой структуры вызывается его метод OnInfo(sender, info), причем в качестве параметра info указывается параметр метода SetInfo, а в качестве параметра sender&nbsp;&#8212; ссылка на объект ConcreteSubject, вызвавший метод SetInfo. Таким образом, наблюдатель сразу информируется и о наступившем событии, и о субъекте, который инициировал это событие. При реализации метода SetInfo необходимо учесть ситуацию, когда некоторые наблюдатели в своем методе OnInfo отсоединятся от субъекта, что приведет к изменению структуры observers. </p><p class="ptTaskContinue">Вторая иерархия включает абстрактный класс Observer с абстрактным методом OnInfo(sender, info) и класс-потомок ConcreteObserver. Параметр sender метода OnInfo является ссылкой на объект типа Subject, параметр info&nbsp;&#8212; строковый. Класс ConcreteObserver дополнительно имеет строковое поле log и символьное поле detachInfo, а также методы Attach, Detach и GetLog. Конструктор класса ConcreteObserver имеет параметр detachInfo, который инициализирует соответствующее поле; поле log инициализируется пустой строкой. Методы Attach(subj) и Detach(subj) имеют параметр-ссылку типа Subject и не возвращают значений. В методе Attach выполняется вызов метода Attach объекта subj, в методе Detach выполняется вызов метода Detach объекта subj, причем в качестве параметра в обоих вызываемых методах передается ссылка на объект ConcreteObserver, из которого вызваны эти методы. Метод GetLog не имеет параметров и возвращает значение поля log. </p><p class="ptTaskContinue">Метод OnInfo(sender, info), переопределяемый в классе ConcreteObserver, является основным методом, обеспечивающим взаимодействие между конкретным субъектом и конкретным наблюдателем. Напомним, что этот метод вызывается конкретным субъектом для информирования всех присоединенных к нему в настоящий момент наблюдателей, причем информация передается в поле info, а поле sender содержит ссылку на субъект, передавший эту информацию. В данном задании в методе OnInfo надо выполнить следующие действия: добавить содержимое параметра info в конец строки log объекта ConcreteObserver, для которого был вызван метод OnInfo, и, кроме того, если <i>последний</i> символ строки info совпадает со значением поля detachInfo объекта ConcreteObserver, то необходимо отсоединить этого наблюдателя от субъекта sender, вызвав метод Detach объекта ConcreteObserver с параметром sender. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;10). Кроме того, дано целое число&nbsp;K (&#8804;&nbsp;30) и набор различных двухсимвольных строк, первым символом которых является цифра &#34;1&#34; или &#34;2&#34;, а вторым&nbsp;&#8212; строчная латинская буква. Создать два объекта subj1 и subj2 типа ConcreteSubject и набор observers из N&nbsp;объектов типа ConcreteObserver, указывая в качестве параметра detachInfo конструктора объектов ConcreteObserver строчные латинские буквы, которые перебираются в алфавитном порядке (&#34;a&#34; для первого объекта ConcreteObserver, &#34;b&#34; для второго объекта и т.&nbsp;д.). Для каждого объекта ConcreteObserver вызвать методы Attach с параметрами-ссылками на объекты subj1 и subj2. Затем для каждой строки из данного набора строк вызвать метод SetInfo SetInfo объекта subj1 или subj2, передав эту строку в качестве параметра, причем если строка начинается с цифры &#34;1&#34;, то метод SetInfo должен вызываться для объекта subj1, а если с цифры &#34;2&#34;, то для объекта subj2. После обработки всех строк из исходного набора вывести значения полей log объектов из набора observ, используя метод GetLog класса ConcreteObserver (выведенные строки должны содержать все данные, переданные наблюдателям субъектами subj1 и subj2, вплоть до тех данных, которые вызвали отсоединение наблюдателя от соответствующего субъекта). </p><p class="ptTaskContinue"><span class="ptSpecial">Примечание.</span> Описанный вариант взаимодействия субъектов и наблюдателей можно реализовать с помощью <i>делегаты</i> и <i>события</i> (см. примечание к заданию OOP3Behav1).</p>
<pre class="pt">public abstract class Subject
{
    public abstract void Attach(Observer observ);
    public abstract void Detach(Observer observ);
    public abstract void SetInfo(string info);
}

// Implement the ConcreteSubject descendant class

public abstract class Observer
{
    public abstract void OnInfo(Subject sender, string info);
}

// Implement the ConcreteObserver descendant class</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav3°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPStrategy.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPStrategy.png" border=1></p><p class="ptTaskContinue"><b>Strategy</b> (<b>Стратегия</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue">Известен также под именем <b>Policy</b> (<b>Политика</b>). </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: выше средней. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. Стратегия позволяет заменять алгоритмы для любого клиента (&#34;контекста&#34;) на этапе выполнения. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Strategy</i> (<i>Стратегия</i>)&nbsp;&#8212; объявляет общий для всех поддерживаемых алгоритмов интерфейс; класс Context пользуется этим интерфейсом для вызова конкретного алгоритма, определенного в одном из классов ConcreteStrategy; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteStrategyA</i>, <i>ConcreteStrategyB</i>, <i>ConcreteStrategyC</i> (<i>Конкретные</i> <i>стратегии</i>)&nbsp;&#8212; реализуют алгоритм, используя интерфейс, объявленный в классе Strategy; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Context</i> (<i>Контекст</i>)&nbsp;&#8212; конфигурируется объектом класса ConcreteStrategy; хранит ссылку на объект класса Strategy; может определять интерфейс, который позволяет объекту Strategy получить доступ к данным контекста. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать две иерархии классов. Первая иерархия включает абстрактный класс Strategy с абстрактным методом Algorithm(info) (метод имеет строковый параметр info и возвращает строковое значение) и конкретные классы ConcreteStrategyA, ConcreteStrategyB и ConcreteStrategyC&nbsp;&#8212; потомки класса Strategy. Конкретные классы имеют конструкторы без параметров, не выполняющие дополнительных действий. Метод Algorithm(info) конкретных классов A, B, C возвращает строку, полученную из строки info добавлением справа символа &#34;A&#34;, &#34;B&#34;, &#34;C&#34; соответственно. </p><p class="ptTaskContinue">Вторая иерархия включает абстрактный класс Context и конкретные классы Context1 и Context2&nbsp;&#8212; потомки класса Context. Класс Context содержит поле st&nbsp;&#8212; ссылку на объект типа Strategy&nbsp;&#8212; и методы SetStrategy(st) (с параметром-ссылкой st типа Strategy) и RunAlgorithm (без параметров, возвращает строковое значение). Метод SetStrategy класса Context присваивает свой параметр полю st, метод RunAlgorithm является абстрактным. Классы Context1 и Context2 переопределяют метод RunAlgorithm, вызывая в нем метод Algorithm для поля st, причем в качестве параметра info указывается строка &#34;1&#34; (для класса Context1) или &#34;2&#34; (для класса Context2); метод RunAlgorithm возвращает строку, возвращаемую методом Algorithm. Конструкторы классов Context1 и Context2 не имеют параметров; в них создается объект типа ConcreteStrategyA (для класса Context1) или ConcreteStrategyB (для класса Context2) и поле st инициализируется ссылкой на созданный объект. </p><p class="ptTaskContinue">Дана строка S, состоящая из символов &#34;1&#34; и &#34;2&#34;; ее длина не превосходит&nbsp;15. Также дано целое число&nbsp;K, не превосходящее длины строки&nbsp;S, и набор ind из K&nbsp;различных целых чисел, определяющих индексы символов в строке&nbsp;S (символы индексируются от&nbsp;0). Создать набор ctxt объектов-ссылок типа Context (можно использовать массив или другую структуру данных); размер набора равен длине строки&nbsp;S, фактический тип каждого элемента набора определяется соответствующим символом строки&nbsp;S: это Context1 для символа &#34;1&#34; и Context2 для символа &#34;2&#34;. Для элементов набора ctxt, индексы которых входят в исходный набор ind, вызвать метод SetStrategy, передав в качестве параметра объект типа ConcreteStrategyC. Перебирая все объекты набора ctxt в исходном порядке, вызвать для них метод RunAlgorithm и вывести его возвращаемое значение. </p><pre class="pt">public abstract class Strategy
{
    public abstract string Algorithm(string info);
}

// Implement the ConcreteStrategyA, ConcreteStrategyB
//   and ConcreteStrategyC descendant classes

public abstract class Context
{
    protected Strategy st;
    public void SetStrategy(Strategy st)
    {
        this.st = st;
    }
    public abstract string RunAlgorithm();
}

// Implement the Context1 and Context2 descendant classes</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav4°</span>. <b>Strategy</b> (<b>Стратегия</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 2</span>. Реализовать иерархию классов-<i>валидаторов</i>, включающую класс Validator и его классы-потомки EmptyValidator, NumberValidator и RangeValidator. Классы-валидаторы предназначены для проверки правильности введенных строковых данных. Классы Validator, EmptyValidator и NumberValidator не имеют полей, их конструкторы не имеют параметров и не выполняют дополнительных действий. В классе Validator определен метод Validate(s), имеющий строковый параметр s и возвращающий строку с описанием ошибки, обнаруженной в строке s. Метод Validate класса Validator всегда возвращает пустую строку; таким образом, класс Validator считает допустимой любую строку. </p><p class="ptTaskContinue">Для класса EmptyValidator метод Validate(s) возвращает пустую строку, если параметр s не является пустой строкой; в противном случае он возвращает строку &#34;!Empty text&#34;. </p><p class="ptTaskContinue">Для класса NumberValidator метод Validate(s) возвращает пустую строку, если параметр s содержит строковое представление некоторого целого числа; в противном случае он возвращает строку вида &#34;!'&lt;s&gt;': not a number&#34;, где в позиции &lt;s&gt; указывается содержимое параметра&nbsp;s. </p><p class="ptTaskContinue">Класс RangeValidator содержит целочисленные поля min и max; его конструктор имеет целочисленные параметры a и b, инициализирующие поля таким образом, чтобы поле min было равно минимальному из чисел a и b, а поле max&nbsp;&#8212; максимальному из этих чисел. Для класса RangeValidator метод Validate(s) возвращает пустую строку, если параметр s содержит строковое представление некоторого целого числа и при этом данное число лежит в диапазоне от min до max включительно; в противном случае метод возвращает строку вида &#34;!'&lt;s&gt;': not in range &lt;min&gt;..&lt;max&gt;&#34;, где в позиции &lt;s&gt; указывается содержимое параметра s, а в позициях &lt;min&gt; и &lt;max&gt;&nbsp;&#8212; значения соответствующих полей. </p><p class="ptTaskContinue">Реализовать класс TextBox, содержащий строковое поле text и поле v&nbsp;&#8212; ссылку на объект типа Validator. Конструктор класса не имеет параметров, в нем создается объект типа Validator и ссылка на него присваивается полю v, а поле text инициализируется пустой строкой. Класс TextBox включает три метода: SetText(text)&nbsp;&#8212; задает или изменяет поле text; SetValidator(v)&nbsp;&#8212; изменяет поле v; Validate (без параметров)&nbsp;&#8212; вызывает для объекта v метод Validate с параметром text и возвращает значение, возвращенное этим методом. </p><p class="ptTaskContinue">Также реализовать класс TextForm. Он содержит набор tb элементов типа TextBox (можно использовать массив или другую структуру данных). Конструктор класса TextForm имеет параметр n, определяющий размер набора tb (можно считать, что параметр n не превосходит&nbsp;10); в конструкторе создаются все элементы набора tb. Класс TextForm включает три метода: SetText(ind, text)&nbsp;&#8212; задает или изменяет поле text для элемента набора tb с индексом ind; SetValidator(ind, v)&nbsp;&#8212; изменяет поле&nbsp;v для элемента набора tb с индексом ind; Validate (без параметров)&nbsp;&#8212; последовательно вызывает методы Validate для всех элементов набора tb и возвращает строку, полученную объединением строк, возвращенных этими методами. При реализации методов SetText и SetValidator можно считать, что параметр ind всегда лежит в допустимом диапазоне (от&nbsp;0 до n&nbsp;&#8722;&nbsp;1, где n&nbsp;&#8212; размер набора&nbsp;tb). </p><p class="ptTaskContinue">Даны три целых числа&nbsp;N, A,&nbsp;B, причем&nbsp;N лежит в диапазоне от&nbsp;1 до&nbsp;10. Также дано целое число&nbsp;K, не превосходящее&nbsp;N, и набор из K пар (ind, val), где ind является целым числом в диапазоне от&nbsp;0 до N&nbsp;&#8722;&nbsp;1, а val является одним из символов &#34;E&#34;, &#34;N&#34;, &#34;R&#34;. Все значения ind являются различными. Кроме того, дано пять наборов строк, каждый из которых содержит по N элементов. </p><p class="ptTaskContinue">Создать объект tf типа TextForm, вызвав его конструктор с параметром&nbsp;N. Для каждой пары (ind, val) вызвать метод SetValidator объекта tf с первым параметром ind и вторым параметром&nbsp;&#8212; ссылкой на объект-валидатор, тип которого соответствует символу val: &#34;E&#34;&nbsp;&#8212; EmptyValidator, &#34;N&#34;&nbsp;&#8212; NumberValidator, &#34;R&#34;&nbsp;&#8212; RangeValidator; для объекта RangeValidator использовать конструктор с параметрами&nbsp;A и&nbsp;B, где&nbsp;A и&nbsp;B&nbsp;&#8212; ранее указанные числа. Для каждого из пяти данных наборов строк выполнить следующие действия: добавить набор строк в объект tf (вызвав требуемое число раз метод SetText объекта tf) и проверить правильность этого набора строк (вызвав метод Validate объекта tf и выведя его результат). </p><pre class="pt">public class Validator
{
    public virtual string Validate(string s)
    {
        return &quot;&quot;;
    }
}

// Implement the EmptyValidator, NumberValidator
//   and RangeValidator descendant classes

// Implement the TextBox and TextForm classes</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav5°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPTemplateMethod.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPTemplateMethod.png" border=1></p><p class="ptTaskContinue"><b>Template Method</b> (<b>Шаблонный метод</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: средняя. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: определяет основу алгоритма и позволяет подклассам определить (или переопределить) некоторые шаги алгоритма, не изменяя его структуру в целом. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>AbstractClass</i> (<i>Абстрактный класс</i>)&nbsp;&#8212; определяет абстрактные примитивные операции, замещаемые в конкретных подклассах для реализации шагов алгоритма; реализует шаблонный метод, определяющий последовательность действий алгоритма (шаблонный метод вызывает примитивные операции, а также операции, определенные в классе AbstractClass или в других объектах); </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteClass</i> (<i>Конкретный класс</i>)&nbsp;&#8212; реализует примитивные операции, выполняющие шаги алгоритма способом, который зависит от подкласса. </p><p class="ptTaskContinue">Помимо абстрактных примитивных операций шаблонного метода, которые <i>необходимо</i> переопределить в конкретных классах, шаблонный метод может включать операции-<i>перехватчики</i> (hooks), которые могут быть переопределены в конкретных класса, а могут быть оставлены без изменения. Использование шаблонного метода позволяет избавиться от избыточного кода в подклассах. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать иерархию классов, связанную с формированием рецептов приготовления напитков и включающую абстрактный класс AbstractClass и четыре его потомка: ConcreteClass1, ConcreteClass2 (непосредственные потомки абстрактного класса), ConcreteClass3 (потомок ConcreteClass1) и ConcreteClass4 (потомок ConcreteClass2). В абстрактном классе реализовать шаблонный метод TemplateMethod, формирующий и возвращающий строковое значение. Это значение получается путем последовательного добавления к результирующей строке значений, возвращаемых методами BasicOperation1, PrimitiveOperation, BasicOperation2 и HookOperation. Метод PrimitiveOperation является абстрактным методом, остальные методы имеют реализацию: метод BasicOperation1 возвращает строку &#34;Boil water&#34; (вскипятить воду), метод BasicOperation2 возвращает строку &#34;=Pour into a cup&#34; (налить в чашку), метод HookOperation возвращает пустую строку, причем данный метод является защищенным. </p><p class="ptTaskContinue">В классе ConcreteClass1 реализовать метод PrimitiveOperation, возвращающий строку &#34;=Brew tea&#34; (заварить чай), в классе ConcreteClass2 реализовать этот же метод, возвращающий строку &#34;=Brew coffee&#34; (заварить кофе). В классе ConcreteClass3 переопределить метод HookOperation таким образом, чтобы он возвращал строку &#34;=Add sugar and lemon&#34; (добавить сахар и лимон), в классе ConcreteClass4 переопределить этот же метод так, чтобы он возвращал строку &#34;=Add sugar and milk&#34; (добавить сахар и молоко). Конструкторы всех конкретных классов не имеют параметров и не выполняют дополнительных действий. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;10) и набор из N целых чисел, принимающих значения от&nbsp;1 до&nbsp;4. Создать структуру (например, массив) из N элементов-ссылок типа AbstractClass и инициализировать ее элементы экземплярами конкретных классов в зависимости от значений соответствующих чисел исходного набора (если число равно&nbsp;1, то создается экземпляр класса ConcreteClass1, если число равно&nbsp;2, то создается экземпляр класса ConcreteClass2 и т.&nbsp;д.). Перебирая элементы созданной структуры <i>в обратном порядке</i>, вызвать для каждого из них метод TemplateMethod и вывести возвращенную им строку. </p><pre class="pt">public abstract class AbstractClass
{
    public abstract string PrimitiveOperation();
    // Implement methods TemplateMethod,
    // BasicOperation1, BasicOperation2 and HookOperation
}

// Implement the ConcreteClass1, ConcreteClass2, ConcreteClass3
//   and ConcreteClass4 descendant classes</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav6°</span>. <b>Template Method</b> (<b>Шаблонный метод</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 2</span>. Реализовать иерархию классов, связанную с поиском минимальных и максимальных элементов в наборе данных и включающую абстрактный класс AbstractComparable и три его потомка: NumberComparable, LengthComparable и TextComparable. В абстрактном классе реализованы четыре <i>статических</i> шаблонных метода IndexMax, LastIndexMax, IndexMin, LastIndexMin. Параметром каждого метода является набор comp объектов-ссылок типа AbstractComparable; (массив или другая структура данных); методы возвращают целое число&nbsp;&#8212; индекс первого наибольшего, последнего наибольшего, первого наименьшего и последнего наименьшего элемента набора comp соответственно (индексирование производится от нуля). В шаблонных методах используется абстрактный метод CompareTo(other) с параметром-ссылкой other типа AbstractComparable. Этот метод позволяет сравнивать между собой экземпляры a и b одного и того же класса&nbsp;&#8212; потомка класса AbstractComparable: вызов Comparable(b) для объекта a возвращает отрицательное значение, если a &#34;меньше&#34;, чем b; нулевое значение, если a &#34;равно&#34; b; положительное значение, если a &#34;больше&#34;, чем b (слова &#34;меньше&#34;, &#34;равно&#34; и &#34;больше&#34; взяты в кавычки, так как смысл сравнений может быть различным для разных потомков класса AbstractComparable). </p><p class="ptTaskContinue">Каждый из конкретных классов имеет конструктор со строковым параметром data, который определяет значение поля key. Для класса NumberComparable поле key имеет целый тип; если параметр data является строковым представлением некоторого целого числа, то в поле key записывается это число, если параметр data не удовлетворяет указанному условию, то поле key полагается равным&nbsp;0. Для класса LengthComparable поле key также имеет целый тип и полагается равным длине строки data. Для класса TextComparable поле key имеет строковый тип и полагается равным самой строке data. </p><p class="ptTaskContinue">Реализовать в классах-потомках метод CompareTo(other) в котором параметр other преобразуется к типу данного класса-потомка, после чего поля key объекта, вызвавшего метод, и объекта other сравниваются между собой; если поле key объекта, вызвавшего метод, меньше, равно или больше поля key объекта other, то метод возвращает соответственно отрицательное, нулевое или положительное значение (для класса TextComparable строковые поля key сравниваются лексикографически). Не требуется особым образом обрабатывать ситуацию, когда параметр other не может быть преобразован к нужному типу, поскольку она не будет возникать при обработке правильно сформированных наборов данных. </p><p class="ptTaskContinue">Даны целые числа N (&#8804;&nbsp;9), K (&#8804;&nbsp;7), а также K наборов из N&nbsp;+&nbsp;1 строки, причем начальная строка в каждом наборе имеет вид &#34;N&#34;, &#34;L&#34; или &#34;T&#34;. Описать структуру comp из N элементов-ссылок типа AbstractComparable (тип структуры должен совпадать с типом параметра шаблонных методов) и использовать эту структуру для обработки <i>каждого</i> исходного набора строк следующим образом: </p><p class="ptTaskContinue">(1)&nbsp;создать и записать в структуру comp объекты типа, определяемого начальной строкой обрабатываемого набора: если начальная строка равна &#34;N&#34;, &#34;L&#34; или &#34;T&#34;, то создаются объекты типа NumberComparable, LengthComparable или TextComparable соответственно; строки исходного набора указываются в качестве параметров конструкторов объектов, для начальной строки объект не создается; </p><p class="ptTaskContinue">(2)&nbsp;вызвать шаблонные методы IndexMax, LastIndexMax, IndexMin, LastIndexMin с параметром comp и вывести их возвращаемые значения в указанном порядке. </p><pre class="pt">public abstract class AbstractComparable
{
    public abstract int CompareTo(AbstractComparable other);

    // Implement the IndexMax, LastIndexMax, IndexMin
    //   and LastIndexMin static methods
}

// Implement the NumberComparable, LengthComparable
//   and TextComparable descendant classes</pre>
<h2>Iterator, Command, State</h2>
<p class="ptTask"><span class="ptSpecial">OOP3Behav7°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPIterator.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPIterator.png" border=1></p><p class="ptTaskContinue"><b>Iterator</b> (<b>Итератор</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue">Известен также под именем <b>Cursor</b> (<b>Курсор</b>). </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: высокая. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: предоставляет способ последовательного доступа ко всем элементам составного объекта, не раскрывая его внутреннего представления. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Iterator</i> (<i>Итератор</i>)&nbsp;&#8212; определяет интерфейс для доступа и обхода элементов; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteIterator</i> (<i>Конкретный итератор</i>)&nbsp;&#8212; реализует интерфейс класса Iterator; следит за текущей позицией при обходе агрегата; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Aggregate</i> (<i>Агрегат</i>)&nbsp;&#8212; определяет интерфейс для создания объекта-итератора; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteAggregate</i> (<i>Конкретный агрегат</i>)&nbsp;&#8212; реализует интерфейс создания итератора и возвращает экземпляр подходящего класса ConcreteIterator. </p><p class="ptTaskContinue">Во многих современных языках программирования итераторы реализованы в стандартных библиотеках или даже на уровне языковых конструкций. Данное задание можно выполнять, используя либо базовые средства ООП, либо специализированные средства выбранного языка. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать две иерархии классов, связанные с применением паттерна Iterator. Первая иерархия является иерархией классов-<i>агрегатов</i> и включает абстрактный класс Aggregate, содержащий абстрактный метод CreateIterator (не имеет параметров, возвращает ссылку на объект Iterator), и классы ConcreteAggregateA, ConcreteAggregateB и ConcreteAggregateC. Каждый из конкретных классов содержит поле data; для класса ConcreteAggregateA оно целочисленное, для класса ConcreteAggregateB оно строковое, для класса ConcreteAggregateC оно представляет собой структуру с целочисленными элементами (например, массив; можно считать, что число элементов структуры не превосходит&nbsp;10). Поле data инициализируется в конструкторе класса с помощью параметра data того же типа, что и инициализируемое поле. Конкретные классы-агрегаты&nbsp;A,&nbsp;B и&nbsp;C реализуют метод CreateIterator возвращающий итератор, тип которого определяется типом класса-агрегата: для агрегата&nbsp;A это ConcreteIteratorA, для агрегата&nbsp;B&nbsp;&#8212; ConcreteIteratorB, для агрегата&nbsp;C&nbsp;&#8212; ConcreteIteratorC. При создании итератора в методе CreateIterator конструктору итератора передается параметр, являющийся ссылкой на объект-агрегат, вызвавший метод CreateIterator. Классы-агрегаты также имеют метод GetData без параметров, возвращающий поле data. </p><p class="ptTaskContinue">Вторая иерархия является иерархией классов-<i>итераторов</i>; она включает абстрактный класс Iterator и классы ConcreteIteratorA, ConcreteIteratorB и ConcreteIteratorC. Класс Iterator содержит четыре абстрактных метода без параметров: First и Next (не возвращают значений), IsDone (возвращает логическое значение), CurrentItem (возвращает целочисленное значение). </p><p class="ptTaskContinue">Метод First устанавливает итератор на первый элемент перебираемого набора данных, метод Next переводит итератор на следующий элемент (или за конец набора), метод IsDone возвращает значение true, если итератор указывает на позицию за концом набора, и false, если итератор указывает на некоторый элемент набора; метод CurrentItem возвращает элемент набора, на который указывает итератор, или&nbsp;&#8722;1, если итератор находится за последним элементом набора (возможен также вариант, когда в последней ситуации возбуждается исключение, поскольку в программе такая ситуация обычно свидетельствует об ошибке). Для пустого набора метод First сразу устанавливает итератор за конец набора; при нахождении итератора за концом набора метод Next не выполняет никаких действий. </p><p class="ptTaskContinue">Конкретные классы-итераторы&nbsp;A, B,&nbsp;C связаны с ранее описанными классами-агрегатами&nbsp;A, B,&nbsp;C и обеспечивают особый способ перебора содержащихся в них данных. Итератор&nbsp;A перебирает все <i>цифры</i> целочисленного поля data агрегата A <i>в обратном порядке</i> (знак числа игнорируется); для числа&nbsp;0 возвращается цифра 0 (это единственная ситуация, когда последним элементом набора является цифра&nbsp;0). Итератор&nbsp;B перебирает все <i>цифровые символы</i> строкового поля data агрегата B <i>в обратном порядке</i>. Итератор C перебирает все цифры всех элементов структуры data агрегата C, причем как сами элементы, так и их цифры должны перебираться <i>в обратном порядке</i>. Для итераторов&nbsp;B и&nbsp;C возможна ситуация, когда перебираемый набор является пустым (если строковое поле data не содержит цифровых символов или структура data не содержит ни одного элемента). Каждый конкретный итератор содержит поле aggr, которое является ссылкой на связанный с ним объект-агрегат; это поле инициализируется в конструкторе итератора с помощью соответствующего параметра. Кроме того, итераторы содержат вспомогательные поля, используемые при реализации методов First, Next, IsDone и CurrentItem. </p><p class="ptTaskContinue">Дано целое число&nbsp;N (&#8804;&nbsp;10) и N&nbsp;наборов элементов. Первый элемент каждого набора представляет собой символ &#34;A&#34;, &#34;B&#34; или &#34;C&#34;; он определяет тип создаваемого объекта-агрегата (A,&nbsp;B или&nbsp;C). Следующие элементы каждого набора определяют поле data создаваемого агрегата: для агрегата&nbsp;A это одно целое число, для агрегата&nbsp;B&nbsp;&#8212; одна строка, для агрегата&nbsp;C&nbsp;&#8212; целое число&nbsp;K (&#8804;&nbsp;10), определяющее размер структуры данных data, и К&nbsp;целых чисел&nbsp;&#8212; элементов этой структуры (число K может быть равно&nbsp;0). </p><p class="ptTaskContinue">Описать структуру (например, массив) из N&nbsp;элементов-ссылок типа Aggregate, сохранить в ней исходные объекты-агрегаты и выполнить обработку этих объектов, перебирая их <i>в обратном порядке</i>. Для каждого объекта-агрегата требуется вывести сумму цифр, возвращаемых его итератором (или&nbsp;0, если итератор ничего не возвращает), а затем&nbsp;&#8212; сами цифры, возвращаемые его итератором. </p><p class="ptTaskContinue"><span class="ptSpecial">Примечание</span>. В языках с С-подобным синтаксисом для перебора элементов с применением итератора it, имеющего описанный выше набор методов, можно использовать следующий вариант цикла for: <tt>for (it.First(); !it.IsDone(); it.Next()) &lt;обработка it.CurrentItem()&gt;</tt> </p><pre class="pt">public abstract class Aggregate
{
    public abstract Iterator CreateIterator();
}

// Implement the ConcreteAggregateA, ConcreteAggregateB
//   and ConcreteAggregateC descendant classes

public abstract class Iterator
{
    public abstract void First();
    public abstract void Next();
    public abstract bool IsDone();
    public abstract int CurrentItem();
}

// Implement the ConcreteIteratorA, ConcreteIteratorB
//   and ConcreteIteratorC descendant classes</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav8°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPCommand.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPCommand.png" border=1></p><p class="ptTaskContinue"><b>Command</b> (<b>Команда</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue">Известен также под именем <b>Action</b> (<b>Действие</b>), <b>Transaction</b> (<b>Транзакция</b>). </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: выше средней. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: инкапсулирует запрос (действие, операцию) как объект, позволяя тем самым задавать параметры клиентов для обработки соответствующих запросов, ставить запросы в очередь или протоколировать их, а также поддерживать отмену операций. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Command</i> (<i>Команда</i>)&nbsp;&#8212; объявляет интерфейс для выполнения запроса; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteCommand</i> (<i>Конкретная команда</i>)&nbsp;&#8212; определяет связь между объектом-получателем Receiver и требуемым запросом; реализует метод Execute путем вызова требуемых методов объекта Receiver; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Client</i> (<i>Клиент</i>)&nbsp;&#8212; создает объект класса ConcreteCommand и задает его получателя; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Invoker</i> (<i>Инициатор</i>)&nbsp;&#8212; обращается к команде для выполнения запроса; не использует никакой информации о конкретном получателе запроса; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Receiver</i> (<i>Получатель</i>)&nbsp;&#8212; располагает информацией об операциях, необходимых для выполнения запроса; в роли получателя может выступать любой класс. </p><p class="ptTaskContinue">Основной особенностью паттерна Command является то, что он отделяет объект-инициатор Invoker, выдающий запросы, от объекта-получателя Receiver, который умеет эти запросы выполнять. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать классы, связанные с организацией запросов на основе паттерна Command. Иерархия классов-<i>команд</i> включает абстрактный класс Command с абстрактным методом Execute (который не имеет параметров и ничего не возвращает) и классы ConcreteCommandA и ConcreteCommandB, связанные с конкретными командами A и B. Классы ConcreteCommandA и ConcreteCommandB включают поле recv, определяющее получателя соответствующей команды; это поле является ссылкой на объект класса ReceiverA для команды A и ссылкой на объект класса ReceiverB для команды B; поле recv определяется в конструкторе конкретной команды, имеющем параметр recv соответствующего типа. Метод Execute конкретной команды A вызывает метод ActionA для объекта recv (типа ReceiverA), метод Execute конкретной команды B вызывает метод ActionB для объекта recv (типа ReceiverB). </p><p class="ptTaskContinue">Классы-<i>получатели</i> ReceiverA и ReceiverB содержат поле cli&nbsp;&#8212; ссылку на объект класса Client и поле info строкового типа; эти поля инициализируются в конструкторе, имеющем одноименные параметры cli и info. Метод ActionA класса ReceiverA вызывает метод AddLeft(info) объекта cli; метод ActionB класса ReceiverB вызывает метод AllRight(info) объекта cli. Следует подчеркнуть, что классы-получатели не входят в какую-либо особую иерархию, и каждый из них реализует свой собственный набор методов. </p><p class="ptTaskContinue">Класс-<i>клиент</i> Client содержит строковое поле info, которое инициализируется пустой строкой в конструкторе (конструктор не имеет параметров). Класс Client также содержит три метода: AddLeft(newInfo), AddRight(newInfo) и GetInfo. Методы AddLeft и AddRight имеют строковый параметр newInfo и добавляют строку newInfo соответственно в начало и конец поля info; эти методы ничего не возвращают. Метод GetInfo без параметров возвращает значение поля info. </p><p class="ptTaskContinue">Класс-<i>инициатор</i> Invoker предназначен для выполнения связанной с ним команды. Он содержит поле cmd&nbsp;&#8212; ссылку на объект типа Command, которая инициализируется в конструкторе с одноименным параметром cmd, а также метод Invoke, в котором выполняется вызов метода Execute команды cmd. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;10), задающее количество различных команд, и набор S из N различных строк, каждая из которых начинается либо с символа &#34;A&#34;, либо с символа &#34;B&#34;. Создать объект cli типа Client и набор cmd из N команд (например, массив) с элементами-ссылками типа Command. Каждый элемент набора cmd является либо командой ConcreteCommandA (если соответствующая строка набора S начинается с символа &#34;A&#34;), либо командой ConcreteCommandB (если соответствующая строка набора S начинается с символа &#34;B&#34;); при создании команд A и B используются объекты типа ReceiverA или ReceiverB соответственно, которые, в свою очередь, создаются с помощью конструкторов, имеющих  следующие параметры: ранее созданный объект cli типа Client и соответствующая строка из набора S. Например, если очередной строкой набора S является строка &#34;Apqr&#34;, то соответствующим элементом набора cmd должен быть объект ConcreteCommandA, причем его конструктору должен передаваться объект ReceiverA, в конструкторе которого указываются параметры cli и &#34;Apqr&#34;. </p><p class="ptTaskContinue">Также дано целое число K (&#8804;&nbsp;30), задающее количество различных инициаторов (объектов типа Invoker), и набор из K целых чисел со значениями из диапазона от 0 до N&nbsp;&#8722;&nbsp;1 (каждый элемент набора определяет <i>индекс</i> некоторой команды из набора cmd). Создать набор inv из K инициаторов (например, массив) с элементами-ссылками типа Invoker и инициализировать каждого инициатора командой с соответствующим индексом из набора cmd (например, если начальным элементом набора из K целых чисел является число 5, то начальный инициатор inv[0] должен инициализироваться командой cmd[5]). Несколько инициаторов может быть связано с одной и той же командой (что является стандартной ситуацией при организации пользовательского интерфейса, когда одну и ту же команду можно выполнить, например, с помощью пункта меню, кнопки быстрого доступа или горячей клавиши). </p><p class="ptTaskContinue">Наконец, дано целое число M (&#8804;&nbsp;20), задающее количество команд для выполнения, и набор из M целых чисел со значениями из диапазона от 0 до K&nbsp;&#8722;&nbsp;1 (каждый элемент набора определяет <i>индекс</i> того инициатора из набора inv, который должен использоваться для выполнения требуемой команды). Выполнить требуемые команды, вызвав метод Invoke для элементов набора inv с указанными индексами. После выполнения каждой команды выводить текущее состояние объекта cli, используя его метод GetInfo. </p><pre class="pt">// Implement the Client, ReceiverA and ReceiverB classes

public abstract class Command
{
    public abstract void Execute();
}

// Implement the ConcreteCommandA
//   and ConcreteCommandB descendant classes

public class Invoker
{
    Command cmd;
    public Invoker(Command cmd)
    {
        this.cmd = cmd;
    }
    public void Invoke()
    {
        cmd.Execute();
    }
}</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav9°</span>. <b>Command</b> (<b>Команда</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 2</span>. Реализовать набор классов для варианта паттерна Command с дополнительными возможностями, связанными с <i>созданием макрокоманд</i> и <i>отменой предыдущих действий</i>. </p><p class="ptTaskContinue">Имеются три класса-<i>получателя</i>, реализующих различные операции и умеющих отменять их: класс OperationA включает статические методы ActionA (выводит строку &#34;+A&#34;) и UndoActionA (выводит строку &#34;&#8722;A&#34;), класс OperationB включает статические методы ActionB (выводит строку &#34;+B&#34;) и UndoActionB (выводит строку &#34;&#8722;B&#34;), класс OperationC включает статические методы ActionC (выводит строку &#34;+C&#34;) и UndoActionC (выводит строку &#34;&#8722;C&#34;). Других методов или полей классы-получатели не содержат. Следует подчеркнуть, что эти классы не входят в какую-либо особую иерархию. </p><p class="ptTaskContinue">Иерархия классов-<i>команд</i> начинается с абстрактного класса Command, включающего методы Execute и Unexecute (методы не имеют параметров и не возвращают значений). Его потомками являются классы CommandA, CommandB, CommandC и MacroCommand. Конструкторы классов CommandA, CommandB, CommandC не имеют параметров и не выполняют дополнительных действий. Метод Execute команды A выполняет вызов статического метода ActionA класса-получателя OperationA, метод Unexecute команды A выполняет вызов статического метода UndoActionA. Методы Execute и Unexecute команд B и C определяются аналогично, с использованием статических методов классов OperationB и OperationC. </p><p class="ptTaskContinue">Класс MacroCommand позволяет объединять имеющиеся команды в последовательности команд (<i>макрокоманды</i>). Он содержит структуру cmds (например, массив) с элементами-ссылками типа Command, которая инициализируется в конструкторе, имеющем соответствующий параметр-структуру (можно считать, что макрокоманда содержит не более 5&nbsp;команд). Метод Execute класса MacroCommand выполняет вызов методов Execute всех элементов структуры cmds в исходном порядке, а метод Unexecute&nbsp;&#8212; вызов методов Unexecute всех элементов структуры cmds в обратном порядке. </p><p class="ptTaskContinue">Реализовать класс Menu, предоставляющий средства для настройки <i>инициаторов</i> команд, их выполнения, а также выполнения операций отмены и восстановления. Класс Menu содержит две структуры: массив availCmds размера&nbsp;3, в котором хранятся ссылки на команды, <i>доступные для выполнения</i>, и структуру lastCmds, в котором хранятся ссылки на <i>ранее выполненные команды</i>, что дает возможность <i>отменять</i> эти команды или, после отмены, <i>восстанавливать</i> их. В качестве структуры lastCmds удобно использовать динамическую структуру, позволяющую добавлять в конец новые элементы и удалять часть последних элементов. Можно считать, что структура lastCmds в любой момент времени будет содержать не более 40&nbsp;элементов. Со структурой lastCmds связано дополнительное целочисленное поле undoIndex, определяющее индекс элемента из lastCmd, после которого следуют <i>ранее отмененные</i> команды (которые впоследствии могут быть восстановлены). Конструктор класса Menu содержит два ссылочных параметра: cmd1 и cmd2 типа Command; эти параметры определяют два начальных элемента массива availCmds; третий элемент этого массива является макрокомандой (объектом типа MacroCommand), включающей команды cmd1 и cmd2 в указанном порядке. </p><p class="ptTaskContinue">Класс Menu содержит три метода: Invoke(cmdIndex), Undo(count) и Redo(count); методы имеют целочисленные параметры и не возвращают значений. </p><p class="ptTaskContinue">Метод Invoke(cmdIndex) <i>выполняет</i> команду из массива availCmds с индексом cmdIndex (при реализации этого метода можно считать, что параметр cmdIndex всегда находится в допустимом диапазоне&nbsp;0&#8211;2).  Кроме того, при выполнении метода Invoke из структуры lastCmds удаляются все конечные элементы, начиная с элемента с индексом undoIndex&nbsp;+&nbsp;1 (если такие элементы существуют), в конец структуры lastCmds добавляется ссылка на только что выполненную команду, а значение поля undoIndex полагается равным индексу добавленной команды. </p><p class="ptTaskContinue">Метод Undo(count) <i>отменяет</i> count выполненных команд, хранящихся в структуре lastCmds, начиная с команды с индексом undoIndex в направлении <i>уменьшения</i> индексов (если в структуре lastCmds содержится недостаточно элементов, то отменяются все доступные команды). Для каждой из этих команд вызывается метод Unexecute; кроме того, значение поля undoIndex корректируется так, чтобы оно соответствовало последней еще не отмененной команде (если отменены все команды из набора lastCmds, то значение undoIndex полагается равным&nbsp;&#8722;1). </p><p class="ptTaskContinue">Метод Redo(count) <i>восстанавливает</i> count ранее отмененных команд, выполняя метод Execute для элементов структуры lastCmds, начиная с команды с индексом undoIndex&nbsp;+&nbsp;1 в направлении <i>увеличения</i> индексов (если в структуре lastCmds содержится недостаточно элементов, то восстанавливаются все ранее отмененные команды). Кроме того, значение поля undoIndex корректируется так, чтобы оно соответствовало последней восстановленной команде. </p><p class="ptTaskContinue">Описанный механизм отмены/восстановления команд позволяет отменять и восстанавливать любое количество ранее выполненных команд (с сохранением их исходного порядка выполнения), однако при выполнении новой команды он блокирует возможность восстановления ранее отмененных команд (поскольку их результат может конфликтовать с результатом выполнения новой команды). </p><p class="ptTaskContinue">Даны два различных символа C1 и C2, которые могут принимать три значения: &#34;A&#34;, &#34;B&#34;, &#34;C&#34;. Символ C1 определяет тип первого параметра конструктора объекта Menu (значение &#34;A&#34; соответствует классу CommandA, значение &#34;B&#34;&nbsp;&#8212; классу CommandB, значение &#34;C&#34;&nbsp;&#8212; классу CommandC). Аналогичным образом, символ C2 определяет тип второго параметра конструктора объекта Menu. Используя указанную информацию, создать объект m типа Menu. </p><p class="ptTaskContinue">Также дано целое число N (&#8804;&nbsp;40), задающее количество методов объекта m для выполнения, и набор из N двухсимвольных строк, кодирующих требуемые методы. Первый символ каждой строки является одной из букв &#34;I&#34;, &#34;U&#34;, &#34;R&#34;, а второй символ является цифрой, причем в случае первого символа &#34;I&#34; возможны только цифры &#34;0&#34;, &#34;1&#34;, &#34;2&#34;, а в случае символов &#34;U&#34; и &#34;R&#34;&nbsp;&#8212; только цифры в диапазоне от &#34;1&#34; до &#34;9&#34;. Строки &#34;I0&#34;, &#34;I1&#34;, &#34;I2&#34; соответствуют методу Invoke с параметрами 0, 1, 2; строки, начинающиеся с символа &#34;U&#34;, соответствуют методу Undo, причем цифра определяет количество команд для отмены (например, строка &#34;U4&#34; соответствует методу Undo(4)); строки, начинающиеся с символа &#34;R&#34;, соответствуют методу Redo, а цифра определяет количество восстанавливаемых команд. </p><p class="ptTaskContinue">Выполнить в указанном порядке все методы для созданного объекта m типа Menu. Выводить какие-либо данные не требуется, так как вывод осуществляется в классах-получателях OperationA, OperationB и OperationC при выполнении соответствующих команд. </p><pre class="pt">public static class OperationA
{
    public static void ActionA()
    {
        Put(&quot;+A&quot;);
    }
    public static void UndoActionA()
    {
        Put(&quot;-A&quot;);
    }
}

public static class OperationB
{
    public static void ActionB()
    {
        Put(&quot;+B&quot;);
    }
    public static void UndoActionB()
    {
        Put(&quot;-B&quot;);
    }
}

public static class OperationC
{
    public static void ActionC()
    {
        Put(&quot;+C&quot;);
    }
    public static void UndoActionC()
    {
        Put(&quot;-C&quot;);
    }
}

public abstract class Command
{
    public abstract void Execute();
    public abstract void Unexecute();
}

// Implement the CommandA, CommandB, CommandC
//   and MacroCommand descendant classes

public class Menu
{
    // Add required fields
    public Menu(Command cmd1, Command cmd2)
    {
        // Implement the constructor
    }
    public void Invoke(int cmdIndex)
    {
        // Implement the method
    }
    public void Undo(int count)
    {
        // Implement the method
    }
    public void Redo(int count)
    {
        // Implement the method
    }
}</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav10°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPState.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPState.png" border=1></p><p class="ptTaskContinue"><b>State</b> (<b>Состояние</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: средняя. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: позволяет объекту варьировать свое поведение в зависимости от внутреннего состояния, которое определяется одним из нескольких объектов, связанных с конкретными состояниями и имеющими одинаковый интерфейс. Извне создается впечатление, что изменился класс объекта. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Context</i> (<i>Контекст</i>)&nbsp;&#8212; определяет интерфейс, представляющий интерес для клиентов; хранит экземпляр подкласса ConcreteState, которым определяется текущее состояние; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>State</i> (<i>Состояние</i>)&nbsp;&#8212; определяет интерфейс для инкапсуляции поведения, ассоциированного с конкретным состоянием контекста Context; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteStateA</i>, <i>ConcreteStateB</i> (<i>Конкретные состояния</i>)&nbsp;&#8212; реализуют поведение, ассоциированное с некоторым состоянием контекста Context. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать набор классов, связанных с разбором текста на основе паттерна State. Предполагается, что обрабатываемый текст включает обычное содержимое (токен Normal), строковые литералы, заключенные в двойные кавычки (токен String), и комментарии, заключенные в фигурные скобки (токен Comm). Фигурные скобки в строковых литералах считаются обычными символами, как и двойные кавычки в комментариях. Если в строковом литерале встречаются две двойных кавычки подряд, то они рассматриваются как обычный символ &#34;двойная кавычка&#34;, входящий в строковый литерал. Комментарии не являются вложенными; открывающая фигурная скобка внутри комментария рассматривается как обычный символ. </p><p class="ptTaskContinue">Признаком конца разбираемого текста является наличие точки, которая не считается входящей в сам текст. В токены String не включаются обрамляющие кавычки, в токены Comm не включаются обрамляющие фигурные скобки. Если последний строковый литерал или комментарий не заканчивается требуемым символом (кавычкой или фигурной скобкой соответственно), то подобный фрагмент текста считается <i>ошибочным токеном</i> ErrString или ErrComm соответственно; такой токен должен содержать символы от начала строкового литерала или комментария вплоть до завершающей точки (не включая эту точку). </p><p class="ptTaskContinue">Любые виды токенов могут быть пустыми; в начале и конце текста, а также между специальными токенами String и Comm обязательно присутствует токен Normal (возможно, пустой). Исключением являются ошибочные токены ErrString и ErrComm, после которых разбор текста завершается. </p><p class="ptTaskContinue">Иерархия классов-<i>состояний</i> включает абстрактный класс State с абстрактным методом GetNextToken (не имеет параметров, возвращает строку с описанием очередного токена разбираемого текста) и классы ConcreteStateNormal, ConcreteStateString, ConcreteStateComm и ConcreteStateFinal. Каждый конкретный класс, кроме класса ConcreteStateFinal, содержит поле ct&nbsp;&#8212; ссылку на объект Context&nbsp;&#8212; и поле index целого типа, которые инициализируются в конструкторе с использованием соответствующих параметров. Поле ct определяет объект, содержащий разбираемый текст, а поле index определяет индекс позиции, начиная с которой требуется продолжить разбор текста. </p><p class="ptTaskContinue">Метод GetNextToken возвращает строку, содержащую полученный токен (возможно, пустой), перед которым указывается его тип и двоеточие (например, &#34;Normal:abc&#34;, &#34;ErrString:mn2&#34;, &#34;Comm:&#34;). Класс ConcreteStateFinal не содержит полей, его конструктор не выполняет дополнительных действий, а метод GetNextToken всегда возвращает пустую строку. После определения текущего токена Normal метод GetNextToken класса ConcreteStateNormal вызывает метод SetState контекста ct, указывая в качестве параметра экземпляр класса ConcreteStateString (если обнаружен символ &#34;двойная кавычка&#34;), ConcreteStateComm (если обнаружен символ &#34;{&#34;) или ConcreteStateFinal (если обнаружен символ &#34;точка&#34;). После определения текущего <i>правильного</i> токена String или Comm метод GetNextToken классов ConcreteStateString и ConcreteStateComm вызывает метод SetState контекста ct, указывая в качестве параметра экземпляр класса ConcreteStateNormal. После определения <i>ошибочного</i> токена ErrString или ErrComm метод GetNextToken классов ConcreteStateString и ConcreteStateComm вызывает метод SetState контекста ct с экземпляром класса ConcreteStateFinal. </p><p class="ptTaskContinue">Класс-<i>контекст</i> Context содержит строковое поле text с разбираемым текстом и поле-ссылку currentState типа State. Конструктор класса имеет параметр text, используемый для инициализации поля text; поле currentState инициализируется объектом типа ConcreteStateNormal. Класс Context имеет методы GetCharAt(index), SetState(newState) и GetNextToken. Метод GetCharAt возвращает символ поля text с индексом index (предполагается, что индекс находится в допустимом диапазоне); метод SetState изменяет поле currentState, присваивая ему значение параметра newState (этот метод, наряду с методом GetCharAt, используется в методах классов-состояний); метод GetNextToken возвращает очередной токен разбираемого текста, вызывая одноименный метод объекта currentState. </p><p class="ptTaskContinue">Дана строка, которая оканчивается точкой. Используя объект ct типа Context, выполнить разбор данной строки, вызывая метод GetNextToken объекта ct и выводя его возвращаемый результат, пока очередной вызов не вернет пустую строку (пустую строку выводить не следует). </p><pre class="pt">public abstract class State
{
    public abstract string GetNextToken();
}

// Implement the ConcreteStateNormal, ConcreteStateString,
//   ConcreteStateComm and ConcreteStateFin descendant classes

// Implement the Context class</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav11°</span>. <b>State</b> (<b>Состояние</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 2</span>. Реализовать набор классов, связанных с моделированием работы автомата по продаже шариков (ball machine). </p><p class="ptTaskContinue">Иерархия классов-состояний включает абстрактный класс State с абстрактными методами, описывающими возможные действия с автоматом&nbsp;&#8212; InsertCoin (вложить монетку), GetBall (получить шарик), ReturnCoin (вернуть монетку), AddBall (добавить шарик в автомат), и набор конкретных классов, соответствующих различным возможным состояниям автомата: ReadyState (автомат содержит шарики и готов к приему монетки), HasPayedState (автомат получил монетку и готов выдать шарик или вернуть монетку), NoBallState (в автомате нет шариков). Все методы не имеют параметров и не возвращают значения. </p><p class="ptTaskContinue">Каждый конкретный класс содержит поле machine&nbsp;&#8212; ссылку на объект типа BallMachine; это поле инициализируется в конструкторе, имеющем одноименный параметр. Все переопределенные методы в каждом конкретном классе могут выводить соответствующее текстовое сообщение, изменять состояние автомата, вызывая для объекта machine его метод SetState с подходящим параметром, и выполнять другие действия. Ниже перечисляются действия всех методов для конкретных классов-состояний. </p><p class="ptTaskContinue">Класс ReadyState: </p><p class="ptTaskContinue">&#8226;&nbsp;метод InsertCoin выводит текст &#34;Coin is inserted&#34; (монетка получена) и переводит автомат в состояние HasPayedState; </p><p class="ptTaskContinue">&#8226;&nbsp;методы GetBall и ReturnCoin выводят текст &#34;You need to pay first&#34; (вначале заплатите); </p><p class="ptTaskContinue">&#8226;&nbsp;метод AddBall не выполняет никаких действий. </p><p class="ptTaskContinue">Класс HasPayedState: </p><p class="ptTaskContinue">&#8226;&nbsp;метод InsertCoin выводит текст &#34;You have already paid&#34; (вы уже заплатили); </p><p class="ptTaskContinue">&#8226;&nbsp;метод ReturnCoin выводит текст &#34;Take your coin&#34; (получите вашу монетку) и переводит автомат в состояние ReadyState; </p><p class="ptTaskContinue">&#8226;&nbsp;метод AddBall, как и для предыдущего класса, не выполняет никаких действий; </p><p class="ptTaskContinue">&#8226;&nbsp;метод GetBall выводит текст &#34;Take your ball&#34; (получите ваш шарик) и, кроме того, вызывает метод DecreaseBallCount объекта machine и анализирует его возвращаемое значение (равное оставшемуся количеству шариков): если это значение больше нуля, то автомат переводится в состояние ReadyState, в противном случае автомат переводится в состояние NoBallState. </p><p class="ptTaskContinue">Класс NoBallState: </p><p class="ptTaskContinue">&#8226;&nbsp;методы InsertCoin, GetBall и ReturnCoin выводят текст &#34;Sorry, balls are over&#34; (извините, шарики закончились); </p><p class="ptTaskContinue">&#8226;&nbsp;метод AddBall переводит автомат в состояние ReadyState и не выводит сообщений. </p><p class="ptTaskContinue">Класс BallMachine содержит поле ballCount целого типа (равное текущему количеству шариков), поля ready, hasPayed и noBall типа State (в которых содержатся ссылки на соответствующие объекты-состояния), а также поле currentState типа State (в котором содержится ссылка на текущее состояние). Поля инициализируются в конструкторе без параметров; полю ballCount присваивается значение 3, а для инициализации полей ready, hasPayed и noBall используются конструкторы соответствующих классов с параметром&nbsp;&#8212; ссылкой на создаваемый объект типа BallMachine. Кроме того, в конструкторе выполняется присваивание полю currentState значения ready. </p><p class="ptTaskContinue">Класс BallMachine содержит методы InsertCoin, GetBall, ReturnCoin, AddBall, в которых выполняется вызов одноименных методов объекта currentState; в методе AddBall дополнительно выводится текст &#34;Ball is added&#34; (шарик добавлен) и выполняется увеличение на&nbsp;1 поля ballCount. В классе также надо реализовать метод DecreaseBallCount без параметров, который уменьшает на&nbsp;1 поле ballCount и возвращает новое значение этого поля (метод DecreaseBallCount используется в методе GetBall класса HasPayedState), и метод SetState(newState), который присваивает полю currentState значение параметра newState. Для доступа на чтение к полям ready, hasPayed и noBall надо предусмотреть методы GetReadyState, GetHasPayedState и GetNoBallState (эти методы, совместно с методом SetState, используются в методах классов-состояний для изменения состояния объекта BallMachine). </p><p class="ptTaskContinue">Дана строка S, содержащая только символы &#34;I&#34;, &#34;G&#34;, &#34;R&#34;, &#34;A&#34;; каждый символ соответствует одной из команд автомата BallMachine: &#34;I&#34;&nbsp;&#8212; InsertCoin, &#34;G&#34;&nbsp;&#8212; GetBall, &#34;R&#34;&nbsp;&#8212; ReturnCoin, &#34;A&#34;&nbsp;&#8212; AddBall. Создать объект типа BallMachine и вызвать для него набор команд, соответствующий символам исходной строки S в порядке их следования в строке. Выводить какие-либо результаты не требуется, так как вывод осуществляется в методах, реализующих команды автомата. </p><pre class="pt">public abstract class State
{
    public abstract void InsertCoin();
    public abstract void GetBall();
    public abstract void ReturnCoin();
    public abstract void AddBall();
}

// Implement the ReadyState, HasPayedState
//   and NoBallState descendant classes

// Implement the BallMachine class</pre>
<h2>Mediator, Chain of&nbsp;Responsibility, Visitor, Interpreter</h2>
<p class="ptTask"><span class="ptSpecial">OOP3Behav12°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPMediator.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPMediator.png" border=1></p><p class="ptTaskContinue"><b>Mediator</b> (<b>Посредник</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: ниже средней. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: определяет объект, инкапсулирующий способ взаимодействия множества объектов. Посредник обеспечивает слабую связанность системы, избавляя объекты от необходимости явно ссылаться друг на друга и позволяя тем самым независимо изменять способы взаимодействия между ними. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Mediator</i> (<i>Посредник</i>)&nbsp;&#8212; определяет интерфейс для обмена информацией с объектами Colleague; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteMediator</i> (<i>Конкретный посредник</i>)&nbsp;&#8212; реализует кооперативное поведение, координируя действия объектов Colleague; владеет информацией о коллегах; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Colleague</i> (<i>Коллега</i>)&nbsp;&#8212; определяет интерфейс для взаимодействия с посредником; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteColleagueA</i>, <i>ConcreteColleagueB</i> (<i>Конкретные коллеги</i>)&nbsp;&#8212; знают о своем объекте Mediator; обмениваются информацией только с посредником (вместо того, чтобы общаться между собой напрямую). </p><p class="ptTaskContinue">Посредник реализует кооперативное поведение путем переадресации каждого запроса, посланного ему каким-либо коллегой, подходящему коллеге (одному или нескольким). </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать две иерархии классов, связанные с применением паттерна Mediator. Первая иерархия является иерархией классов-<i>коллег</i> и включает абстрактный класс Colleague и конкретные классы ConcreteColleague1 и ConcreteColleague2. </p><p class="ptTaskContinue">Класс Colleague содержит поле m, являющееся ссылкой на связанный с данным коллегой объект Mediator, и методы SetMediator(m) (не возвращает значения, инициализирует поле m одноименным параметром метода, также имеющим тип Mediator) и Notify (не имеет параметров и не возвращает значения, извещает посредник&nbsp;m о наступлении события путем вызова метода NotifyFrom объекта m, причем в качестве параметра метода NotifyFrom передается ссылка на объект, вызвавший метод Notify). В методе Notify перед вызовом метода NotifyFrom можно проверять, что поле m не является пустой ссылкой, хотя при согласованной работе коллег и посредников такая ситуация не должна возникать. Методы SetMediator и Notify не являются абстрактными, они реализуются в классе Colleague и наследуются всеми подклассами без каких-либо изменений. </p><p class="ptTaskContinue">Класс ConcreteColleague1 дополнительно содержит целочисленное поле data (инициализируется в конструкторе значением&nbsp;1), класс ConcreteColleague2 содержит строковое поле data (инициализируется в конструкторе строкой&nbsp;&#34;ab&#34;). Конкретные классы также содержат методы GetData и SetData, позволяющие обращаться к полю data на чтение и запись соответственно. Конструкторы классов ConcreteColleague1 и ConcreteColleague2 не имеют параметров. </p><p class="ptTaskContinue">Вторая иерархия является иерархией классов-<i>посредников</i>, связанных с ранее описанными классами-коллегами. Она включает абстрактный класс Mediator и конкретные классы ConcreteMediatorA и ConcreteMediatorB. Класс Mediator содержит абстрактный метод NotifyFrom(coll), имеющий параметр-ссылку типа Colleague и не возвращающий значений. Этот метод информирует посредник о событии, наступившем в объекте coll. Напомним, что именно этот метод должен вызываться в методе Notify каждого конкретного класса-коллеги. </p><p class="ptTaskContinue">Классы ConcreteMediatorA и ConcreteMediatorB реализуют два различных сценария взаимодействия объектов типа ConcreteColleague1 и ConcreteColleague2. Они создают набор взаимодействующих коллег, позволяют получать ссылки на них и обрабатывают связанные с ними события, изменяя состояние других коллег. Конструкторы классов ConcreteMediatorA и ConcreteMediatorB не имеют параметров. </p><p class="ptTaskContinue">Класс ConcreteMediatorA содержит поля c1 (типа ConcreteColleague1) и c2 (типа ConcreteColleague2). Объекты с1 и c2 создаются в конструкторе класса ConcreteMediatorA и связываются с объектом-посредником путем вызова методов SetMediator (с параметром, являющимся ссылкой на создаваемый объект ConcreteMediatorA). Для доступа к объектам c1 и c2 предусмотрены методы GetC1 и GetC2, возвращающие ссылки на соответствующие объекты, приведенные к типу Colleague. Метод NotifyFrom(coll) класса ConcreteMediatorA выполняет следующие действия: </p><p class="ptTaskContinue">&#8226;&nbsp;если параметр coll является ссылкой на поле c1, то к строковому полю data объекта c2 добавляется пробел и строковое представление поля data объекта c1; </p><p class="ptTaskContinue">&#8226;&nbsp;если параметр coll является ссылкой на поле c2, то числовое поле data объекта с1 увеличивается на текущую длину строкового поля data объекта c2. </p><p class="ptTaskContinue">В конце своей работы метод NotifyFrom выводит на экран текущие значения полей data объектов c1 и c2. </p><p class="ptTaskContinue">Класс ConcreteMediatorB содержит поля c1a и c1b (типа ConcreteColleague1) и c2 (типа ConcreteColleague2). Объекты с1a, c1b и c2 создаются в конструкторе класса ConcreteMediatorB (действия при их создании аналогичны действиям, описанным для класса ConcreteMediatorA). Для доступа к объектам предусмотрены методы GetC1a, GetC1b и GetC2, возвращающие ссылки на соответствующие объекты, приведенные к типу Colleague. Метод NotifyFrom(coll) класса ConcreteMediatorB выполняет следующие действия: </p><p class="ptTaskContinue">&#8226;&nbsp;если параметр coll является ссылкой на поле c1a, то числовое поле data объекта c1b увеличивается на значение поля data объекта c1a, а к строковому полю data объекта c2 добавляется символ &#34;a&#34;; </p><p class="ptTaskContinue">&#8226;&nbsp;если параметр coll является ссылкой на поле c1b, то числовое поле data объекта c1a увеличивается на значение поля data объекта c1b, а к строковому полю data объекта c2 добавляется символ &#34;b&#34;; </p><p class="ptTaskContinue">&#8226;&nbsp;если параметр coll является ссылкой на поле c2, то в поля data объектов c1a и c1b записываются числа, равные количеству символов &#34;a&#34; и &#34;b&#34; в строке data объекта c2 (например, если строка равна &#34;abaab&#34;, то в поле data объекта с1a записывается число&nbsp;3, а в поле data объекта c1b записывается число&nbsp;2). </p><p class="ptTaskContinue">В конце своей работы метод NotifyFrom выводит на экран текущие значения полей data объектов c1a, c1b и c2. </p><p class="ptTaskContinue">Создать объекты-посредники ma (типа ConcreteMediatorA) и mb (типа ConcreteMediatorB). Также создать структуру coll (например, массив) из пяти ссылок на элементы типа Colleague и записать в нее ссылки, возвращаемые следующими методами (в указанном порядке): ma.GetC1, ma.GetC2, mb.GetC1a, mb.GetC1b, mb.GetC2. Дано целое число N (&#8804;&nbsp;20) и набор из N целых чисел в диапазоне от 0 до 4, определяющих индексы элементов структуры coll. Для каждого числа K из данного набора выполнить вызов метода Notify для элемента структуры coll с индексом K. Выводить какие-либо результаты не требуется, так как вывод осуществляется в методах NotifyFrom объектов-посредников. </p><pre class="pt">public abstract class Colleague
{
    Mediator m;
    public void SetMediator(Mediator m)
    {
        this.m = m;
    }
    public void Notify()
    {
        m.NotifyFrom(this);
    }
}

// Implement the ConcreteColleague1
//   and ConcreteColleague2 descendant classes

public abstract class Mediator
{
    public abstract void NotifyFrom(Colleague coll);
}

// Implement the ConcreteMediatorA
//   and ConcreteMediatorB descendant classes</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav13°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPChain.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPChain.png" border=1></p><p class="ptTaskContinue"><b>Chain of Responsibility</b> (<b>Цепочка обязанностей</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: ниже средней. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: позволяет избежать привязки отправителя запроса к его получателю, давая шанс обработать запрос нескольким объектам. Связывает объекты-получатели в <i>цепочку</i> и передает запрос вдоль этой цепочки, пока его не обработают. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Handler</i> (<i>Обработчик</i>)&nbsp;&#8212; определяет интерфейс для обработки запросов; может (но не обязан) реализовывать связь с преемником; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteHandler</i> (<i>Конкретный обработчик</i>)&nbsp;&#8212; обрабатывает запрос, за который отвечает; имеет доступ к своему преемнику, которому направляет запрос, если не может его обработать самостоятельно; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Client</i> (<i>Клиент</i>)&nbsp;&#8212; отправляет запрос некоторому объекту ConcreteHandler в цепочке. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать иерархию классов-<i>обработчиков</i>, включающую абстрактный класс Handler и два конкретных класса ConcreteHandler1 и ConcreteHandler2. Класс Handler содержит абстрактный метод HandleRequest(req) (не возвращает значений, имеет параметр req целого типа, определяющий номер запроса). </p><p class="ptTaskContinue">Класс ConcreteHandler1 имеет поле successor&nbsp;&#8212; ссылку на объект Handler и три целочисленных поля: id (целочисленный идентификатор обработчика), req1 и req2 (определяют диапазон номеров запросов, которые может обработать данный обработчик). Все эти поля инициализируются в конструкторе с использованием параметров конструктора successor, id, req1, req2. Метод HandleRequest(req) класса ConcreteHandler1 выполняет следующие действия. Если его параметр req лежит в диапазоне от req1 до req2, то запрос обрабатывается путем вывода текста &#34;Request &lt;req&gt; processed by handler &lt;id&gt;&#34; (запрос &lt;req&gt; обработан обработчиком &lt;id&gt;), где на позициях &lt;req&gt; и &lt;id&gt; указываются значения параметра req и поля id. В противном случае выполняется вызов метода HandleRequest(req) для объекта successor (перед этим вызовом можно проверять, что поле successor не является пустой ссылкой, хотя при правильном построении цепочки обработчиков такая ситуация не должна возникать). </p><p class="ptTaskContinue">Класс ConcreteHandler2 является особым <i>терминальным</i> обработчиком, который должен находиться в конце цепочки обработчиков и к которому, таким образом, поступают все необработанные запросы. Он не имеет полей, его конструктор не выполняет дополнительных действий, а метод HandleRequest(req) выводит на экран текст &#34;Request &lt;req&gt; not processed&#34; (запрос &lt;req&gt; не обработан), где на позиции &lt;req&gt; указывается значение параметра req. </p><p class="ptTaskContinue">Вспомогательный класс Client содержит поле h&nbsp;&#8212; ссылку типа Handler на обработчик, являющийся первым в ранее сформированной цепочке обработчиков. Поле h инициализируется в конструкторе с помощью одноименного параметра. Класс Client также содержит метод SendRequest(req), имеющий целочисленный параметр req и не возвращающий значения; в этом методе выполняется вызов метода HandleRequest(req) для объекта h. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;10) и N пар целых чисел (r1,&nbsp;r2) (для любой пары выполняется неравенство r1&nbsp;&#8804;&nbsp;r2). Используя переменную&nbsp;h&nbsp;&#8212; ссылку на объект Handler, последовательно создать один объект типа ConcreteHandler2 и N&nbsp;объектов типа ConcreteHandler1. Ссылки на создаваемые объекты сохраняются в одной и той же переменной&nbsp;h; параметрами конструктора для объектов ConcreteHandler1 должны быть значения&nbsp;h,&nbsp;i, r1,&nbsp;r2, где&nbsp;i&nbsp;&#8212; индекс пары из исходного набора (пары индексируются от&nbsp;0), а&nbsp;r1 и&nbsp;r2&nbsp;&#8212; первый и второй элемент этой пары. В результате будет создана цепочка из N&nbsp;+&nbsp;1 обработчика, причем первым элементом этой цепочки (ссылка на который будет храниться в переменной&nbsp;h) будет обработчик типа ConcreteHandler1 с идентификатором N&nbsp;&#8722;&nbsp;1, предпоследним&nbsp;&#8212; обработчик типа ConcreteHandler1 с идентификатором&nbsp;0, а последним&nbsp;&#8212; обработчик типа ConcreteHandler2. Создать объект cli типа Client, указав в качестве параметра его конструктора значение ссылки&nbsp;h. </p><p class="ptTaskContinue">Также дано целое число K (&#8804;&nbsp;20) и набор из K&nbsp;различных целых чисел&nbsp;&#8212; номеров запросов. Для каждого запроса req из данного набора выполнить вызов метода SendRequest(req) объекта cli. Выводить какие-либо результаты не требуется, так как вывод осуществляется в методах HandleRequest объектов-обработчиков. </p><pre class="pt">public abstract class Handler
{
    public abstract void HandleRequest(int req);
}

// Implement the ConcreteHandler1
//   and ConcreteHandler2 descendant classes

public class Client
{
    Handler h;
    public Client(Handler h)
    {
        this.h = h;
    }
    public void SendRequest(int req)
    {
        h.HandleRequest(req);
    }
}</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav14°</span>. <b>Chain of Responsibility</b> (<b>Цепочка обязанностей</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue">В данном задании рассматривается вариант иерархии классов обработчиков, в которой базовый класс обеспечивает в методе HandleRequest всю необходимую функциональность для передачи запроса по цепочке обработчиков, а подклассы расширяют эту функциональность. Кроме того, в задании рассматривается вариант представления запросов в виде иерархии классов, инкапсулирующих параметры запроса. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 2</span>. Реализовать две иерархии классов, связанные с применением паттерна Chain of Responsibility. Первая иерархия является иерархией классов-<i>запросов</i> и включает абстрактный класс Request и два конкретных класса RequestA и RequestB. Класс Request содержит абстрактный метод ToStr без параметров, возвращающий строковое описание запроса. В классах RequestA и RequestB определено поле param, задающее параметр запроса, причем для класса A параметр является целочисленным, а для класса B&nbsp;&#8212; строковым. Поле param инициализируется в конструкторе с помощью одноименного параметра конструктора. Также в этих классах определен метод GetParam, возвращающий значение поля param, и метод ToStr, возвращающий описание запроса, включающее тип запроса (букву &#34;A&#34; или &#34;B&#34;), двоеточие и параметр запроса (целое число для запроса A и строку для запроса B), например, &#34;A:34&#34;, &#34;B:sm&#34;. </p><p class="ptTaskContinue">Вторая иерархия является иерархией классов-<i>обработчиков</i> и включает конкретный базовый класс Handler и классы-потомки HandlerA и HandlerB. Класс Handler содержит поле successor (ссылку на объект Handler) и метод HandleRequest(req) (не возвращает значений, имеет параметр-ссылку req типа Request, определяющий вид запроса). Метод HandleRequest работает следующим образом: если поле successor не является пустой ссылкой, то вызывается метод HandleRequest(req) для объекта successor, в противном случае выводится текст &#34;Request &lt;req&gt; not processed&#34; (запрос &lt;req&gt; не обработан), где на позиции &lt;req&gt; указывается значение, возвращаемое методом ToStr параметра req. Класс Handler имеет конструктор с параметром-ссылкой successor типа Handler, который инициализирует одноименное поле. Таким образом, данный класс обеспечивает всю необходимую функциональность для организации цепочки обработчиков. </p><p class="ptTaskContinue">Классы HandlerA и HandlerB предназначены для обработки запросов соответствующего типа (A или B) и имеют целочисленное поле id (идентификатор обработчика) и поля param1 и param2 (определяют диапазон параметров запросов, которые может обработать данный обработчик). Тип полей param1 и param2 соответствует типу параметра обрабатываемого запроса: для класса HandlerA это целый тип, для класса HandlerB&nbsp;&#8212; строковый. Конструктор классов HandlerA и HandlerB имеет четыре параметра: successor типа ссылки на Handler, id целого типа, param1 и param2 типа, соответствующего типу одноименных полей. В конструкторе вызывается конструктор базового класса с параметром successor и инициализируются поля id, param1 и param2. </p><p class="ptTaskContinue">Метод HandleRequest(req) классов HandlerA и HandlerB выполняет следующие действия. Вначале проверяется <i>тип времени выполнения</i> параметра req, и в случае, если этот тип соответствует типу обрабатываемого запроса (RequestA для HandlerA, RequestB для HandlerB), проверяется, лежит ли параметр param запроса req в диапазоне от param1 до param2 (строковые параметры для запроса RequestB сравниваются лексикографически). Если обе проверки являются успешными, то запрос обрабатывается путем вывода текста &#34;Request &lt;req&gt; processed by handler &lt;id&gt;&#34; (запрос &lt;req&gt; обработан обработчиком &lt;id&gt;), где на позиции &lt;req&gt; указывается значение, возвращаемое методом ToStr объекта req, а на позиции &lt;id&gt; указывается значение поля id обработчика. В противном случае выполняется вызов метода HandleRequest(req) базового класса (в котором либо происходит переход к следующему обработчику в цепочке, либо, при его отсутствии, выводится сообщение о невозможности обработать запрос). </p><p class="ptTaskContinue">Вспомогательный класс Client содержит поле h&nbsp;&#8212; ссылку типа Handler на обработчик, являющийся первым в ранее сформированной цепочке обработчиков. Поле h инициализируется в конструкторе с помощью одноименного параметра. Класс Client также содержит метод SendRequest(req), имеющий параметр-ссылку типа Request и не возвращающий значения; в этом методе выполняется вызов метода HandleRequest(req) для объекта&nbsp;h. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;10) и N троек элементов. В каждой тройке первый элемент является символом &#34;A&#34; или &#34;B&#34;, а тип остальных двух элементов (p1,&nbsp;p2) зависит от символа: в случае символа &#34;A&#34; это целые числа, а в случае &#34;B&#34;&nbsp;&#8212; строки. В любом случае выполняется неравенство p1&nbsp;&#8804;&nbsp;p2, где для чисел используется обычное сравнение, а для строк&nbsp;&#8212; лексикографическое. Используя переменную h&nbsp;&#8212; ссылку на объект Handler, последовательно создать один объект типа Handler (передав ему в качестве параметра пустую ссылку) и N объектов типа HandlerA или HandlerB (тип определяется первым элементом соответствующей тройки). Ссылки на создаваемые объекты записываются в одну и ту же переменную&nbsp;h; параметрами конструктора для объектов HandlerA и HandlerB должны быть значения&nbsp;h,&nbsp;i, p1,&nbsp;p2, где i&nbsp;&#8212; индекс очередной тройки из исходного набора (тройки индексируются от&nbsp;0), а p1 и p2&nbsp;&#8212; второй и третий элемент этой тройки. В результате будет создана цепочка из N&nbsp;+&nbsp;1 обработчика, причем первым элементом этой цепочки (ссылка на который будет храниться в переменной&nbsp;h) будет обработчик типа HandlerA или HandlerB с идентификатором N&nbsp;&#8722;&nbsp;1, предпоследним&nbsp;&#8212; обработчик типа HandlerA или HandlerB с идентификатором&nbsp;0, а последним&nbsp;&#8212; обработчик типа Handler (не имеющий идентификатора). Создать объект cli типа Client, указав в качестве параметра его конструктора значение ссылки h. </p><p class="ptTaskContinue">Также дано целое число K (&#8804;&nbsp;20) и набор из K&nbsp;различных запросов, определяемых парами элементов (c, p), где c&nbsp;&#8212; символ &#34;A&#34; или &#34;B&#34;, а p&nbsp;&#8212; параметр запроса (целочисленный в случае &#34;A&#34;, строковый в случае &#34;B&#34;). Для каждой пары создать запрос req соответствующего типа и выполнить вызов метода SendRequest(req) объекта cli. Выводить какие-либо результаты не требуется, так как вывод осуществляется в методах HandleRequest объектов-обработчиков. </p><pre class="pt">public abstract class Request
{
    public abstract string ToStr();
}

// Implement the RequestA and RequestB descendant classes

public class Handler
{
    Handler successor;
    public Handler(Handler successor)
    {
        this.successor = successor;
    }
    public virtual void HandleRequest(Request req)
    {
        // Implement the method
    }
}

// Implement the HandlerA and HandlerB descendant classes

public class Client
{
    Handler h;
    public Client(Handler h)
    {
        this.h = h;
    }
    public void SendRequest(Request req)
    {
        h.HandleRequest(req);
    }
}</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav15°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPVisitor.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPVisitor.png" border=1></p><p class="ptTaskContinue"><b>Visitor</b> (<b>Посетитель</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: низкая. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: описывает операцию, выполняемую с каждым объектом из некоторой структуры. Паттерн Visitor позволяет определить новую операцию, не изменяя классы этих объектов и используя различные варианты операции для объектов различных типов, входящих в одну структуру. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Visitor</i> (<i>Посетитель</i>)&nbsp;&#8212; объявляет группу методов Visit, в которой для каждого класса ConcreteElement в структуре объектов предусмотрен свой метод; имя метода (например, VisitConcreteElementA) и его параметр идентифицируют объект, который вызывает данный метод для отправки посетителю соответствующего запроса (это позволяет посетителю определить, элемент какого конкретного класса он посещает, и обращаться к элементу напрямую через его интерфейс); </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteVisitor1</i>, <i>ConcreteVisitor2</i> (<i>Конкретные посетители</i>)&nbsp;&#8212; реализуют все операции, объявленные в классе Visitor и связанные с обработкой объектов различных типов, содержащихся в обрабатываемой структуре; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Element</i> (<i>Элемент</i>)&nbsp;&#8212; определяет метод Accept, который принимает посетителя в качестве аргумента; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ConcreteElementA</i>, <i>ConcreteElementB</i> (<i>Конкретные</i> <i>элементы</i>)&nbsp;&#8212; реализуют метод Accept, принимающий посетителя как аргумент (как правило, в этом методе происходит вызов того метода из группы методов Visit указанного посетителя, который соответствует данному конкретному элементу); </p><p class="ptTaskContinue">&#8226;&nbsp;<i>ObjectStructure</i> (<i>Структура объектов</i>)&nbsp;&#8212; может перечислять свои элементы, а также предоставлять посетителю высокоуровневый интерфейс для посещения своих элементов. </p><p class="ptTaskContinue">Совместное использование методов Accept и группы методов Visit в паттерне Visitor обеспечивает <i>двойную диспетчеризацию</i> запросов, при которой характер запроса определяется двумя объектами: конкретным посетителем и конкретным элементом. Двойная диспетчеризация позволяет посетителю по-разному обрабатывать элементы различных классов. </p><p class="ptTaskContinue">Применение паттерна Visitor оправдано, если иерархия классов-элементов является стабильной (т.&nbsp;е. в нее редко добавляются новые классы) и при этом часто возникает необходимость в новых операциях, которые требуется по-разному выполнять для элементов различных типов. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать две иерархии классов, связанные с применением паттерна Visitor. Первая иерархия является иерархией классов-<i>элементов</i> и включает абстрактный класс Element, содержащий абстрактный метод Accept с параметром-ссылкой типа Visitor (не возвращает результата), и конкретные классы ConcreteElementA, ConcreteElementB, ConcreteElementC. Каждый конкретный класс содержит поле data; для класса ConcreteElementA оно целочисленное, для класса ConcreteElementB оно строковое, для класса ConcreteElementC оно является вещественным числом. Поле data инициализируется в конструкторе класса с помощью параметра data того же типа, что и инициализируемое поле. Конкретные классы-элементы&nbsp;A,&nbsp;B и&nbsp;C реализуют метод Accept(v), в котором для параметра&nbsp;v типа Visitor выполняется вызов соответствующего метода класса Visitor, определяемого типом класса-элемента: для элемента&nbsp;A это VisitConcreteElementA, для элемента&nbsp;B&nbsp;&#8212; VisitConcreteElementB, для элемента C&nbsp;&#8212; VisitConcreteElementC (параметром методов Visit является ссылка на объект, вызвавший метод Accept). </p><p class="ptTaskContinue">Кроме того, классы-элементы имеют методы для доступа на чтение и запись к полю data: метод GetData без параметров возвращает значение поля data, метод SetData с параметром newData изменяет значение поля data на значение параметра newData. Следует подчеркнуть, что методы GetData и SetData являются <i>специфическими</i> для каждого конкретного класса-элемента (в данном случае это аналоги специфических методов OperationA и OperationB, приведенных на диаграмме классов). </p><p class="ptTaskContinue">С иерархией классов-элементов также связан класс ObjectStructure. Поле struc этого класса является структурой (например, массивом) с элементами-ссылками на объекты типа Element (можно считать, что число элементов структуры struc не превосходит&nbsp;10). Поле struc инициализируется в конструкторе с помощью параметра struc того же типа. Класс ObjectStructure содержит метод Accept(v) с параметром-ссылкой типа Visitor. Этот метод перебирает все элементы структуры struc и для каждого элемента вызывает его метод Accept с параметром v. </p><p class="ptTaskContinue">Вторая иерархия является иерархией классов-<i>посетителей</i>, связанных с ранее описанными конкретными классами. Она включает абстрактный класс Visitor и конкретные классы ConcreteVisitor1, ConcreteVisitor2 и ConcreteVisitor3. Класс Visitor содержит три абстрактных метода: VisitConcreteElementA(e), VisitConcreteElementB(e), VisitConcreteElementC(e). Эти методы не возвращают значений; их параметрами являются ссылки на соответствующие объекты-элементы (например, VisitConcreteElementA имеет параметр типа ConcreteElementA). Напомним, что именно эти методы должны вызываться в методе Accept каждого конкретного класса-элемента. </p><p class="ptTaskContinue">Конкретные классы-посетители&nbsp;1, 2,&nbsp;3 реализуют различные наборы операций, связанных с классами-элементами&nbsp;A, B,&nbsp;C, определяя методы VisitConcreteElementA(e), VisitConcreteElementB(e), VisitConcreteElementC(e). Класс ConcreteVisitor1 обеспечивает <i>вывод</i> поля data в окно задачника, вызывая в каждом из указанных методов соответствующую команду вывода для значения GetData элемента&nbsp;e. Класс ConcreteVisitor2 <i>преобразует</i> поле data различным образом для разных классов-элементов, используя метод SetData элемента&nbsp;e: для элементов типа&nbsp;A он изменяет знак целого числа data на противоположный, для элементов типа&nbsp;B он изменяет порядок следования символов строки data на противоположный, для элементов типа&nbsp;C он изменяет любое ненулевое вещественное число data на обратное к нему (равное 1/data). Класс ConcreteVisitor3 определяет некоторую <i>общую характеристику</i> для всех однотипных элементов обрабатываемой структуры: для элементов типа&nbsp;A определяется сумма их целочисленных полей data, для элементов типа&nbsp;B находится строка, получаемая сцеплением всех строковых полей data, для элементов типа&nbsp;C находится произведение вещественных полей data. Для хранения полученных характеристик надо использовать в классе ConcreteVisitor3 поля resultA, resultB, resultC, а для доступа к ним&nbsp;&#8212; методы GetResultA, GetResultB, GetResultC. Конструкторы объектов-посетителей не имеют параметров и не выполняют дополнительных действий. </p><p class="ptTaskContinue">Дано целое число&nbsp;N (&#8804;&nbsp;10) и N&nbsp;пар значений. Первое значение каждой пары представляет собой символ &#34;A&#34;, &#34;B&#34; или &#34;C&#34;; он определяет тип создаваемого объекта-элемента (A,&nbsp;B или&nbsp;C). Второе значение каждой пары определяет поле data создаваемого элемента: для элемента типа&nbsp;A это целое число, для элемента типа&nbsp;B&nbsp;&#8212; строка, для элемента типа&nbsp;C&nbsp;&#8212; вещественное число. </p><p class="ptTaskContinue">Создать объект&nbsp;s типа ObjectStructure и поместить в него все исходные элементы. Также создать три объекта-посетителя&nbsp;v1, v2,&nbsp;v3 типа ConcreteVisitor1, ConcreteVisitor2, ConcreteVisitor3 соответственно. Вывести содержимое структуры&nbsp;s, используя вызов ее метода Accept(v1), после чего преобразовать это содержимое, используя вызов Accept(v2), и вывести преобразованное содержимое с помощью еще одного вызова Accept(v1). Затем вызвать метод Accept(v3) и вывести найденные в нем характеристики элементов структуры&nbsp;s с помощью методов GetResultA, GetResultB и GetResultC объекта&nbsp;v3. </p><pre class="pt">public abstract class Element
{
    public abstract void Accept(Visitor v);
}

public class ConcreteElementA : Element
{
    // Add required fields and methods
    public override void Accept(Visitor v)
    {
        // Implement the method
    }
}

public class ConcreteElementB : Element
{
    // Add required fields and methods
    public override void Accept(Visitor v)
    {
        // Implement the method
    }
}

public class ConcreteElementC : Element
{
    // Add required fields and methods
    public override void Accept(Visitor v)
    {
        // Implement the method
    }
}

public class ObjectStructure
{
    Element[] struc;
    public ObjectStructure(Element[] struc)
    {
        // Implement the constructor
    }
    public void Accept(Visitor v)
    {
        foreach (var e in struc)
            e.Accept(v);
    }
}

public abstract class Visitor
{
    public abstract void VisitConcreteElementA(ConcreteElementA e);
    public abstract void VisitConcreteElementB(ConcreteElementB e);
    public abstract void VisitConcreteElementC(ConcreteElementC e);
}

// Implement the ConcreteVisitor1, ConcreteVisitor2
//   and ConcreteVisitor3 descendant classes</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav16°</span>. </p><p class="ptPicture"><img src="file:///C:\Program Files (x86)\PT4\LIB\Graph\OOPInterpreter.png" alt="C:\Program Files (x86)\PT4\LIB\Graph\OOPInterpreter.png" border=1></p><p class="ptTaskContinue"><b>Interpreter</b> (<b>Интерпретатор</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Частота использования</span>: низкая. </p><p class="ptTaskContinue"><span class="ptSpecial">Назначение</span>: для заданного языка определяет представление его грамматики, а также интерпретатор предложений этого языка. </p><p class="ptTaskContinue"><span class="ptSpecial">Участники</span>: </p><p class="ptTaskContinue">&#8226;&nbsp;<i>AbstractExpression</i> (<i>Абстрактное выражение</i>)&nbsp;&#8212; объявляет абстрактную операцию Interpret, общую для всех узлов в абстрактном синтаксическом дереве; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>TerminalExpression</i> (<i>Терминальное выражение</i>)&nbsp;&#8212; реализует операцию Interpret для терминальных символов грамматики; необходим отдельный экземпляр для каждого терминального символа в предложении; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>NonterminalExpression</i> (<i>Нетерминальное выражение</i>)&nbsp;&#8212; по одному такому классу требуется для каждого грамматического правила вида <i>R</i>&nbsp;::=&nbsp;<i>R</i><sub>1</sub>&nbsp;<i>R</i><sub>2</sub>&nbsp;&#8230;&nbsp;<i>R</i><sub><i>n</i></sub>; хранит переменные экземпляра типа AbstractExpression для каждого символа от&nbsp;<i>R</i><sub>1</sub> до&nbsp;<i>R</i><sub><i>n</i></sub>; реализует операцию Interpret для нетерминальных символов грамматики (эта операция рекурсивно вызывает себя же для переменных, представляющих <i>R</i><sub>1</sub>,&nbsp;&#8230;, <i>R</i><sub><i>n</i></sub>); </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Context</i> (<i>Контекст</i>)&nbsp;&#8212; содержит информацию, глобальную по отношению к интерпретатору; </p><p class="ptTaskContinue">&#8226;&nbsp;<i>Client</i> (<i>Клиент</i>)&nbsp;&#8212; строит (или получает в готовом виде) абстрактное синтаксическое дерево разбора, представляющее отдельное предложение на языке с данной грамматикой (дерево составлено из экземпляров классов NonterminalExpression и TerminalExpression); вызывает операцию Interpret. </p><p class="ptTaskContinue">Поскольку разбор выражения не входит в задачу паттерна Interpreter (это может быть, например, задачей класса Client), в заданиях, связанных с этим паттерном, синтаксическое дерево разбора выражения предлагается в качестве одного из элементов исходных данных (что позволяет, в частности, рассмотреть вариант операции Interpret, обеспечивающий восстановление исходного выражения по его дереву разбора). </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 1</span>. Реализовать иерархию классов, которая определяет следующую грамматику арифметического выражения: </p><p class="ptTaskCenter"><table align="center"><tr><td align=left>&lt;expr&gt;  <td align=center><tt>::=</tt> <td align=left>&lt;const&gt; | &lt;var&gt; | &lt;math&gt;    <tr><td align=left>&lt;math&gt;  <td align=center><tt>::=</tt> <td align=left>(&lt;expr&gt;&lt;op&gt;&lt;expr&gt;)          <tr><td align=left>&lt;op&gt;    <td align=center><tt>::=</tt> <td align=left>+ | &#8722; | * | /               <tr><td align=left>&lt;const&gt; <td align=center><tt>::=</tt> <td align=left>&lt;вещественное число&gt;        <tr><td align=left>&lt;var&gt;   <td align=center><tt>::=</tt> <td align=left>&lt;имя вещественной переменной&gt;</table></p><p class="ptTaskContinue"></p><p class="ptTaskContinue">Иерархия классов содержит абстрактный класс AbstractExpression, класс NontermMath (<i>математическая операция</i>), определяющий нетерминальное выражение, и два класса, определяющих терминальные выражения: TermConst (<i>константа</i>) и TermVar (<i>переменная</i>). Класс AbstractExpression содержит абстрактные методы InterpretA(cont), InterpretB(cont), InterpretC(cont), определяющие три варианта интерпретации выражения (параметр-ссылка cont имеет тип Context, описываемый далее). Методы InterpretA и InterpretB возвращают строковое значение, метод InterpretC&nbsp;&#8212; вещественное число. В каждом конкретном классе (NontermMath, TermConst и TermVar) требуется переопределить эти абстрактные методы. </p><p class="ptTaskContinue">Интерпретация A состоит в <i>восстановлении</i> строкового представления арифметического выражения, удовлетворяющего приведенной выше грамматике, по его синтаксическому дереву разбора. Интерпретация B состоит в <i>конструировании</i> строкового представления для эквивалентного выражения, записанного в <i>бесскобочном формате</i>, в котором терминальные выражения const и var остаются прежними, а нетерминальная операция math принимает вид &lt;math&gt;&nbsp;<tt>::=</tt>&nbsp;&lt;expr&gt;&nbsp;&lt;expr&gt;&nbsp;&lt;op&gt; (между каждым элементом в правой части располагается пробел). Имена переменных для интерпретаций A и B берутся из контекста (экземпляра класса Context). Интерпретация C состоит в <i>вычислении</i> арифметического выражения, представленного синтаксическим деревом разбора; при этом значения переменных также берутся из контекста. </p><p class="ptTaskContinue">Примеры интерпретаций A, B, C для одного и того же синтаксического дерева: строка &#34;(10.50&#8722;((var1+6.00)*a))&#34;, строка &#34;10.50 var1 6.00 + a * &#8722;&#34;, число &#8722;9.5 (при условии, что контекст содержит переменные var1&nbsp;=&nbsp;4 и a&nbsp;=&nbsp;2). </p><p class="ptTaskContinue">Класс Context должен содержать два набора элементов размера&nbsp;10: строковый набор names с именами доступных переменных и набор вещественных чисел values со значениями соответствующих переменных (для хранения наборов можно использовать массив или другую структуру данных). Конструктор класса Context не имеет параметров; он заносит в набор names односимвольные имена переменных от&nbsp;a до&nbsp;j, а в набор values&nbsp;&#8212; значения 1.0. Класс Context включает три метода: SetVar(ind, name, value), GetName(ind), GetValue(ind). Параметр ind во всех методах определяет индекс обрабатываемой переменной (число от&nbsp;0 до&nbsp;9). Метод SetVar задает для переменной с индексом ind имя (строку name) и значение (вещественное число value). Метод GetName возвращает имя переменной с индексом ind, метод GetValue возвращает значение переменной с индексом ind. При реализации этих методов можно не проверять допустимость значений параметра ind, а также не контролировать возможную ошибочную ситуацию, когда два элемента набора name совпадают (т.&nbsp;е. когда две разные переменные имеют одинаковые имена). </p><p class="ptTaskContinue">Класс NontermMath содержит поля expr1 и expr2&nbsp;&#8212; ссылки на AbstractExpression (первый и второй операнд математической операции соответственно)&nbsp;&#8212; и поле op символьного типа (знак операции). Поля инициализируются в конструкторе с помощью одноименных параметров. </p><p class="ptTaskContinue">Класс TermConst содержит вещественное поле value, задаваемое в конструкторе, имеющем параметр value. В методах InterpretA и InterpretB этого класса должно возвращаться строковое представление поля value с двумя дробными знаками и точкой в качестве десятичного разделителя. </p><p class="ptTaskContinue">Класс TermVar содержит целочисленное поле ind&nbsp;&#8212; индекс переменной в некотором объекте-контексте. Это поле инициализируется в конструкторе с помощью параметра ind. Напомним, что контекст передается в качестве параметра во всех методах, выполняющих интерпретацию выражения (InterpretA, InterpretB и InterpretC). </p><p class="ptTaskContinue">Также определить класс Client, содержащий поля expr и cont&nbsp;&#8212; ссылки на AbstractExpression и Context, которые инициализируются в конструкторе с помощью соответствующих параметров. Класс Client включает три метода без параметров: InterpretA, InterpretB и InterpretC, в которых вызывается метод объекта expr с тем же именем и параметром cont и возвращается результат, полученный этим методом. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;30) и N наборов значений, каждый из которых определяет один узел синтаксического дерева разбора. Последующие узлы могут содержать ссылки на предыдущие узлы, поэтому все узлы следует сохранять в структуре nodes (например, массиве) с элементами-ссылками типа AbstractExpression. Каждый набор, соответствующий узлу синтаксического дерева, начинается с символа &#34;M&#34;, &#34;C&#34; или &#34;V&#34;. Объекту класса NontermMath соответствует символ &#34;M&#34;, за которым следуют три значения: индексы первого и второго операнда в уже заполненной части структуры nodes и символ операции (один из символов &#34;+&#34;, &#34;&#8722;&#34;, &#34;*&#34;, &#34;/&#34;). Индексирование элементов структуры nodes ведется от&nbsp;0. Объекту класса TermConst соответствует символ &#34;C&#34;, за которым следует вещественное число&nbsp;&#8212; значение константы. Объекту класса TermVar соответствует символ &#34;V&#34;, за которым следует индекс переменной в некотором контексте (целое число в диапазоне от&nbsp;0 до&nbsp;9). </p><p class="ptTaskContinue">Также дан набор значений, определяющих контекст: целое число M (&#8804;&nbsp;10) и M наборов троек (ind, name, val), в котором ind определяет индекс переменной в контексте, name определяет имя переменной, а val&nbsp;&#8212; ее значение (для остальных переменных контекста сохраняются имена и значения по умолчанию). </p><p class="ptTaskContinue">Используя исходные данные, сформировать элементы синтаксического дерева разбора и сохранить их в структуре nodes, создать объект cont типа Context и настроить его содержимое. После этого создать объект cl типа Client, передав его конструктору последний элемент структуры nodes и объект cont. Для объекта cl вызвать методы InterpretA, InterpretB и InterpretC и вывести их возвращаемые значения. </p><pre class="pt">public class Context
{
    // Add the constructor, required fields and methods
}

public abstract class AbstractExpression
{
    public abstract string InterpretA(Context cont);
    public abstract string InterpretB(Context cont);
    public abstract double InterpretC(Context cont);
}

// Implement the TermConst, TermVar
//   and NontermMath descendant classes

public class Client
{
    AbstractExpression expr;
    Context cont;
    public Client(AbstractExpression expr, Context cont)
    {
        this.expr = expr;
        this.cont = cont;
    }
    public string InterpretA()
    {
        return expr.InterpretA(cont);
    }
    public string InterpretB()
    {
        return expr.InterpretB(cont);
    }
    public double InterpretC()
    {
        return expr.InterpretC(cont);
    }
}</pre>
<p class="ptTask"><span class="ptSpecial">OOP3Behav17°</span>. <b>Interpreter</b> (<b>Интерпретатор</b>)&nbsp;&#8212; паттерн поведения. </p><p class="ptTaskContinue"><span class="ptSpecial">Задание 2</span>. Реализовать иерархию классов, которая определяет следующую грамматику строкового выражения: </p><p class="ptTaskCenter"><table align="center"><tr><td align=left>&lt;expr&gt;   <td align=center><tt>::=</tt> <td align=left>&lt;concat&gt; | &lt;if&gt; | &lt;loop&gt; | &lt;str&gt;        <tr><td align=left>&lt;concat&gt; <td align=center><tt>::=</tt> <td align=left>&lt;expr&gt;&lt;expr&gt; | &lt;concat&gt;&lt;expr&gt;          <tr><td align=left>&lt;if&gt;     <td align=center><tt>::=</tt> <td align=left>(var?&lt;expr&gt;:&lt;expr&gt;)                    <tr><td align=left>&lt;loop&gt;   <td align=center><tt>::=</tt> <td align=left>(var:&lt;expr&gt;)                           <tr><td align=left>&lt;str&gt;    <td align=center><tt>::=</tt> <td align=left>&lt;строка без символов &#34;(&#34;, &#34;)&#34;, &#34;?&#34;, &#34;:&#34;&gt;<tr><td align=left>&lt;var&gt;    <td align=center><tt>::=</tt> <td align=left>&lt;имя целочисленной переменной&gt;         </table></p><p class="ptTaskContinue"></p><p class="ptTaskContinue">Выражение concat возвращает конкатенацию нескольких выражений expr (двух или более); выражение if анализирует значение переменной var, и если var&nbsp;&#8800;&nbsp;0, то возвращает первое из указанных выражений expr, в противном случае возвращает второе из указанных выражений; выражение loop возвращает выражение expr, повторенное столько раз, каково значение переменной var (или пустую строку, если var&nbsp;&#8804;&nbsp;0). </p><p class="ptTaskContinue">Иерархия классов содержит абстрактный класс AbstractExpression, классы NontermConcat, NontermIf и NontermLoop, определяющие нетерминальные выражения concat, if, loop соответственно, и класс TermStr, определяющий терминальное выражение str. Класс AbstractExpression содержит два абстрактных метода InterpretA(cont) и InterpretB(cont), возвращающих строковое значение и определяющих два варианта интерпретации выражения (параметр-ссылка cont имеет тип Context, описываемый далее). В каждом конкретном классе (NontermConcat, NontermIf, NontermLoop и TermStr) требуется переопределить эти абстрактные методы. </p><p class="ptTaskContinue">Интерпретация A состоит в <i>восстановлении</i> строкового представления выражения, удовлетворяющего приведенной выше грамматике, по его синтаксическому дереву разбора; при этом имена переменных берутся из контекста (экземпляра класса Context). Интерпретация B состоит в <i>построении</i> конкретной строки по выражению, представленному синтаксическим деревом разбора; при этом значения переменных также берутся из контекста. </p><p class="ptTaskContinue">Примеры интерпретаций A и B для одного и того же синтаксического дерева разбора: строка &#34;abc(var1?(n:x):dd)yz&#34; и строка &#34;abcxxxxyz&#34; (при условии, что контекст содержит переменные var1&nbsp;=&nbsp;1 и n&nbsp;=&nbsp;4). </p><p class="ptTaskContinue">Класс Context должен содержать два набора элементов размера&nbsp;10: строковый набор names с именами доступных переменных и набор целых чисел values со значениями соответствующих переменных (для хранения наборов можно использовать массив или другую структуру данных). Конструктор класса Context не имеет параметров; он заносит в набор names односимвольные имена переменных от&nbsp;a до&nbsp;j, а в набор values&nbsp;&#8212; нулевые значения. Класс Context включает три метода: SetVar(ind, name, value), GetName(ind), GetValue(ind). Параметр ind во всех методах определяет индекс обрабатываемой переменной (число от&nbsp;0 до&nbsp;9). Метод SetVar задает для переменной с индексом ind имя (строку name) и значение (целое число value). Метод GetName возвращает имя переменной с индексом ind, метод GetValue возвращает значение переменной с индексом ind. При реализации этих методов можно не проверять допустимость значений параметра ind, а также не контролировать возможную ошибочную ситуацию, когда два элемента набора name совпадают (т.е. когда две разные переменные имеют одинаковые имена). </p><p class="ptTaskContinue">Класс NontermConcat содержит структуру exprs (например, массив) с элементами-ссылками типа AbstractExpression, которая инициализируется в конструкторе, имеющем соответствующий параметр-структуру. Можно считать, что выражение concat содержит не более 5 выражений expr. Класс NontermIf содержит поля expr1 и expr2&nbsp;&#8212; ссылки на AbstractExpression (первое и второе выражение expr в правой части определения выражения if)&nbsp;&#8212; и целочисленное поле ind&nbsp;&#8212; индекс переменной var в некотором объекте-контексте. Класс NontermLoop содержит поле expr&nbsp;&#8212; ссылку на AbstractExpression (выражение expr в правой части определения выражения loop)&nbsp;&#8212; и целочисленное поле ind&nbsp;&#8212; индекс переменной var в некотором объекте-контексте. Значения полей этих классов задаются в их конструкторах с помощью одноименных параметров. </p><p class="ptTaskContinue">Класс TermStr содержит строковое поле s, задаваемое в конструкторе с помощью строкового параметра. В методах InterpretA и InterpretB этого класса должно возвращаться значение поля&nbsp;s без каких-либо изменений. </p><p class="ptTaskContinue">Дано целое число N (&#8804;&nbsp;30) и N наборов значений, каждый из которых определяет один узел синтаксического дерева разбора. Последующие узлы могут содержать ссылки на предыдущие, поэтому все узлы следует сохранять в структуре nodes (например, массиве) с элементами-ссылками типа AbstractExpression. Каждый набор, соответствующий узлу синтаксического дерева, начинается с символа &#34;C&#34;, &#34;I&#34;, &#34;L&#34; или &#34;S&#34;. Объекту класса NontermConcat соответствует символ &#34;C&#34;, за которым следует целое число K (2&nbsp;&#8804;&nbsp;K&nbsp;&#8804;&nbsp;5) и K индексов узлов из уже заполненной части структуры nodes (индексирование элементов структуры nodes ведется от&nbsp;0); все узлы в указанном порядке должны входить в структуру exprs объекта NontermConcat. Объекту класса NontermIf соответствует символ &#34;I&#34;, за которым следует индекс V переменной в некотором контексте (целое число в диапазоне от&nbsp;0 до&nbsp;9) и индексы двух узлов из уже заполненной части структуры nodes. Объекту класса NontermLoop соответствует символ &#34;L&#34;, за которым следует индекс V переменной в некотором контексте и индекс некоторого узла из уже заполненной части структуры nodes. Наконец, объекту класса TermStr соответствует символ &#34;S&#34;, за которым следует строка&nbsp;&#8212; значение выражения str. </p><p class="ptTaskContinue">Также даны три набора значений, определяющих три различных контекста. Определение каждого контекста содержит целое число M (&#8804;&nbsp;10) и M наборов троек (ind, name, val), в которых ind определяет индекс переменной в контексте, name определяет имя переменной, а val&nbsp;&#8212; ее значение (для остальных переменных контекста сохраняются имена и значения по умолчанию). </p><p class="ptTaskContinue">Используя исходные данные, сформировать элементы синтаксического дерева разбора и сохранить их в структуре nodes, а также создать и настроить три объекта типа Context. Для последнего элемента структуры nodes вызвать методы InterpretA и InterpretB, указав в качестве параметра каждый из созданных контекстов, и вывести их возвращаемые значения (вначале выводятся значения, соответствующие первому контексту, затем второму, затем третьему). </p><pre class="pt">public class Context
{
    // Add the constructor, required fields and methods
}

public abstract class AbstractExpression
{
    public abstract string InterpretA(Context cont);
    public abstract string InterpretB(Context cont);
}

// Implement the TermStr, NontermConcat, NontermIf
//   and NontermLoop descendant classes</pre>
<hr noshade>
<p class="ptFooter">Page generation date: 2022/4/26.</p>
</body></html>
